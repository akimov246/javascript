<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Базовые операторы, математика</title>
    <link href="../../style.css" type="text/css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Термины: «унарный», «бинарный», «операнд»</h2>
        <ul>
            <li>
                <i>Операнд</i> - то, к чему применяется оператор. Например, в умножении <code>5 * 2</code> есть два операнда:
                левый операнд равен <code>5</code>, а правый операнд равен <code>2</code>. Иногда их называют «аргументами» вместо
                «операндов»;
            </li>
            <li>
                <i>Унарным</i> называют оператор, который применяется к одному оператору. Например, оператор унарный минус
                <code>"-"</code> меняет знак числа на противоположный;
            </li>
            <li>
                <i>Бинарным</i> называется оператор, который применяется к двум операндам.
            </li>
        </ul>
    </article>

    <article>
        <h2>Математика</h2>
        <p>Поддерживаются следующие математические операторы:</p>
        <ul>
            <li>Сложение <code>+</code></li>
            <li>Вычитание <code>-</code></li>
            <li>Умножение <code>*</code></li>
            <li>Деление <code>/</code></li>
            <li>Взятие остатка от деления <code>%</code></li>
            <li>Возведение в степень <code>**</code></li>
        </ul>
    </article>

    <article>
        <h2>Сложение строк при помощи бинарного +</h2>
        <p>Если бинарный оператор <code>+</code> применить к строкам, то он их объединяет в одну.</p>
        <p>Если хотя бы один операнд является строкой, то второй будет также преобразован в строку.</p>
        <p>НО <code>2 + 2 + '1'</code> // будет '41', а не '221'</p>
        <p>Здесь операторы работают один за другим. Первый <code>+</code> складывает два числа и возвращает <code>4</code>,
        затем следующий <code>+</code> объединяет результат со строкой, производя действие <code>4 + '1' = '41'</code>.</p>
        <p>Сложение и преобразование строк - это особенность бинарного плюса <code>+</code>. Другие арифметические операторы
        работают только с числами и всегда преобразуют операнды в числа.</p>
        <p>Например, вычитание и деление:</p>
        <code>alert(6 - '2');</code> // 4, '2' приводится к числу<br>
        <code>alert('6' / '2');</code> // 3, оба операнда приводятся к числам
    </article>

    <article>
        <h2>Приведение к числу, унарный +</h2>
        <p>Плюс <code>+</code> существует в двух формах: бинарной, которую мы использовали выше, и унарной.</p>
        <p>Унарный, то есть примененный к одному значению, плюс <code>+</code> ничего не делает с числами. Но если
        операнд не число, унарный плюс преобразует его в число.</p>
        <code>alert(+true); // 1</code><br>
        <code>alert(+'');</code> // 0
        <p>На самом деле это то же самое, что и <code>Number(...)</code>, только короче.</p>
    </article>

    <article>
        <h2>Приоритет операторов</h2>
        <p>В том случае, если в выражении есть несколько операторов - порядок их выполнения определяется <i>приоритетом</i>,
        или, другими словами, существует определенный порядок выполнения операторов.</p>
        <p>В JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше,
        выполнится раньше. Если приоритет одинаковый, то порядок выполнения - слева направо.</p>
    </article>

    <article>
        <h2>Присваивание</h2>
        <p>Оператор присваивания <code>=</code> имеет один из самых низких приоритетов.</p>
        <p>Именно поэтому, когда переменной что-либо присваивают, например <code>x = 2 * 2 + 1</code>, то сначала выполнится
        арифметика, а уже затем произойдет присваивание <code>=</code> с сохранением результата в <code>x</code>.</p>

        <h3>Присваивание = возвращает значение</h3>
        <p>Тот факт, что <code>=</code> является оператором, а не «магической» конструкцией языка, имеет интересные последствия.</p>
        <p>Большинство операторов в JavaScript возвращают значение. Для некоторых это очевидно, например сложение <code>+</code>
        или умножение <code>*</code>. Но и оператор присваивания не является исключением.</p>
        <p>Вызов <code>x = value</code> записывает <code>value</code> в <code>x</code> и <i>возвращает его</i>.</p>
        <p>Благодаря этому присваивание можно использовать как часть более сложного выражения:</p>
        <code>let a = 1;</code><br>
        <code>let b = 2;</code><br>
        <code>let c = 3 - (a = b + 1);</code><br>
        <code>alert(a);</code> // 3<br>
        <code>alert(c);</code> // 0
        <p>В примере выше результатом <code>(a = b + 1)</code> будет значение, которое присваивается переменной <code>a</code>
        (то есть <code>3</code>). Потом оно используется для дальнейших вычислений.</p>
        <p>Однако писать в таком стиле не рекомендуется.</p>

        <h3>Присваивание по цепочке</h3>
        <p>Рассмотрим еще одну интересную возможность: цепочку присваиваний.</p>
        <code>let a, b, c;</code><br>
        <code>a = b = c = 2 + 2;</code><br>
        <code>alert(a);</code> // 4<br>
        <code>alert(b);</code> // 4<br>
        <code>alert(c);</code> // 4
        <p>Такое присваивание работает справа налево. Сначала вычисляется самое правое выражение <code>2 + 2</code>, и затем
        результат присваивается переменным слева: <code>c</code>, <code>b</code> и <code>a</code>. В конце у всех переменных будет
        одно значение.</p>

        <h3>Сокращенная арифметика с присваиванием</h3>
        <p>Часто нужно применить оператор к переменной и сохранить результат в ней же.</p>
        <p>Для этого используются совмещенные операторы:</p>
        <ul>
            <li><code>+=</code></li>
            <li><code>-=</code></li>
            <li><code>*=</code></li>
            <li><code>/=</code></li>
            <li><code>%=</code></li>
            <li><code>**=</code></li>
        </ul>
        <p>Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после
        большинства других операций.</p>
    </article>

    <article>
        <h2>Инкремент/Декремент</h2>
        <p>Одной из наиболее частых операций является увеличение или уменьшение на единицу.</p>
        <p>Для этого существуют даже специальные операторы:</p>
        <ul>
            <li><b>Инкремент</b> <code>++</code> увеличивает переменную на 1;</li>
            <li><b>Декремент</b> <code>--</code> уменьшает переменную на 1.</li>
        </ul>
        <article class="warning">
            <h2>Важно:</h2>
            <p>Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++,
            приведет к ошибке.</p>
        </article>
        <p>Операторы <code>++</code> и <code>--</code> могут быть расположены не только после, но и до переменной.</p>
        <ul>
            <li>Когда оператор идет после переменной - это «постфиксная форма»: <code>counter++</code>;</li>
            <li>«Префиксная форма» - это когда оператор идет перед переменной: <code>++counter</code>.</li>
        </ul>
        <p>Обе эти инструкции делают одно и то же: увеличивают <code>counter</code> на <code>1</code>.</p>
        <p>Есть ли разница между ними? Да, но увидеть ее мы сможем, только если будем использовать значение, которое
        возвращают <code>++/--</code>.</p>
        <p>Как мы знаем, все операторы возвращают значение. Операторы инкремента/декремента не исключение. Префиксная форма
        возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).</p>
        <p>Чтобы увидеть разницу, вот небольшой пример:</p>
        <code>let counter = 1;</code><br>
        <code>let a = ++counter;</code> // (*)<br>
        <code>alert(a);</code> // 2
        <p>В строке <code>(*)</code> <i>префиксная форма</i> <code>++counter</code> увеличивает <code>counter</code> и
        возвращает новое значение <code>2</code>.</p>
        <p>Теперь посмотрим на постфиксную форму:</p>
        <code>let counter = 1;</code><br>
        <code>let a = counter++;</code> // (*)<br>
        <code>alert(a);</code> // 1
        <p>В строке <code>(*)</code> <i>постфиксная</i> форма <code>counter++</code> также увеличивает <code>counter</code>,
        но возвращает <i>старое</i> значение (которое было до увеличения).</p>
        <p>Подведем итоги:</p>
        <ul>
            <li>Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы,
            какую форму использовать;</li>
            <li>Если хочется тут же использовать результат, то нужна префиксная форма;</li>
            <li>Если нужно увеличить и при этом получить значение переменной <i>до увеличения</i> - нужна постфиксная форма.</li>
        </ul>

        <article class="note">
            <h2>Инкремент/декремент можно использовать в любых выражениях</h2>
            <p>Операторы <code>++/--</code> могут также использоваться внутри выражений. Их приоритет выше, чем у большинства
            других арифметических операций.</p>
            <p>Например:</p>
            <code>let counter = 1;</code><br>
            <code>alert(2 * ++counter);</code> // 4
            <p>Сравните с:</p>
            <code>let counter = 1;</code><br>
            <code>alert(2 * counter++);</code> // 2
            <p>Хотя технически здесь все в порядке, такая запись обычно делает код менее читабельным. Одна строка выполняет
            множество действий - нехорошо.</p>
        </article>
    </article>

    <article>
        <h2>Побитовые операции</h2>
        <p>Побитовые операторы работают с 32-разрядными целыми числами (при необходимости приводятся к ним),
        на уровне их внутреннего двоичного представления.</p>
        <p>Поддерживаются следующие побитовые операторы:</p>
        <ul>
            <li>AND(и) (<code>&</code>)</li>
            <li>OR(или) (<code>|</code>)</li>
            <li>XOR(побитовое исключающее или) (<code>^</code>)</li>
            <li>NOT(не) (<code>~</code>)</li>
            <li>LEFT SHIFT(левый сдвиг) (<code><<</code>)</li>
            <li>RIGHT SHIFT(правый сдвиг) (<code>>></code>)</li>
            <li>ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) (<code>>>></code>)</li>
        </ul>
        <p>Они используются редко, когда возникает необходимость оперировать с числами на очень низком (побитовом) уровне.</p>
    </article>

    <article>
        <h2>Оператор «запятая»</h2>
        <p>Оператор «запятая» (<code>,</code>) редко применяется и является одним из самых необычных. Иногда он используется
        для написания более короткого кода, поэтому нам нужно его знать, чтобы понимать, что при этом происходит.</p>
        <p>Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой <code>,</code>.
        Каждое выражение выполняется, но возвращается результат только последнего.</p>
        <p>Например:</p>
        <code>let a = (1 + 2, 3 + 4);</code><br>
        <code>alert(a);</code> // 7
        <p>Первое выражение <code>1 + 2</code> выполняется, а результат отбрасывается. Затем идем <code>3 + 4</code>,
        выражение выполняется и возвращается результат.</p>
        <article class="note">
            <h2>Запятая имеет очень низкий приоритет</h2>
            <p>Оператор <code>,</code> имеет очень низкий приоритет, ниже <code>=</code>, поэтому скобки важны в
            приведенном выше примере.</p>
            <code>a = 1 + 2, 3 + 4;</code><br>
            <code>alert(a);</code> // 3
            <p>Без скобок в <code>a = 1 + 2, 3 + 4</code> сначала выполнится <code>+</code>, суммируя числа в <code>a = 3, 7</code>,
            затем оператор присваивания <code>=</code> присвоит <code>a = 3</code>, а то, что идет дальше, будет проигнорировано.
            Все так же, как в <code>(a = 1 + 2), 3 + 4</code>.</p>
        </article>
        <p>Зачем нам оператор, который отбрасывает все, кроме последнего выражения?</p>
        <p>Иногда его используют в составе более сложных конструкций, чтобы сделать несколько действий в одной строке.</p>
    </article>
</body>
</html>