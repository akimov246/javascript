<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Тип данных Symbol</title>
    <link href="../../style.css" type="text/css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Тип данных Symbol</h2>
        <p>По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы.
        Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.</p>
    </article>

    <article>
        <h2>Символы</h2>
        <p>«Символ» представляет собой уникальный идентификатор.</p>
        <p>Создаются новые символы с помощью функции <code>Symbol()</code>:</p>
        <code>let id = Symbol();</code>
        <p>При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:</p>
        <code>let id = Symbol('id');</code>
        <p>Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это все равно
        будут разные символы. Описание - это просто метка, которая ни на что не влияет.</p>

        <article class="warning">
            <h2>Символы не преобразуются автоматически в строки</h2>
            <p>Большинство типов данных в JavaScript могут быть неявно преобразованы в строку. Например, функция
            <code>alert</code> принимает практически любое значение, автоматически преобразовывает его в строку, а затем
            выводит это значение, не сообщая об ошибке. Символы же особенные и не преобразуются автоматически.</p>
            <p>Это языковая «защита» от путаницы, ведь строки и символы - принципиально разные типы данных и не должны
            неконтролируемо преобразовываться друг в друга.</p>
            <p>Если же мы действительно хотим вывести символ с помощью <code>alert</code>, то необходимо явно преобразовать
            его с помощью метода <code>.toString()</code>, вот так:</p>
            <code>
                let id = Symbol('id');<br>
                alert(id.toString());
            </code>
            <p>Или мы можем обратиться к свойству <code>symbol.description</code>, чтобы вывести только описание:</p>
            <code>
                let id = Symbol('id');<br>
                alert(id.description);
            </code>
        </article>
    </article>

    <article>
        <h2>«Скрытые» свойства</h2>
        <p>Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их
        из другой части программы.</p>
        <p>Например, мы работаем с объектами <code>user</code>, которые принадлежат стороннему коду. Мы хотим добавить к
        ним идентификаторы.</p>
        <p>Используем для этого символьный ключ:</p>
        <code>
            let user {<br>
            &nbsp;&nbsp;name: 'Вася';<br>
            };<br>
            <br>
            let id = Symbol('id);<br>
            <br>
            user[id] = 1;<br>
        </code>
        <p>Почему же лучше использовать <code>Symbol('id')</code>, а не строку <code>'id'</code>?</p>
        <p>Так как объект <code>user</code> принадлежит стороннему коду, и этот код также работает с ним, то нам не следует
        добавлять к нему какие-либо поля. Это небезопасно. Но к символу сложно нечаянно обратиться, сторонний код вряд ли
        его вообще увидит, и, скорее всего, добавление поля к объекту не вызовет никаких проблем.</p>
        <p>Кроме того, предположим, что другой скрипт для каких-то своих целей хочет записать собственный идентификатор в
        объект <code>user</code>. Этот скрипт может быть какой-то JavaScript-библиотекой, абсолютно не связанной с нашим скриптом.</p>
        <p>Сторонний код может создать для этого свой символ <code>Symbol('id')</code>:</p>
        <code>
            let id = Symbol('id);<br>
            user[id] = 'Их идентификатор';
        </code>
        <p>Конфликта между их и нашим идентификатором не будет, так как символы всегда уникальны, даже если их имена совпадают.</p>
        <p>А вот если бы использовали строку <code>'id'</code> вместо символа, то тогда бы был конфликт.</p>
    </article>

    <article>
        <h2>Символы в литеральном объекте</h2>
        <p>Если мы хотим использовать символ при литеральном объявлении объекта <code>{ ... }</code>, его необходимо
        заключать в квадратные скобки.</p>
        <p>Вот так:</p>
        <code>
            let id = Symbol('id');<br>
            <br>
            let user = {<br>
            &nbsp;&nbsp;name: 'Вася';<br>
            &nbsp;&nbsp;[id] = 123;
            };
        </code>
        <p>Это вызвано тем, что нам нужно использовать значение переменной <code>id</code> в качестве ключа, а не строку «id».</p>
    </article>

    <article>
        <h2>Символы игнорируются циклом for...in</h2>
        <p>Свойства, чьи ключи - символы, не перебираются циклом <code>for...in</code>.</p>
        <p>Это часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут работать
        с нашим объектом, то при переборе они не получат ненароком наше символьное свойство. <code>Object.keys(user)</code>
        также игнорирует символы.</p>
        <p>А вот <code>Object.assign()</code>, в отличие от цикла <code>for...in</code>, копирует и строковые, и символьные
        свойства.</p>
        <p>Здесь нет никакого парадокса или противоречия. Так и задумано. Идея заключается в том, что, когда мы клонируем или
        объединяем объекты, мы обычно хотим скопировать все свойства (включая такие свойства с ключами-символами).</p>
    </article>

    <article>
        <h2>Глобальные символы</h2>
        <p>Итак, как мы видели, обычно все символы уникальны, даже если их имена совпадают. Но иногда мы наоборот хотим,
        чтобы символы с одинаковыми именами были одной сущностью. Например, разные части нашего приложения хотят получить
        доступ к символу <code>'id'</code>, подразумевая именно одно и то же свойство.</p>
        <p>Для этого существует <i>глобальный реестр символов</i>. Мы можем создавать в нем символы и обращаться к ним позже,
        а при каждом обращении нам гарантированно будет возвращаться один и тот же символ.</p>
        <p>Для чтения (или, при отсутствии, создания) символа из реестра используется вызов <code>Symbol.for(key)</code>.</p>
        <p>Он проверяет глобальный реестр и, при наличии в нем символа с именем <code>key</code>, возвращает его, иначе же
        создает новый символ <code>Symbol(key)</code> и записывает в реестр под ключом <code>key</code>.</p>
        <p>Например:</p>
        <code>
            let id = Symbol.for('id');<br>
            <br>
            let idAgain = Symbol.for('id')<br>
            <br>
            alert(id === idAgain); // true
        </code>
        <p>Символы, содержащиеся в реестре, называются <i>глобальными символами</i>. Если вам нужен символ, доступный везде
        в коде - используйте глобальные символы.</p>
    </article>

    <article>
        <h2>Symbol.keyFor</h2>
        <p>Для глобальных символов, кроме <code>Symbol.for(key)</code>, который ищет символ по имени, существует
        обратный метод: <code>Symbol.keyFor(sym)</code>, который, наоборот, принимает глобальный символ и возвращает его имя.</p>
        <p>К примеру:</p>
        <code>
            let sym = Symbol('id');<br>
            alert(Symbol.keyFor(sym)); // 'id'
        </code>
        <p>Внутри метода <code>Symbol.keyFor</code> используется глобальный реестр символов для нахождения имени символа.
        Так что этот метод не будет работать для неглобальных символов. Если символ неглобальный, метод не сможет его найти
        и вернет <code>undefined</code>.</p>
        <p>Впрочем, для любых символов доступно свойство <code>description</code>.</p>
    </article>

    <article>
        <h2>Системные символы</h2>
        <p>Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их,
        чтобы настраивать различные аспекты поведения объектов.</p>
        <p>Эти символы перечислены в спецификации в таблице <b>Well-known symbols</b>:</p>
        <ul>
            <li><code>Symbol.hasInstance</code></li>
            <li><code>Symbol.isConcatSpreadable</code></li>
            <li><code>Symbol.iterator</code></li>
            <li><code>Symbol.toPrimitive</code></li>
            <li>И так далее...</li>
        </ul>
        <p>В частности, <code>Symbol.toPrimitive</code> позволяет описать правила объекта, согласно которым он будет
        преобразовываться к примитиву.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Символ (symbol) - примитивный тип данных, использующийся для создания уникальных идентификаторов.</p>
        <p>Символы создаются вызовом функции <code>Symbol()</code>, в которую можно передать описание (имя) символа.</p>
        <p>Даже если символы имеют одно и то же имя, это разные символы. Если мы хотим, чтобы одноименные символы были равны,
        то следует использовать глобальный реестр: вызов <code>Symbol.for(key)</code> возвращает (или создает) глобальный символ
        с именем <code>key</code> в качестве имени. Многократные вызовы команды <code>Symbol.for</code> с одним и тем же
        аргументом возвращают один и тот же символ.</p>
        <p>Символы имеют два основных варианта использования:</p>
        <ol>
            <li>
                <p>«Скрытые» свойства объектов.</p>
                <p>Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем
                создать символ и использовать его в качестве ключа. Символьное свойство не появится в <code>for...in</code>,
                так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением,
                так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи
                или использования.</p>
                <p>Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.</p>
            </li>
            <li><p>Существует множество системных символов, используемых внутри JavaScript, доступных как <code>Symbol.*</code>.
            Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов.</p></li>
        </ol>
        <p>Технически символы скрыты не на 100%. Существует встроенный метод <code>Object.getOwnPropertySymbols(obj)</code> -
        с его помощью можно получить все свойства объекта с ключами-символами. Также существует метод
        <code>Reflect.ownKeys(obj)</code>, который возвращает все ключи объекта, включая символьные. Так что они не совсем
        спрятаны. Но большинство библиотек, встроенные методы и синтаксические конструкции не используют эти методы.</p>
    </article>
</body>
</html>