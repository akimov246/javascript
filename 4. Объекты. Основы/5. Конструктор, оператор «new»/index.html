<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Конструктор, оператор «new»</title>
    <link href="../../style.css" type="text/css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Конструктор, оператор «new»</h2>
        <p>Обычный синтаксис <code>{ ... }</code> позволяет создать только один объект. Но зачастую нам нужно создать множество
        похожих, однотипных объектов, таких как пользователи, элементы меню и так далее.</p>
        <p>Это можно сделать при помощи функции-конструктора и оператора <code>new</code>.</p>
    </article>

    <article>
        <h2>Функция-конструктор</h2>
        <p>Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:</p>
        <ol>
            <li>Имя функции-конструктора должно начинаться с большой буквы.</li>
            <li>Функция-конструктор должна выполняться только с помощью оператора <code>new</code>.</li>
        </ol>
        <p>Например:</p>
        <code>
            function User(name) {<br>
            &nbsp;&nbsp;this.name = name;<br>
            &nbsp;&nbsp;this.isAdmin = false;<br>
            }<br>
            <br>
            let user = new User('Jack');
        </code>
        <p>Когда функция вызывается как <code>new User(...)</code>, происходит следующее:</p>
        <ol>
            <li>Создается новый пустой объект, и он присваивается <code>this</code>.</li>
            <li>Выполняется тело функции. Обычно оно модифицирует <code>this</code>, добавляя туда новые свойства.</li>
            <li>Возвращается значение <code>this</code>.</li>
        </ol>
        <p>Теперь если нам будет необходимо создать других пользователей, мы можем просто вызвать <code>new User('Ann')</code>,
        <code>new User('Alice')</code> и так далее. Данная конструкция гораздо удобнее и читабельнее, чем многократное
        создание литерала объекта.</p>
        <p>Это и является основной целью конструкторов - реализовать код для многократного создания однотипных объектов.</p>
        <p>Технически любая функция (кроме стрелочных функций, поскольку у них нет <code>this</code>) может использоваться
        в качестве конструктора. Его можно запустить с помощью <code>new</code>, и он выполнит выше указанный алгоритм.
        Подобные функции должны начинаться с большой буквы - это общепринятое соглашение, чтобы было ясно, что функция
        должна вызываться с помощью <code>new</code>.</p>

        <article class="note">
            <h2>new function() { ... }</h2>
            <p>Если в нашем коде большое присутствует большое количество строк, создающих один сложный объект, то мы
            можем обернуть их в функцию-конструктор, которая будет немедленно вызвана, вот так:</p>
            <code>
                let user = new function() {<br>
                &nbsp;&nbsp;this.name = 'John';<br>
                &nbsp;&nbsp;this.isAdmin = false;<br>
                };
            </code>
            <p>Такой конструктор не может быть вызван снова, так как он нигде не сохраняется, просто создается и тут же
            вызывается. Таким образом, этот трюк направлен на инкапсуляцию кода, которые создает отдельный объект,
            без возможности повторного использования в будущем.</p>
        </article>
    </article>

    <article>
        <h2>Проверка на вызов в режиме конструктора: new.target</h2>
        <p>Используя специальное свойство <code>new.target</code> внутри функции, вы можете проверить, вызвана ли функция
        при помощи оператора <code>new</code> или без него.</p>
        <p>В случае обычного вызова функции <code>new.target</code> будет <code>undefined</code>. Если же она была вызвана
        при помощи <code>new</code>, <code>new.target</code> будет равен самой функции.</p>
        <p>Это можно использовать внутри функции, чтобы узнать, была ли она вызвана при помощи <code>new</code>,
        «в режиме конструктора», или без него, «в обычном режиме».</p>
        <p>Также мы можем сделать, чтобы вызовы с <code>new</code> и без него делали одно и то же:</p>
        <code>
            function User(name) {<br>
            &nbsp;&nbsp;if (!new.target) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return new User(name);<br>
            &nbsp;&nbsp;}<br>
            <br>
            &nbsp;&nbsp;this.name = name;<br>
            }<br>
        </code>
        <p>Такой подход иногда используется в библиотеках, чтобы сделать синтаксис более гибким. Чтобы люди могли вызывать функцию
        с <code>new</code> и без него, и она все еще могла работать.</p>
        <p>Впрочем, вероятно, это не очень хорошая практика использовать этот трюк везде, так как отсутствие <code>new</code>
        может ввести разработчика в заблуждение. С <code>new</code> мы точно знаем, что создается новый объект.</p>
    </article>

    <article>
        <h2>Возврат значения из конструктора, return</h2>
        <p>Обычно конструкторы не имеют оператора <code>return</code>. Их задача - записать все необходимое в <code>this</code>,
        и это автоматически становится результатом.</p>
        <p>Но если <code>return</code> все же есть, то применяется простое правило:</p>
        <ul>
            <li>При вызове <code>return</code> с объектом, вместо <code>this</code> вернется объект.</li>
            <li>При вызове <code>return</code> с примитивным значением, оно проигнорируется.</li>
        </ul>
        <p>Другими словами, <code>return</code> с объектом возвращает этот объект, во всех остальных случаях возвращается
        <code>this</code>.</p>
    </article>

    <article>
        <h2>Создание методов в конструкторе</h2>
        <p>Использование конструкторов для создания объектов дает большую гибкость. Функции-конструкторы могут иметь
        параметры, определяющие, как создать объект и что в него записывать.</p>
        <p>Конечно, мы можем добавить к <code>this</code> не только свойства, но и методы.</p>
        <p>Например, <code>new User(name)</code> ниже создаст объект с заданным <code>name</code> и методом <code>sayHi</code>:</p>
        <code>
            function User(name) {<br>
            &nbsp;&nbsp;this.name = name;<br>
            <br>
            &nbsp;&nbsp;this.sayHi = function() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;alert('Привет!');<br>
            &nbsp;&nbsp;};<br>
            }
        </code>
    </article>

    <article>
        <h2>Итого</h2>
        <ul>
            <li>Функции-конструкторы или просто конструкторы, являются обычными функциями, но существует общепринятое соглашение
            именовать их с большой буквы.</li>
            <li>Функции-конструкторы следует вызывать только с помощью <code>new</code>. Такой вызов подразумевает создание
            пустого <code>this</code> в начале и возврат заполненного в конце.</li>
        </ul>
        <p>Мы можем использовать конструкторы для создания множества похожих объектов.</p>
    </article>

    <script src="script.js"></script>
</body>
</html>