<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Событийный цикл: микрозадачи и макрозадачи</title>
    <link href="../../../style.css" rel="stylesheet">
    <script defer src="../../../highlightElements.js"></script>
</head>
<body>
    <article>
        <h2>Событийный цикл: микрозадачи и макрозадачи</h2>
        <p>Поток выполнения в браузере, равно как и в Node.js, основан на <i>событийном цикле</i>.</p>
        <p>Понимание работы событийного цикла важно для оптимизаций, иногда для правильной архитектуры.</p>
        <p>В этой главе мы сначала разберем теорию, а затем рассмотрим ее практическое применение.</p>
    </article>

    <article>
        <h2>Событийный цикл</h2>
        <p>Идея <i>событийного цикла</i> очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает
        задачи, исполняет их и снова ожидает появления новых.</p>
        <p>Общий алгоритм движка:</p>
        <ol>
            <li>
                <p>Пока есть задачи:</p>
                <ul>
                    <li>
                        <p>Выполнить их, начиная с самой старой.</p>
                    </li>
                </ul>
            </li>
            <li>
                <p>Бездействовать до появления новой задачи, а затем перейти к пункту 1.</p>
            </li>
        </ol>
        <p>Это формализация того, что мы наблюдаем, просматривая веб-страницу. Движок JavaScript большую часть времени
        ничего не делает и работает, только если требуется исполнить скрипт/обработчик или обработать событие.</p>
        <p>Примеры задач:</p>
        <ul>
            <li>
                <p>Когда загружается внешний скрипт <code>&lt;script src="..."&gt;</code>, то задача - это выполнение
                этого скрипта.</p>
            </li>
            <li>
                <p>Когда пользователь двигает мышь, задача - сгенерировать событие <code>mousemove</code> и выполнить его
                обработчики.</p>
            </li>
            <li>
                <p>Когда истечет таймер, установленный с помощью <code>setTimeout(func, ...)</code>, задача - это
                выполнение функции <code>func</code>.</p>
            </li>
            <li>
                <p>И так далее.</p>
            </li>
        </ul>
        <p>Задачи поступают на выполнение - движок выполняет их - затем ожидает новые задачи (во время ожидания практически
        не нагружается процессор компьютера).</p>
        <p>Может случиться так, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь.</p>
        <p>Очередь, которую формируют такие задачи, называют «очередью макрозадач» (macrotask queue, термин
        <a target="_blank" href="https://v8.dev/">V8</a>).</p>
        <img src="https://learn.javascript.ru/article/event-loop/eventLoop.svg" alt style="width: 40vw">
        <p>Например, когда движок занят выполнением скрипта, пользователь может передвинуть мышь, тем самым
        вызвав появление события <code>mousemove</code>, или может истечь таймер, установленный <code>setTimeout</code>,
        и т.п. Эти задачи формируют очередь, как показано на иллюстрации выше.</p>
        <p>Задачи из очереди исполняются по правилу «первым пришел - первым ушел». Когда браузер заканчивает выполнение
        скрипта, он обрабатывает событие <code>mousemove</code>, затем выполняет обработчик, заданный <code>setTimeout</code>,
        и так далее.</p>
        <p>Пока что все просто, не правда ли?</p>
        <p>Отметим две детали:</p>
        <ol>
            <li>
                <p>Рендеринг (отрисовка страницы) никогда не происходит во время выполнения задачи движком. Не имеет значения,
                сколь долго выполняется задача. Изменения в DOM отрисовываются только после того, как задача выполнена.</p>
            </li>
            <li>
                <p>Если задача выполняется очень долго, то браузер не может выполнить другие задачи, обрабатывать
                пользовательские события, поэтому спустя некоторое время браузер предлагает «убить» долго выполняющуюся
                задачу. Такое возможно, когда в скрипте много сложных вычислений или ошибка, ведущая к бесконечному циклу.</p>
            </li>
        </ol>
        <p>Это была теория. Теперь давайте взглянем, как можно применить эти знания.</p>
    </article>

    <article>
        <h2>Пример 1: разбиение «тяжелой» задачи</h2>
        <p>Допустим, у нас есть задача, требующая значительных ресурсов процессора.</p>
        <p>Например, подсветка синтаксиса (используется для выделения цветом участков кода на этой странице) - довольно
        процессороемкая задача. Для подсветки кода надо выполнить синтаксический анализ, создать много элементов
        для цветного выделения, добавить их в документ - для большого текста это требует значительных ресурсов.</p>
        <p>Пока движок занят подсветкой синтаксиса, он не может делать ничего, связанного с DOM, не может обрабатывать
        пользовательские события и т.д. Возможно даже «подвисание» браузера, что совершенно неприемлемо.</p>
        <p>Мы можем избежать этого, разбив задачу на части. Сделать подсветку для первых 100 строк, затем запланировать
        <code>setTimeout</code> (с нулевой задержкой) для разметки следующих 100 строк и т.д.</p>
        <p>Чтобы продемонстрировать такой подход, давайте будем использовать для простоты функцию, которая считает
        от <code>1</code> до <code>1000000000</code>.</p>
        <p>Если вы запустите код ниже, движок «зависнет» на некоторое время. Для серверного JS это будет явно заметно,
        а если вы будете выполнять код в браузере, то попробуйте понажимать другие кнопки на странице - вы заметите,
        что никакие другие события не обрабатываются до завершения функции счета.</p>
<pre><code class="language-javascript">let i = 0;

let start = Date.now();

function count() {
    // Делаем тяжелую работу
    for (let j = 0; j < 1e9; j++) {
        i++;
    }

    alert(`Done in ${Date.now() - start}ms`);
}

count();</code></pre>
        <div style="margin: 0.5rem">
            <button>Запустить пример</button>
        </div>
        <script>
            document.currentScript.previousElementSibling.firstElementChild.addEventListener('pointerdown', async function() {
                let module = await import('./scripts/example1.1.js');
                module.default();
            });
        </script>
        <p>Браузер может даже показать сообщение «скрипт выполняется слишком долго».</p>
        <p>Давайте разобьем задачу на части, воспользовавшись вложенным <code>setTimeout</code>:</p>
<pre><code class="language-javascript">let i = 0;

let start = Date.now();

function count() {
    // Делаем часть тяжелой работы (*)
    do {
        i++;
    } while (i % 1e6 !== 0);

    if (i === 1e9) {
        alert(`Done in ${Date.now() - start}ms`;
    } else {
        setTimeout(count); // Планируем новый вызов (**)
    }
}

count();</code></pre>
        <div style="margin: 0.5rem">
            <button>Запустить пример</button>
        </div>
        <script>
            document.currentScript.previousElementSibling.firstElementChild.addEventListener('pointerdown', async function() {
                let module = await import('./scripts/example1.2.js');
                module.default();
            });
        </script>
        <p>Теперь интерфейс браузера полностью работоспособен во время выполнения «счета».</p>
        <p>Один вызов <code>count</code> делает часть работы <code>(*)</code>, а затем, если необходимо, планирует свой
        очередной запуск <code>(**)</code>:</p>
        <ol>
            <li>
                <p>Первое выполнение производит счет: i = 1...1000000.</p>
            </li>
            <li>
                <p>Второе выполнение производит счет: i = 1000001...2000000.</p>
            </li>
            <li>
                <p>... И так далее.</p>
            </li>
        </ol>
        <p>Теперь если новая сторонняя задача (например, событие <code>click</code>) появляется, пока движок занят
        выполнением 1-й части, то она становится в очередь, и затем выполняется, когда 1-я часть завершена,
        перед следующей частью. Периодические возвраты в событийный цикл между запусками <code>count</code> дают
        движку достаточно «воздуха», чтобы сделать что-то еще, отреагировать на действия пользователей.</p>
        <p>Отметим, что оба варианта - с разбиением задачи с помощью <code>setTimeout</code> и без - сопоставимы по
        скорости выполнения. Нет большой разницы в общем времени счета.</p>
        <p>Чтобы сократить разницу еще сильнее, давайте немного улучшим наш код.</p>
        <p>Мы перенесем планирование очередного вызова в начало <code>count()</code>:</p>
<pre><code class="language-javascript">let i = 0;

let start = Date.now();

function count() {
    // Перенесем планирование очередного вызова в начало
    if (i < 1e9 - 1e6) {
        setTimeout(count); // Запланировать новый вызов
    }

    do {
        i++;
    } while (i % 1e6 !== 0);

    if (i === 1e9) {
        alert(`Done in ${Date.now() - start}ms`);
    }
}

count();</code></pre>
        <div style="margin: 0.5rem">
            <button>Запустить пример</button>
        </div>
        <script>
            document.currentScript.previousElementSibling.firstElementChild.addEventListener('pointerdown', async function() {
                let module = await import('./scripts/example1.3.js');
                module.default();
            });
        </script>
        <p>Теперь, когда мы начинаем выполнять <code>count()</code> и видим, что потребуется выполнить <code>count()</code>
        еще раз, мы планируем этот вызов немедленно, перед выполнением работы.</p>
        <p>Если вы запустите код, то легко заметите, что он требует значительно меньше времени.</p>
        <p>Почему?</p>
        <p>Все просто: как вы помните, в браузере есть минимальная задержка в 4 миллисекунды при множестве вложенных
        вызовов <code>setTimeout</code>. Даже если мы указываем задержку <code>0</code>, на самом деле она будет
        равна <code>4мс</code> (или чуть больше). Поэтому чем раньше мы запланируем выполнением - тем быстрее выполнится код.</p>
        <p>Итак, мы разбили ресурсоемкую задачу на части - теперь она не блокирует пользовательский интерфейс, причем
        почти без потерь в общем времени выполнения.</p>
    </article>

    <article>
        <h2>Пример 2: индикация прогресса</h2>
        <p>Еще одно преимущество разделения крупной задачи в браузерных скриптах - это возможность показывать индикатор
        выполнения.</p>
        <p>Обычно браузер отрисовывает содержимое страницы после того, как заканчивается выполнение текущего кода.
        Не имеет значения, насколько долго выполняется задача. Изменение в DOM отображаются только после ее завершения.</p>
        <p>С одной стороны, это хорошо, потому что наша функция может создавать много элементов, добавлять их
        по одному в документ и изменять их стили - пользователь не увидит «промежуточного», незаконченного состояния.
        Это важно, верно?</p>
        <p>В примере ниже изменения <code>i</code> не будут заметны, пока функция не завершится, поэтому мы увидим только
        последнее значение <code>i</code>:</p>
<pre><code class="language-html">&lt;div id="progress"&gt;&lt;/div&gt;

&lt;script&gt;</code>
    <code class="language-javascript">function count() {
        for (let i = 0; i < 1e6; i++) {
            progress.innerHTML = i;
        }
    }

    count();</code>
<code class="language-html">&lt;/script&gt;</code></pre>
        <div style="margin: 0.5rem">
            <button>Запустить пример</button>
        </div>
        <script>
            document.currentScript.previousElementSibling.firstElementChild.addEventListener('pointerdown', function() {
                if (this.parentElement.lastElementChild.tagName === 'IFRAME') {
                    this.parentElement.lastElementChild.remove();
                }
                this.parentElement.insertAdjacentHTML('beforeend',
                    '<iframe src="./iframes/example2.1.html"></iframe>');
            });
        </script>
        <p>... Но, возможно, мы хотим что-нибудь показать во время выполнения задачи, например, индикатор выполнения.</p>
        <p>Если мы разобьем тяжелую задачу на части, используя <code>setTimeout</code>, то изменения индикатора будут
        отрисованы в промежутках между частями.</p>
        <p>Так будет красивее:</p>
<pre><code class="language-html">&lt;div id="progress"&gt;&lt;/div&gt;

&lt;script&gt;</code>
    <code class="language-javascript">let i = 0;

    function count() {
        // Сделать часть крупной задачи (*)
        do {
            i++;
            progress.innerHTML = i;
        } while (i % 1e3 !== 0);

        if (i < 1e7) {
            setTimeout(count);
        }
    }

    count();</code>
<code class="language-html">&lt;/script&gt;</code></pre>
        <div style="margin: 0.5rem">
            <button>Запустить пример</button>
        </div>
        <script>
            document.currentScript.previousElementSibling.firstElementChild.addEventListener('pointerdown', function() {
                if (this.parentElement.lastElementChild.tagName === 'IFRAME') {
                    this.parentElement.lastElementChild.remove();
                }
                this.parentElement.insertAdjacentHTML('beforeend',
                    '<iframe src="./iframes/example2.2.html"></iframe>');
            });
        </script>
        <p>Теперь <code>&lt;div&gt;</code> показывает растущее значение <code>i</code> - это своего рода индикатор
        выполнения.</p>
    </article>

    <article>
        <h3>Пример 3: делаем что-нибудь после события</h3>
        <p>В обработчике события мы можем решить отложить некоторые действия, пока событие не «всплывет» и не будет
        обработано на всех уровнях. Мы можем добиться этого, обернув код в <code>setTimeout</code> с нулевой задержкой.</p>
        <p>В главе <a target="_blank" href="../../2.%20Введение%20в%20события/5.%20Генерация%20пользовательских%20событий/index.html">Генерация пользовательских событий</a>
        мы видели пример: наше событие <code>menu-open</code> генерируется через <code>setTimeout</code>, чтобы оно
        возникло после того, как полностью обработано событие «click».</p>
<pre><code class="language-javascript">menu.onclick = function() {
    // ...

    //Создадим наше собственное событие с данными пункта меню, по которому щелкнули мышью
    let customEvent = new CustomEvent('menu-open', {
        bubbles: true
    });

    // Сгенерировать наше событие асинхронно
    setTimeout(() => menu.dispatchEvent(customEvent));
};</code></pre>
    </article>

    <article>
        <h2>Макрозадачи и Микрозадачи</h2>
        <p>Помимо <i>макрозадач</i>, описанных в этой части, существуют <i>микрозадачи</i>, упомянутые в главе
        <a target="_blank" href="../../../Язык%20JavaScript/11.%20Промисы,%20async,%20await/7.%20Микрозадачи/index.html">Микрозадачи</a>.</p>
        <p>Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика
        <code>.then/catch/finally</code> становится микрозадачей. Микрозадачи также используются «под капотом»
        <code>await</code>, т.к. это форма обработки промиса.</p>
        <p>Также есть специальная функция <code>queueMicrotask(func)</code>, которая помещает <code>func</code> в очередь
        микрозадач.</p>
        <p><b>Сразу после каждой <i>макрозадачи</i> движок исполняет все задачи из очереди <i>микрозадач</i> перед тем,
        как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то еще.</b></p>
        <p>Например:</p>
<pre><code class="language-javascript">setTimeout(() => alert('timeout'));

Promise.resolve()
    .then(() => alert('promise'));

alert('code');</code></pre>
        <div style="margin: 0.5rem">
            <button>Запустить пример</button>
        </div>
        <script>
            document.currentScript.previousElementSibling.firstElementChild.addEventListener('pointerdown', async function() {
                let module = await import('./scripts/example3.1.js');
                module.default();
            });
        </script>
        <p>Какой здесь будет порядок?</p>
        <ol>
            <li>
                <p><code>code</code> появляется первым, т.к. это обычный синхронный вызов.</p>
            </li>
            <li>
                <p><code>promise</code> появляется вторым, потому что <code>.then</code> проходит через очередь
                микрозадач и выполняется после текущего синхронного кода.</p>
            </li>
            <li>
                <p><code>timeout</code> появляется последним, потому что это макрозадача.</p>
            </li>
        </ol>
        <p>Более подробное изображение событийного цикла выглядит так:</p>
        <img src="https://learn.javascript.ru/article/event-loop/eventLoop-full.svg" alt style="width: 40vw">
        <p><b>Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой
        макрозадаче.</b></p>
        <p>Это важно, так как гарантирует, что общее окружение остается одним и тем же между микрозадачами - не изменены
        координаты мыши, не получены новые данные по сети и т.п.</p>
        <p>Если мы хотим запустить функцию асинхронно (после текущего кода), но до отображения изменений и до новых
        событий, то можем запланировать это через <code>queueMicrotask</code>.</p>
        <p>Вот пример с индикатором выполнения, похожий на предыдущий, но в этот раз использована функция
        <code>queueMicrotask</code> вместо <code>setTimeout</code>. Обратите внимание - отрисовка страницы происходит
        только в самом конце. Как и в случае обычного синхронного кода.</p>
        <pre><code class="language-html">&lt;div id="progress"&gt;&lt;/div&gt;

&lt;script&gt;</code>
    <code class="language-javascript">let i = 0;

    function count() {
        // Сделать часть крупной задачи (*)
        do {
            i++;
            progress.innerHTML = i;
        } while (i % 1e3 !== 0);

        if (i < 1e6) {
            queueMicrotask(count);
        }
    }

    count();</code>
<code class="language-html">&lt;/script&gt;</code></pre>
        <div style="margin: 0.5rem">
            <button>Запустить пример</button>
        </div>
        <script>
            document.currentScript.previousElementSibling.firstElementChild.addEventListener('pointerdown', function() {
                if (this.parentElement.lastElementChild.tagName === 'IFRAME') {
                    this.parentElement.lastElementChild.remove();
                }
                this.parentElement.insertAdjacentHTML('beforeend',
                    '<iframe src="./iframes/example3.2.html"></iframe>');
            });
        </script>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Более подробный алгоритм событийного цикла (хоть и упрощенный в сравнении со <a target="_blank" href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model">спецификацией</a>):</p>
        <ol>
            <li>
                <p>Выбрать и исполнить старейшую задачу из очереди <i>макрозадач</i> (например, «script»).</p>
            </li>
            <li>
                <p>Исполнить все <i>микрозадачи</i>:</p>
                <ul>
                    <li>
                        <p>Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу.</p>
                    </li>
                </ul>
            </li>
            <li>
                <p>Отрисовать изменения страницы, если они есть.</p>
            </li>
            <li>
                <p>Если очередь микрозадач пуста - подождать, пока появится макрозадача.</p>
            </li>
            <li>
                <p>Перейти к шагу 1.</p>
            </li>
        </ol>
        <p>Чтобы добавить в очередь новую <i>макрозадачу</i>:</p>
        <ul>
            <li>
                <p>Используйте <code>setTimeout(f)</code> с нулевой задержкой.</p>
            </li>
        </ul>
        <p>Этот способ можно использовать для разбиения больших вычислительных задач на части, чтобы браузер мог реагировать
        на пользовательские события и показывать прогресс выполнения этих частей.</p>
        <p>Также это используется в обработчиках событий для отложенного выполнения действия после того, как событие
        полностью обработано (всплытие завершено).</p>
        <p>Для добавления в очередь новой <i>микрозадачи</i>:</p>
        <ul>
            <li>
                <p>Используйте <code>queueMicrotask(f)</code>.</p>
            </li>
            <li>
                <p>Также обработчики промисов выполняются в рамках очереди микрозадач.</p>
            </li>
        </ul>
        <p>События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются:
        микрозадачи исполняются непрерывно одна за другой.</p>
        <p>Поэтому <code>queueMicrotask</code> можно использовать для асинхронного выполнения функции в том же состоянии
        окружения.</p>

        <article class="note">
            <h2>Web Workers</h2>
            <p>Для длительных тяжелых вычислений, которые не должны блокировать событийный цикл, мы можем использовать
            <a target="_blank" href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model">Web Workers</a>.</p>
            <p>Это способ исполнить код в другом, параллельном потоке.</p>
            <p>Web Workers могут обмениваться сообщениями с основным процессом, но они имеют свои переменные и свой событийный цикл.</p>
            <p>Web Workers не имеют доступа к DOM, поэтому основное их применение - вычисления. Они позволяют задействовать
            несколько ядер процессора одновременно.</p>
        </article>
    </article>
</body>
</html>