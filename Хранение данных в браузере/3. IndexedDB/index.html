<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>IndexedDB</title>
    <link href="../../style.css" rel="stylesheet">
    <script defer src="../../highlightElements.js"></script>
</head>
<body>
    <article>
        <h2>IndexedDB</h2>
        <p>IndexedDB - это встроенная база данных, более мощная, чем <code>localStorage</code>.</p>
        <ul>
            <li>
                <p>Хранит практически любые значения по ключам, несколько типов ключей.</p>
            </li>
            <li>
                <p>Поддерживает транзакции для надежности.</p>
            </li>
            <li>
                <p>Поддерживает запросы в диапазоне ключей и индексы.</p>
            </li>
            <li>
                <p>Позволяет хранить больше данных, чем <code>localStorage</code>.</p>
            </li>
        </ul>
        <p>Для традиционных клиент-серверных приложений эта мощность обычно чрезмерна. IndexedDB предназначена для
        оффлайн приложений, можно совмещать с ServiceWorkers и другими технологиями.</p>
        <p>Интерфейс для IndexedDB, описанный в спецификации
        <a target="_blank" href="https://www.w3.org/TR/IndexedDB">https://www.w3.org/TR/IndexedDB</a>, основан на
        событиях.</p>
        <p>Мы также можем использовать <code>async/await</code> с помощью обертки, которая основана на промисах,
        например, <a target="_blank" href="https://github.com/jakearchibald/idb">https://github.com/jakearchibald/idb</a>.
        Это очень удобно, но обертка не идеальна, она не может полностью заменить события.</p>

        <article class="note">
            <h3>Где хранятся данные?</h3>
            <p>Технически данные обычно хранятся в домашнем каталоге посетителя вместе с настройками браузера,
            расширениями и т.д.</p>
            <p>У разных браузеров и пользователей на уровне ОС есть свое собственное независимое хранилище.</p>
        </article>

    </article>

    <article>
        <h2>Открыть базу данных</h2>
        <p>Для начала работы с IndexedDB нужно открыть базу данных.</p>
        <p>Синтаксис:</p>
<pre><code class="language-javascript">let openRequest = indexedDB.open(name, version);</code></pre>
        <ul>
            <li>
                <p><code>name</code> - название базы данных, строка.</p>
            </li>
            <li>
                <p><code>version</code> - версия базы данных, положительное целое число, по умолчанию <code>1</code>.</p>
            </li>
        </ul>
        <p>У нас может быть множество баз данных с различными именами, но все они существуют в контексте текущего
        источника (домен/протокол/порт). Разные сайты не могут получить доступ к базам данных друг друга.</p>
        <p>После этого вызова необходимо назначить обработчик событий для объекта <code>openRequest</code>:</p>
        <ul>
            <li>
                <p><code>success</code>: база данных готова к работе, готов «объект базы данных»
                <code>openRequest.result</code>, его следует использовать для дальнейших вызовов.</p>
            </li>
            <li>
                <p><code>error</code>: не удалось открыть базу данных.</p>
            </li>
            <li>
                <p><code>upgradeneeded</code>: база открыта, но ее схема устарела.</p>
            </li>
        </ul>
        <p><b>IndexedDB имеет встроенный механизм «версионирования схемы», который отсутствует в серверных базах данных.</b></p>
        <p>В отличие от серверных баз данных, IndexedDB работает на стороне клиента, в браузере, и у нас нет
        прямого доступа к данным. Но когда мы публикуем новую версию нашего приложения, возможно, нам понадобится обновить
        базу данных.</p>
        <p>Если локальная версия базы данных меньше, чем версия, определенная в <code>open</code>, то срабатывает
        специальное событие <code>upgradeneeded</code>, и мы сможем сравнить версии и обновить структуры данных по мере
        необходимости.</p>
        <p>Это событие также срабатывает, если базы данных еще не существует, так что в этом обработчике мы можем
        выполнить инициализацию.</p>
        <p>Допустим, мы опубликовали первую версию нашего приложения.</p>
        <p>Затем мы можем открыть базу данных с версией <code>1</code> и выполнить инициализацию в обработчике
        <code>upgradeneeded</code> вот так:</p>
<pre><code class="language-javascript">let openRequest = indexedDB.open('store', 1);

openRequest.onupgradeneeded = function() {
    // Срабатывает, если на клиенте нет базы данных
    // ...выполнить инициализацию...
};

openRequest.onerror = function() {
    console.log('Error: ', openRequest.error);
};

openRequest.onsuccess = function() {
    let db = openRequest.result;
    // Продолжаем работу с базой данных, используя объект db
};</code></pre>
        <p>Затем, позже, мы публикуем 2-ю версию.</p>
        <p>Мы можем открыть его с версией <code>2</code> и выполнить обновление следующим образом:</p>
<pre><code class="language-javascript">let openRequest = indexDB.open('store', 2);

openRequest.onupgradeneeded = function(event) {
    // Версия существующей базы данных меньше 2 (или база данных не существует)
    let db = openRequest.result;
    switch(event.oldVersion) { // Существующая (старая) версия базы данных
        case 0:
            // Версия 0 означает, что на клиенте нет базы данных
            // Выполнить инициализацию
        case 1:
            // На клиенте версия базы данных 1
            // Обновить
    }
};</code></pre>
        <p>Таким образом, в <code>openRequest.onupgradeneeded</code> мы обновляем базу данных. Скоро подробно увидим,
        как это делается. А после того, как этот обработчик завершится без ошибок, сработает
        <code>openRequest.onsuccess</code>.</p>
        <p>После <code>openRequest.onsuccess</code> у нас есть объект базы данных в <code>openRequest.result</code>,
        который мы будем использовать для дальнейших операций.</p>
        <p>Удалить базу данных:</p>
<pre><code class="language-javascript">let deleteRequest = indexedDB.deleteDatabase(name);
// deleteRequest.onsuccess/onerror отслеживает результат</code></pre>

        <article class="warning">
            <h3>А что, если открыть предыдущую версию?</h3>
            <p>Что если мы попробуем открыть базы с более низкой версией, чем текущая? Например, на клиенте
            база версии 3, а мы вызываем <code>open(..., 2)</code>.</p>
            <p>Возникнет ошибка, сработает <code>openRequest.onerror</code>.</p>
            <p>Такое может произойти, если посетитель загрузил устаревший код, например, из кеша прокси. Нам следует
            проверить <code>db.version</code> и предложить ему перезагрузить страницу. А также проверить наши кеширующие
            заголовки, убедиться, что посетитель никогда не получит устаревший код.</p>
        </article>

    </article>

    <article id="concurrentUpdateProblem">
        <h2>Проблема параллельного обновления</h2>
        <p>Раз уж мы говорим про версионирование, рассмотрим связанную с этим небольшую проблему.</p>
        <p>Допустим:</p>
        <ol>
            <li>
                <p>Посетитель открыл наш сайт во вкладке браузера, с базой версии <code>1</code>.</p>
            </li>
            <li>
                <p>Затем мы выпустили обновление, так что наш код обновился.</p>
            </li>
            <li>
                <p>И затем тот же посетитель открыл наш сайт в другой вкладке.</p>
            </li>
        </ol>
        <p>Так что есть две вкладки, на которых открыт наш сайт, но в одной открыто соединение с базой версии 1,
        а другая пытается обновить версию базы в обработчике <code>onupgradeneeded</code>.</p>
        <p>Проблема заключается в том, что база данных всего одна на две вкладки, так как это один и тот же сайт,
        один источник. И она не может быть одновременно версии 1 и 2. Чтобы обновить на версию 2, все соединения
        к версии 1 должны быть закрыты.</p>
        <p>Чтобы это можно было организовать, при попытке обновления на объекте базы возникает событие
        <code>versionchange</code>. Нам нужно слушать его и закрыть соединение к базе (а также, возможно, предложить
        пользователю перезагрузить страницу, чтобы получить обновленный код).</p>
        <p>Если мы его не закроем, то второе, новое соединение будет заблокировано с событием <code>blocked</code>
        вместо <code>success</code>.</p>
        <p>Код который это делает:</p>
<pre><code class="language-javascript">let openRequest = indexedDB.open('store', 2);

openRequest.onupgradeneeded = ...;
openRequest.onerror = ...;

openRequest.onsuccess = function() {
    let db = openRequest.result;

    db.onversionchange = function() {
        db.close();
        alert('База данных устарела, пожалуйста, перезагрузите страницу.');
    };

    // ... База данных готова, используйте ее...
};

openRequest.onblocked = function() {
    // Это событие не должно срабатывать, если мы правильно обрабатываем onversionchange

    // Это означает, что есть еще одно открытое соединение с той же базой данных
    // и оно не было закрыто после того, как для него сработал db.onversionchange
};</code></pre>
        <p>Другими словами, здесь мы делаем две вещи:</p>
        <ol>
            <li>
                <p>Обработчик <code>db.onversionchange</code> сообщает нам о попытке параллельного обновления, если
                текущая версия базы данных устарела.</p>
            </li>
            <li>
                <p>Обработчик <code>openRequest.onblocked</code> сообщает нам об обратной ситуации: в другом месте
                есть соединение с устаревшей версией, и оно не закрывается, поэтому новое соединение установить
                невозможно.</p>
            </li>
        </ol>
        <p>Мы можем более изящно обращаться с вещами в <code>db.onversionchange</code>, например, предлагать посетителю
        сохранить данные до закрытия соединения и так далее.</p>
        <p>Или альтернативным подходом было бы не закрывать базу данных в <code>db.onversionchange</code>, а вместо
        этого использовать обработчик <code>onblocked</code> (на новой вкладке), чтобы предупредить посетителя,
        что более новая версия не можем быть загружена, пока он не закроет другие вкладки.</p>
        <p>Такой конфликт при обновлении происходит редко, но мы должны как-то его обрабатывать, хотя бы поставить
        обработчик <code>onblocked</code>, чтобы наш скрипт не «умирал» молча, удивляя посетителя.</p>
    </article>

    <article>
        <h2>Хранилище объектов</h2>
        <p>Чтобы сохранить что-то в IndexedDB, нам нужно <i>хранилище объектов</i>.</p>
        <p>Хранилище объектов - это основная концепция IndexedDB. В других базах данных это «таблицы» или «коллекции».
        Здесь хранятся данные. Здесь хранятся данные. В базе данных может быть множество хранилищ: одно для пользователей,
        другое для товаров и так далее.</p>
        <p>Несмотря на то, что название - «хранилище объектов», примитивы тоже могут там храниться.</p>
        <p><b>Мы можем хранить почти любое значение, в том числе сложные объекты.</b></p>
        <p>IndexedDB использует <a target="_blank" href="https://www.w3.org/TR/html53/infrastructure.html#section-structuredserializeforstorage">стандартный алгоритм сериализации</a>
        для клонирования и хранения объекта. Это как <code>JSON.stringify</code>, но более мощный, способный хранить
        гораздо больше типов данных.</p>
        <p>Пример объекта, который нельзя сохранить: объект с циклическими ссылками. Такие объекты не сериализуемы.
        <code>JSON.stringify</code> также выдаст ошибку при сериализации.</p>
        <p><b>Каждому значению в хранилище должен соответствовать уникальный ключ.</b></p>
        <p>Ключ должен быть одним из следующих типов: number, date, string, binary или array. Это уникальный
        идентификатор: по ключу мы можем искать/удалять/обновлять значения.</p>
        <img src="images/indexeddb-structure.svg" alt style="width: 50vw">
        <p>Как мы видим, можно указать ключ при добавлении значения в хранилище, аналогично <code>localStorage</code>.
        Но когда мы храним объекты, IndexedDB позволяет установить свойство объекта в качестве ключа, что гораздо
        удобнее. Или мы можем автоматически сгенерировать ключи.</p>
        <p>Но для начала нужно создать хранилище.</p>
        <p>Синтаксис для создания хранилища объектов:</p>
<pre><code class="language-javascript">db.createObjectStore(name, [keyOptions]);</code></pre>
        <p>Обратите внимание, что операция является синхронной, использование <code>await</code> не требуется.</p>
        <ul>
            <li>
                <p><code>name</code> - это название хранилище, например, <code>"books"</code> для книг.</p>
            </li>
            <li>
                <p><code>keyOptions</code> - это необязательный объект с одним или двумя свойствами:</p>
                <ul>
                    <li>
                        <p><code>keyPath</code> - путь к свойству объекта, которое IndexedDB будет использовать
                        в качестве ключа, например, <code>id</code>.</p>
                    </li>
                    <li>
                        <p><code>autoIncrement</code> - если <code>true</code>, то ключ будет формироваться автоматически
                        для новых объектов, как постоянно увеличивающееся число.</p>
                    </li>
                </ul>
            </li>
        </ul>
        <p>Если при создании хранилища не указать <code>keyOptions</code>, то нам потребуется явно указать ключ позже,
        при сохранении объекта.</p>
        <p>Например, это хранилище объектов использует свойство <code>id</code> как ключ:</p>
<pre><code class="language-javascript">db.createObjectStore('books', {keyPath: 'id'});</code></pre>
        <p><b>Хранилище объектов можно создавать/изменять только при обновлении версии базы данных в обработчике
        <code>upgradeneeded</code>.</b></p>
        <p>Это техническое ограничение. Вне обработчика мы сможем добавлять/удалять/обновлять данные, но хранилища
        объектов могут быть созданы/удалены/изменены только во время обновления версии базы данных.</p>
        <p>Для обновления версии базы есть два основных подхода:</p>
        <ol>
            <li>
                <p>Мы можем реализовать функции обновления по версиям: с 1 на 2, с 2 на 3 и т.д. Потом в
                <code>upgradeneeded</code> сравнить версии (например, была 2, сейчас 4) и запустить операции обновления
                для каждой промежуточной версии (2 на 3, затем 3 на 4).</p>
            </li>
            <li>
                <p>Или мы можем взять список существующих хранилищ объектов, используя <code>db.objectStoreNames</code>.
                Этот объект является <a target="_blank" href="https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#domstringlist">DOMStringList</a>,
                в нем есть метод <code>contains(name)</code>, используя который можно проверить существование хранилища.
                Посмотреть, какие хранилища есть и создать те, которых нет.</p>
            </li>
        </ol>
        <p>Для простых баз данных второй подход может быть проще и предпочтительнее.</p>
        <p>Вот демонстрация второго способа:</p>
<pre><code class="language-javascript">let openRequest = indexedDB.open('store', 2);

// Создаем хранилище объектов для books, если еще не существует
openRequest.onupgradeneeded = function() {
    let db = openRequest.result;
    if (!db.objectStoreNames.contains('books')) { // Если хранилище 'books' не существует
        db.createObjectStore('books', {keyPath: 'id'}); // Создаем хранилище
    }
};</code></pre>
        <p>Чтобы удалить хранилище объектов:</p>
<pre><code class="language-javascript">db.deleteObjectStore(name);</code></pre>
    </article>

    <article>
        <h2>Транзакции</h2>
        <p>Термин «транзакции» является общеизвестным, транзакции используются во многих видах баз данных.</p>
        <p>Транзакция - это группа операций, которые должны быть или все выполнены, или все не выполнены (все или ничего).</p>
        <p>Например, когда пользователь что-то покупает, нам нужно:</p>
        <ol>
            <li>
                <p>Вычесть деньги с его счета.</p>
            </li>
            <li>
                <p>Отправить ему покупку.</p>
            </li>
        </ol>
        <p>Будет очень плохо, если мы успеем завершить первую операцию, а затем что-то пойдет не так, например,
        отключат электричество, и мы не сможем завершить вторую операцию. Обе операции должны быть успешно завершены
        (покупка сделана, отлично!) или необходимо отменить обе операции (в этом случае пользователь сохранит свои
        деньги и может попытаться купить еще раз).</p>
        <p>Транзакции гарантируют это.</p>
        <p><b>Все операции с данными в IndexedDB могут быть сделаны только внутри транзакций.</b></p>
        <p>Для начала транзакции:</p>
<pre><code class="language-javascript">db.transaction(store, [type]);</code></pre>
        <ul>
            <li>
                <p><code>store</code> - это название хранилища, к которому транзакция получит доступ, например,
                <code>'books'</code>. Может быть массивом названий, если нам нужно предоставить доступ к нескольким
                хранилищам.</p>
            </li>
            <li>
                <p><code>type</code> - тип транзакции, один из:</p>
                <ul>
                    <li>
                        <p><code>readonly</code> - только чтение, по умолчанию.</p>
                    </li>
                    <li>
                        <p><code>readwrite</code> - только чтение и запись данных, создание/удаление самих
                        хранилищ объектов недоступно.</p>
                    </li>
                </ul>
            </li>
        </ul>
        <p>Есть еще один тип транзакций: <code>versionchange</code>. Такие транзакции могут делать любые операции,
        но мы не можем создать их вручную. IndexedDB автоматически создает транзакцию типа <code>versionchange</code>,
        когда открывает базу данных для обработчика <code>upgradeneeded</code>. Вот почему это единственное место,
        где мы можем обновлять структуру базы данных, создавать/удалять хранилища объектов.</p>

        <article class="note">
            <h3>Почему существует несколько типов транзакций?</h3>
            <p>Производительность является причиной, почему транзакции необходимо помечать как <code>readonly</code>
            или <code>readwrite</code>.</p>
            <p>Несколько <code>readonly</code> транзакций могут одновременно работать с одним и тем же хранилищем
            объектов, а <code>readwrite</code> транзакций - не могут. Транзакции типа <code>readwrite</code>
            «блокируют» хранилище для записи. Следующая такая транзакция должна дождаться выполнения предыдущей,
            перед тем как получить доступ к тому же самому хранилищу.</p>
        </article>

        <p>После того как транзакция будет создана, мы можем добавить элемент в хранилище, вот так:</p>
<pre><code class="language-javascript">let transaction = db.transaction('books', 'readwrite'); // (1)

// Получить хранилище объектов для работы с ним
let books = transaction.objectStore('books'); // (2)

let book = {
    id: 'js',
    price: 10,
    created: now Date()
};

let request = books.add(book); // (3)

request.onsuccess = function() { // (4)
    console.log('Книга добавлена в хранилище', request.result);
};

request.onerror = function() {
    console.log('Ошибка', request.error);
};</code></pre>
        <p>Мы сделали четыре шага:</p>
        <ol>
            <li>
                <p>Создать транзакцию и указать все хранилища, к которым необходим доступ, строка <code>(1)</code>.</p>
            </li>
            <li>
                <p>Получить хранилище объектов, используя <code>transaction.objectStore(name)</code>, строка <code>(2)</code>.</p>
            </li>
            <li>
                <p>Выполнить запрос на добавление элемента в хранилище объектов <code>books.add(book)</code>,
                строка <code>(3)</code>.</p>
            </li>
            <li>
                <p>... Обработать результат запроса <code>(4)</code>, затем мы можем выполнить другие запросы и так далее.</p>
            </li>
        </ol>
        <p>Хранилища объектов поддерживают два метода для добавления значений:</p>
        <ul>
            <li>
                <p><code>put(value, [key])</code> - добавляет значение <code>value</code> в хранилище. Ключ <code>key</code>
                необходимо указать, если при создании хранилища объектов не было указано свойство <code>keyPath</code>
                или <code>autoincrement</code>. Если уже есть значение с таким ключом, то оно будет заменено.</p>
            </li>
            <li>
                <p><code>add(value, [key])</code> - то же, что и <code>put</code>, но если уже существует значение с
                таким ключом, то запрос не выполнится, будет сгенерирована ошибка с названием <code>'ConstraintError'</code>.</p>
            </li>
        </ul>
        <p>Аналогично открытию базы, мы отправляем запрос: <code>books.add(book)</code> и после ожидаем события
        <code>success/error</code>.</p>
        <ul>
            <li>
                <p><code>request.result</code> для <code>add</code> является ключом нового объекта.</p>
            </li>
            <li>
                <p>Ошибка находится в <code>request.error</code> (если есть).</p>
            </li>
        </ul>
    </article>

    <article>
        <h2>Автоматическая фиксация транзакций</h2>
        <p>В примере выше мы запустили транзакцию и выполнили запрос <code>add</code>. Но, как говорилось ранее,
        транзакция может включать в себя несколько запросов, которые все вместе должны либо успешно завершиться,
        либо нет. Как нам закончить транзакцию, обозначить, что больше запросов в ней не будет?</p>
        <p>Короткий ответ: этого не требуется.</p>
        <p>В следующей 3.0 версии спецификации, вероятно, будет возможность вручную завершить транзакцию, но сейчас,
        в версии 2.0, такой возможности нет.</p>
        <p><b>Когда все запросы завершены и
        <a target="_blank" href="../../Язык%20JavaScript/11.%20Промисы,%20async,%20await/7.%20Микрозадачи/index.html">очередь микрозадач</a>
        пуста, тогда транзакция завершится автоматически.</b></p>
        <p>Как правило, это означает, что транзакция автоматически завершится, когда выполнились все ее запросы
        и завершится текущий код.</p>
        <p>Таким образом, в приведенном выше примере не требуется никакого специального вызова, чтобы завершить
        транзакцию.</p>
        <p>Такое автозавершение транзакций имеет важный побочный эффект. Мы не можем вставить асинхронную операцию,
        такую как <code>fetch</code> или <code>setTimeout</code> в середину транзакции. IndexedDB никак не заставит
        транзакцию «висеть» и ждать их выполнения.</p>
        <p>В приведенном ниже коде в запросе <code>request2</code> в строке с <code>(*)</code> будет ошибка, потому что
        транзакция уже завершена, больше нельзя выполнить в ней зарос:</p>
<pre><code class="language-javascript">let request1 = books.add(book);

request1.onsuccess = function() {
    fetch('/').then(response => {
        let request2 = books.add(anotherBook); // (*)
        request2.onerror = function() {
            console.log(request2.error.name); // TransactionInactiveError
        };
    });
};</code></pre>
        <p>Все потому, что <code>fetch</code> является асинхронной операцией, макрозадачей. Транзакции завершаются
        раньше, чем браузер приступает к выполнению макрозадач.</p>
        <p>Авторы спецификации IndexedDB из соображений производительности считают, что транзакции должны завершаться
        быстро.</p>
        <p>В частности, <code>readwrite</code> транзакции «блокируют» хранилища от записи. Таким образом, если одна
        часть приложения инициирует <code>readwrite</code> транзакцию в хранилище объектов <code>books</code>, то
        другая часть приложения, которая хочет сделать то же самое, должна ждать: новая транзакция «зависает» до
        завершения первой. Это может привести к странным задержкам, если транзакции слишком долго выполняются.</p>
        <p>Что же делать?</p>
        <p>В приведенном выше примере мы могли бы запустить новую транзакцию <code>db.transaction</code> перед
        новым запросом <code>(*)</code>.</p>
        <p>Но еще лучше выполнять операции вместе, в рамках одной транзакции: отделить транзакции IndexedDB от других
        асинхронных операций.</p>
        <p>Сначала сделаем <code>fetch</code>, подготовим данные, если нужно, затем создадим транзакцию и выполним
        все запросы к базе данных.</p>
        <p>Чтобы поймать момент успешного выполнения, мы можем повесить обработчик на событие
        <code>transaction.oncomplete</code>:</p>
<pre><code class="language-javascript">let transaction = db.transaction('books', 'readwrite');

// ...Выполнить операции...

transaction.oncomplete = function() {
    console.log('Транзакция выполнена');
};</code></pre>
        <p>Только <code>complete</code> гарантирует, что транзакция сохранена целиком. По отдельности запросы могут
        выполниться, но при финальной записи что-то может пойти не так (ошибка ввода-вывода, проблема с диском, например).</p>
        <p>Чтобы вручную отменить транзакцию, выполните:</p>
<pre><code class="language-javascript">transaction.abort();</code></pre>
        <p>Это отменит все изменения, сделанные запросами в транзакции, и сгенерирует событие <code>transaction.onabort</code>.</p>
    </article>

    <article>
        <h2>Делегирование событий</h2>
        <p>Нужны ли обработчики <code>onerror/onsuccess</code> для каждого запроса? Не всегда. Мы можем использовать
        делегирование событий.</p>
        <p><b>События IndexedDB всплывают: <code>запрос</code> → <code>транзакция</code> → <code>база данных</code>.</b></p>
        <p>Все события являются DOM-событиями с фазами перехвата и всплытия, но обычно используется только всплытие.</p>
        <p>Поэтому мы можем перехватить все ошибки, используя обработчик <code>db.onerror</code>, для оповещения
        пользователя или других целей:</p>
<pre><code class="language-javascript">db.onerror = function(event) {
    let request = event.target; // Запрос, в котором произошла ошибка

    console.log('Ошибка', request.error);
};</code></pre>
        <p>... А если мы полностью обработали ошибку? В этом случае мы не хотим сообщать об этом.</p>
        <p>Мы можем остановить всплытие и, следовательно, <code>db.onerror</code>, используя
        <code>event.stopPropagation()</code> в <code>request.onerror</code>.</p>
<pre><code class="language-javascript">request.onerror = function(event) {
    if (request.error.name === 'ConstraintError') {
        console.log('Книга с таким id уже существует'); // Обрабатываем ошибку
        event.preventDefault(); // Предотвращаем отмену транзакции
        event.stopPropagation(); // Предотвращаем всплытие ошибки
    } else {
        // Ничего не делаем
        // Транзакция будет отменена
        // Мы можем обработать ошибку в transaction.onabort
    }
};</code></pre>
    </article>

    <article>
        <h2>Виды поиска в хранилище объектов</h2>
        <p>Есть два основных вида поиска в хранилище объектов:</p>
        <ol>
            <li>
                <p>По значению ключа или диапазону ключей. В нашем хранилище «books» это будет значение или диапазон
                значений <code>book.id</code>.</p>
            </li>
            <li>
                <p>С помощью другого поля объекта, например, <code>book.price</code>. Для этого требуется дополнительная
                структура данных - <code>index</code>.</p>
            </li>
        </ol>
    </article>

    <article>
        <h2>Поиск по ключу или диапазону ключей</h2>
        <p>Методы поиска поддерживают либо точные ключи, либо так называемые «запросы с диапазоном» -
        <a target="_blank" href="https://www.w3.org/TR/IndexedDB/#keyrange">IDBKeyRange</a> объекты, которые
        задают «диапазон ключей».</p>
        <p>Диапазоны создаются с помощью следующих вызовов:</p>
        <ul>
            <li>
                <p><code>IDBKeyRange.lowerBound(lower, [open])</code> означает: <code>≥lower</code>
                (или <code>&gt;lower</code>, если <code>open</code> это <code>true</code>).</p>
            </li>
            <li>
                <p><code>IDBKeyRange.upperBound(upper, [open])</code> означает: <code>≤upper</code>
                (или <code>&lt;upper</code>, если <code>open</code> это <code>true</code>).</p>
            </li>
            <li>
                <p><code>IDBKeyRange.bound(lower, upper, [lowerOpen], [upperOpen])</code> означает: между <code>lower</code>
                и <code>upper</code>включительно. Если соответствующий <code>open</code> равен <code>true</code>, то граница
                исключается.</p>
            </li>
            <li>
                <p><code>IDBKeyRange.only(key)</code> - диапазон, которой состоит только из одного ключа <code>key</code>,
                редко используется.</p>
            </li>
        </ul>
        <p>Очень скоро мы увидим практические примеры их использования.</p>
        <p>Для выполнения фактического поиска существуют следующие методы. Они принимают аргумент <code>query</code>,
        который может быть либо точным ключом, либо диапазоном ключей.</p>
        <ul>
            <li>
                <p><code>store.get(query)</code> - поиск первого значения по ключу или диапазону.</p>
            </li>
            <li>
                <p><code>store.getAll([query], [count])</code> - поиск всех значений, можно ограничить, передав
                <code>count</code>.</p>
            </li>
            <li>
                <p><code>store.getKey(query)</code> - поиск первого ключа, который удовлетворяет запросу, обычно
                передается диапазон.</p>
            </li>
            <li>
                <p><code>store.getAllKeys([query], [count])</code> - поиск всех ключей, которые удовлетворяют
                запросу, обычно передается диапазон, возможно ограничить поиск, передав <code>count</code>.</p>
            </li>
            <li>
                <p><code>store.count([query])</code> - получить общее количество ключей, которые удовлетворяют запросу,
                обычно передается диапазон.</p>
            </li>
        </ul>
        <p>Например, в хранилище у нас есть множество книг. Помните, поле <code>id</code> является ключом, поэтому
        все эти методы могут искать по ключу <code>id</code>.</p>
        <p>Примеры запросов:</p>
<pre><code class="language-javascript">// Получить одну книгу
books.get('js');

// Получить книгу с 'css' <= id <= 'html'
books.getAll(IDBKeyRange.bound('css', 'html'));

// Получить книги с id < 'html'
books.getAll(IDBKeyRange.upperBound('html', true));

// Получить все книги
books.getAll();

// Получить все ключи, где id > 'js'
books.getAllKeys(IDBKeyRange.lowerBound('js', true));</code></pre>

        <article class="note">
            <h3>Хранилище объектов всегда отсортировано</h3>
            <p>Хранилище объектов внутренне сортирует значения по ключам.</p>
            <p>Поэтому запросы, которые возвращают много значений, всегда возвращают их в порядке сортировки по ключу.</p>
        </article>

    </article>

    <article>
        <h2>Поиск по индексированному полю</h2>
        <p>Для поиска по другим полям объекта нам нужно создать дополнительную структуру данных, называемую «индекс»
        (index).</p>
        <p>Индекс является «расширением» к хранилищу, которое отслеживает данное поле объекта. Для каждого значения
        этого поля хранится список ключей для объектов, которые имеют это значение. Ниже будет более подробная картина.</p>
        <p>Синтаксис:</p>
<pre><code class="language-javascript">objectStore.createIndex(name, keyPath, [options]);</code></pre>
        <ul>
            <li>
                <p><code>name</code> - название индекса.</p>
            </li>
            <li>
                <p><code>keyPath</code> - путь к полю объекта, которое индекс должен отслеживать (мы собираемся сделать
                поиск по этому полю).</p>
            </li>
            <li>
                <p><code>option</code> - необязательный объект со свойствами:</p>
                <ul>
                    <li>
                        <p><code>unique</code> - если <code>true</code>, тогда в хранилище может быть только один
                        объект с заданным значением в <code>keyPath</code>. Если мы попытаемся добавить дубликат,
                        то индекс сгенерирует ошибку <code>ConstraintError</code>.</p>
                    </li>
                    <li>
                        <p><code>multiEntry</code> - используется только, если <code>keyPath</code> является массивом.
                        В этом случае, по умолчанию, индекс обрабатывает весь массив как ключ. Но если мы укажем
                        <code>true</code> в <code>multiEntry</code>, тогда индекс будет хранить список объектов
                        хранилища для каждого значения в этом массиве. Таким образом, элементы массива становятся
                        ключами индекса.</p>
                        <h3>Пример без <code>multiEntry</code></h3>
<pre><code class="language-javascript">const store = db.createObjectStore('books', {keyPath: 'id'});

// Индекс по тегам, но без multiEntry
store.createIndex('tagsIndex', 'tags', {multiEntry: false});

store.add({id: 1, title: 'CSS Mastery', tags: ['css', 'frontend']});
store.add({id: 2, title: 'HTML Guide', tags: ['html', 'frontend']});</code></pre>
                        <p>Теперь в индексе <code>tagsIndex</code> будет <b>2 записи</b>:</p>
                        <ul>
                            <li>
                                <p>ключ = <code>['css', 'frontend']</code> → id=1</p>
                            </li>
                            <li>
                                <p>ключ = <code>['html', 'frontend']</code> → id=2</p>
                            </li>
                        </ul>
                        <p>Поиск по <code>'css'</code> <b>не найдет ничего</b>, потому что ключами индекса являются
                        <b>массивы целиком</b>.</p>

                        <h3>Пример с <code>multiEntry: true</code></h3>
<pre><code class="language-javascript">store.createIndex('tagsIndex', 'tags', {multiEntry: true});</code></pre>
                        <p>Теперь в индекс попадут <b>каждый элемент массива отдельно</b>:</p>
                        <ul>
                            <li>
                                <p>ключ = <code>'css'</code> → id=1</p>
                            </li>
                            <li>
                                <p>ключ = <code>'frontend'</code> → id=1</p>
                            </li>
                            <li>
                                <p>ключ = <code>'html'</code> → id=2</p>
                            </li>
                            <li>
                                <p>ключ = <code>'frontend'</code> → id=2</p>
                            </li>
                        </ul>
                        <p>То есть поиск по <code>'css'</code> найдет книгу с id=1.</p>
                    </li>
                </ul>
            </li>
        </ul>
        <p>В нашем примере мы храним книги с ключом <code>id</code>.</p>
        <p>Допустим, мы хотим сделать поиск по полю <code>price</code>.</p>
        <p>Сначала нам нужно создать индекс. Индексы должны создаваться в <code>upgradeneeded</code>, как и хранилище
        объектов:</p>
<pre><code class="language-javascript">openRequest.onupgradeneeded = function() {
    // Мы должны создать индекс здесь, в versionchange транзакции
    let books = db.createObjectStore('books', {keyPath: 'id'});
    let index = books.createIndex('priceIndex', 'price');
};</code></pre>
        <ul>
            <li>
                <p>Индекс будет отслеживать поле <code>price</code>.</p>
            </li>
            <li>
                <p>Поле <code>price</code> не уникальное, у нас может быть несколько книг с одинаковой ценой,
                поэтому мы не устанавливаем опцию <code>unique</code>.</p>
            </li>
            <li>
                <p>Поле <code>price</code> не является массивом, поэтому опция <code>multiEntry</code> не применима.</p>
            </li>
        </ul>
        <p>Представим, что в нашем <code>books</code> есть 4 книги. Вот картинка, которая показывает что такое «индекс».</p>
        <img src="images/indexeddb-index.svg" alt style="width: 40vw">
        <p>Как уже говорилось, индекс для каждого значения <code>price</code> хранит список ключей, имеющих эту цену.</p>
        <p>Индексы автоматически обновляются, нам не нужно об этом заботиться.</p>
        <p>Сейчас, когда мы хотим найти объект по цене, мы просто применяем те же методы поиска к индексу:</p>
<pre><code class="language-javascript">let transaction = db.transaction('books', 'readonly');
let books = transaction.objectStore('books');
let priceIndex = books.index('priceIndex');

let request = priceIndex.getAll(10);

request.onsuccess = function() {
    if (request.result !== undefined) {
        console.log('Книги: ', request.result); // Массив книг с ценой 10
    } else {
        console.log('Нет книг с такой ценой');
    }
};</code></pre>
        <p>Мы также можем использовать <code>IDBKeyRange</code>, чтобы создать диапазон и найти дешевые/дорогие книги:</p>
<pre><code class="language-javascript">// Найдем книги, где цена < 5
let request = priceIndex.getAll(IDBKeyRange.upperBound(5, true));</code></pre>
        <p>Индексы внутренне отсортированы по полю отслеживаемого объекта, в нашем случае по <code>price</code>.
        Поэтому результат поиска будет уже отсортированный по полю <code>price</code>.</p>
    </article>

    <article>
        <h2>Удаление из хранилища</h2>
        <p>Метод <code>delete</code> удаляет значения по запросу, формат вызова такой же, как в <code>getAll</code>:</p>
        <ul>
            <li>
                <p><code>delete(query)</code> - производит удаление соответствующих запросу значений.</p>
            </li>
        </ul>
        <p>Например:</p>
<pre><code class="language-javascript">// Удалить книгу с id='js'
books.delete('js');</code></pre>
        <p>Если нам нужно удалить книги, основываясь на цене или любом другом поле, сначала нам надо найти ключ в индексе,
        а затем выполнить <code>delete</code>:</p>
<pre><code class="language-javascript">// Найдем ключ, где цена = 5
let request = priceIndex.getKey(5);

request.onsuccess = function() {
    let id = request.result;
    let deleteRequest = books.delete(id);
};</code></pre>
        <p>Чтобы удалить все:</p>
<pre><code class="language-javascript">books.clear(); // Очищаем хранилище</code></pre>
    </article>

    <article>
        <h2>Курсоры</h2>
        <p>Такие методы как <code>getAll/getAllKeys</code> возвращают массив ключей/значений.</p>
        <p>Но хранилище объектов может быть огромным, больше, чем доступно памяти. Тогда метод <code>getAll</code>
        вернет ошибку при попытке получить все записи в массиве.</p>
        <p>Что делать?</p>
        <p>Курсоры предоставляют возможности для работы в таких ситуациях.</p>
        <p><b>Объект <i>cursor</i> идет по хранилищу объектов с заданным запросом (query) и возвращает пары
        ключ/значение по очереди, а не все сразу. Это позволяет экономить память.</b></p>
        <p>Так как хранилище объектов внутренне отсортировано по ключу, курсор проходит по хранилищу в порядке
        хранения ключей (по возрастанию по умолчанию).</p>
        <p>Синтаксис:</p>
<pre><code class="language-javascript">// Как getAll, но с использованием курсора:
let request = store.openCursor([query], [direction]);

// Чтобы получить ключи, не значения (как getAllKeys): store.openKeyCursor</code></pre>
        <ul>
            <li>
                <p><code>query</code> - ключ или диапазон ключей, как для <code>getAll</code>.</p>
            </li>
            <li>
                <p><code>direction</code> - необязательный аргумент, доступные значения:</p>
                <ul>
                    <li>
                        <p><code>'next'</code> - по умолчанию, курсор будет проходить от самого маленького ключа к большему.</p>
                    </li>
                    <li>
                        <p><code>'prev'</code> - обратный порядок: от самого большого ключа к меньшему.</p>
                    </li>
                    <li>
                        <p><code>'nextunique'</code>, <code>'prevunique'</code> - то же самое, но курсор пропускает
                        записи с тем же ключом, что уже был (только для курсоров по индексам, например, для нескольких
                        книг с <code>price=5</code>, будет возвращена только первая).</p>
                    </li>
                </ul>
            </li>
        </ul>
        <p><b>Основным отличием курсора является то, что <code>request.onsuccess</code> генерируется многократно: один
        раз для каждого результата.</b></p>
        <p>Вот пример того, как использовать курсор:</p>
<pre><code class="language-javascript">let transaction = db.transaction('books', 'readonly');
let books = transaction.objectStore('books');

let request = books.openCursor();

// Вызывается для каждой найденной курсором книги
request.onsuccess = function() {
    let cursor = request.result;
    if (cursor) {
        let key = cursor.key; // Ключ книги (поле id)
        let value = cursor.value; // Объект книги
        console.log(key, value);
        cursor.continue();
    } else {
        console.log('Книг больше нет');
    }
};</code></pre>
        <p>Основные методы курсора:</p>
        <ul>
            <li>
                <p><code>advance(count)</code> - продвинуть курсор на <code>count</code> позиций, пропустив значения.</p>
            </li>
            <li>
                <p><code>continue([key])</code> - продвинуть курсор к следующему значению в диапазоне соответствия
                (или для перехода к конкретному значению <code>key</code>, если указан).</p>
            </li>
        </ul>
        <p>Независимо от того, есть ли еще значения, соответствующие курсору или нет - вызывается <code>onsuccess</code>,
        затем в <code>result</code> мы можем получить курсор, указывающий на следующую запись или равны <code>undefined</code>.</p>
        <p>В приведенном выше примере курсор был создан для хранилища объектов.</p>
        <p>Но мы также можем создать курсор для индексов. Как мы помним, индексы позволяют искать по полю объекта.
        Курсоры для индексов работают так же, как для хранилищ объектов - они позволяют экономить память, возвращая
        одно значение в единицу времени.</p>
        <p>Для курсоров по индексам <code>cursor.key</code> является ключом индекса (например <code>price</code>), нам
        следует использовать свойство <code>cursor.primaryKey</code> как ключ объекта:</p>
<pre><code class="language-javascript">let request = priceIndex.openCursor(IDBKeyRange.upperBound(5));

// Вызывается для каждой записи
request.onsuccess = function() {
    let cursor = request.result;
    if (cursor) {
        let key = cursor.primaryKey; // Ключ в хранилище объектов (поле id)
        let value = cursor.value; // Объект книги
        let keyIndex = cursor.key; // Ключ индекса (поле price)
        console.log(key, value);
        cursor.continue();
    } else {
        console.log('Книг больше нет');
    }
};</code></pre>
    </article>

    <article>
        <h2>Итого</h2>
        <p>IndexedDB можно рассматривать как «localStorage на стероидах». Это простая база данных типа ключ-значение,
        достаточно мощная для оффлайн приложений, но простая в использовании.</p>
        <p>Основные этапы использования IndexedDB:</p>
        <ol>
            <li>
                <p>Открыть (или создать) базу данных</p>
<pre><code class="language-javascript">let openRequest = indexedDB.open('exampleDataBase', 1);</code></pre>
            </li>
            <li>
                <p>Создать или обновить хранилища (и индексы)</p>
<pre><code class="language-javascript">openRequest.onupgradeneeded = function(event) {
    let db = openRequest.result;
    let transaction = openRequest.transaction; // Транзакция апгрейда, типа versionchange
    let oldVersion = event.oldVersion;

    let store;
    if (oldVersion < 1) {
        store = db.createObjectStore('users', {keyPath: 'id'});
    }
    if (oldVersion < 2) {
        store = transaction.objectStore('users');
        store.createIndex('nameIndex', 'name', {unique: false, multiEntry: false});
    }
};</code></pre>
            </li>
            <li>
                <p>Обработать успешное открытие</p>
<pre><code class="language-javascript">openRequest.onsuccess = function() {
    let db = openRequest.result;

    db.onversionchange = function() {
        db.close();
        alert('База данных устарела, пожалуйста, перезагрузите страницу.');
    }
};

openRequest.onblocked = function() {
    // Это означает, что есть еще одно открытое соединение с той же базой данных
    // и оно не было закрыто после того, как для него сработал db.onversionchange
};</code></pre>
            </li>
            <li>
                <p>Создать транзакцию</p>
<pre><code class="language-javascript">let transaction = db.transaction('users', 'readwrite');
let store = transaction.objectStore('users');</code></pre>
            </li>
            <li>
                <p>Для поиска по ключу вызываем методы непосредственно у хранилища объектов.</p>
                <ul>
                    <li>
                        <p>Для поиска по любому полю объекта создайте индекс.</p>
                    </li>
                </ul>
            </li>
            <li>
                <p>Если данные не помещаются в памяти, то используйте курсор.</p>
            </li>
            <li>
                <p>Обработать результат запроса</p>
<pre><code class="language-javascript">let getRequest = store.get(1);
getRequest.onsuccess = () => console.log(getRequest.result);</code></pre>
            </li>
            <li>
                <p>Обработать завершение транзакции</p>
<pre><code class="language-javascript">transaction.oncomplete = () => console.log('Транзакция завершена');
transaction.onerror = () => console.log('Ошибка транзакции');
transaction.onabort = () => console.log('Транзакция откатилась');</code></pre>
            </li>
        </ol>

        <h3>Демо-приложение:</h3>
        <div class="demoApp">
            <button id="addBook">Добавить книгу</button>
            <button id="clearStore">Очистить хранилище</button>
            <p>Список книг:</p>
            <ol id="booksList"></ol>
        </div>
        <script>
            let addBookButton = document.querySelector('#addBook');
            let clearStoreButton = document.querySelector('#clearStore');
            let booksList = document.querySelector('#booksList');
            //indexedDB.deleteDatabase('booksDB');

            let db;
            let openRequest = indexedDB.open('booksDB', 1);

            function fillEmptyBookList() {
                let li = document.createElement('li');
                let p = document.createElement('p');
                p.innerHTML = 'Книг пока нет. Пожалуйста, добавьте книги.'
                li.append(p);
                booksList.append(li);
            }

            openRequest.onupgradeneeded = function(event) {
                db = openRequest.result;
                let oldVersion = event.oldVersion;

                if (oldVersion < 1) {
                    db.createObjectStore('books', {keyPath: 'name'});
                }
            };

            openRequest.onsuccess = function() {
                db = openRequest.result;
                let transaction = db.transaction('books', 'readonly');
                let store = transaction.objectStore('books');

                let countRequest = store.count();

                countRequest.onsuccess = function() {
                    if (!countRequest.result) {
                        fillEmptyBookList();
                    } else {
                        let cursorRequest = store.openCursor();

                        cursorRequest.onsuccess = function() {
                        let cursor = cursorRequest.result;
                            if (cursor) {
                                let li = document.createElement('li');
                                let p = document.createElement('p');
                                p.innerHTML = `Название: ${cursor.primaryKey}<br>Цена: ${cursor.value.price}`;
                                li.append(p);
                                booksList.append(li);
                                cursor.continue();
                            }
                        };
                    }
                };
            };

            addBookButton.addEventListener('click', function() {
                let bookName = prompt('Название книги');
                let bookPrice = prompt('Цена книги');

                if (!bookName || !bookPrice) return;

                let transaction = db.transaction('books', 'readwrite');
                let store = transaction.objectStore('books');

                let countRequest = store.count();
                countRequest.onsuccess = function() {
                    if (!countRequest.result) {
                        booksList.firstElementChild.remove();
                    }
                    store.add({name: bookName, price: bookPrice});
                    let li = document.createElement('li');
                    let p = document.createElement('p');
                    p.innerHTML = `Название: ${bookName}<br>Цена: ${bookPrice}`;
                    li.append(p);
                    booksList.append(li);
                };
                addBookButton.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            });

            clearStoreButton.addEventListener('click', function() {
                let transaction = db.transaction('books', 'readwrite');
                let store = transaction.objectStore('books');

                let clearRequest = store.clear();

                clearRequest.onsuccess = function() {
                    booksList.innerHTML = '';
                    fillEmptyBookList();
                };
            });
        </script>
    </article>
</body>
</html>