<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ссылочный тип</title>
    <link href="../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Ссылочный тип</h2>
        <p>Некоторые хитрые способы вызова метода приводят к потере значения <code>this</code>, например:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;name: 'Джон',<br>
            &nbsp;&nbsp;hi() { alert(this.name); },<br>
            &nbsp;&nbsp;bye() { alert('Пока'); }<br>
            };<br>
            <br>
            user.hi(); // Джон (простой вызов метода работает хорошо)<br>
            <br>
            // Теперь давайте попробуем вызывать user.hi или user.bye<br>
            // в зависимости от имени пользователя user.name<br>
            (user.name === 'Джон' ? user.hi : user.bye)(); // Ошибка!
        </code>
        <p>В последней строчке кода используется условный оператор <code>?</code>, который определяет, какой будет
        вызван метод (<code>user.hi</code> или <code>user.bye</code>) в зависимости от выполнения условия. В данном
        случае будет выбран <code>user.hi</code>.</p>
        <p>Затем метод тут же вызывается с помощью скобок <code>()</code>. Но вызов не работает как положено!</p>
        <p>Вы можете увидеть, что при вызове будет ошибка, потому что значением <code>this</code> внутри функции
        становится <code>undefined</code> (полагаем, что у нас строгий режим).</p>
        <p>Так работает (доступ к методу объекта через точку):</p>
        <code>user.hi();</code>
        <p>Так уже не работает (вызываемый метод вычисляется):</p>
        <code>(user.name === 'Джон' ? user.hi : user.bye)(); // Ошибка!</code>
        <p>Почему? Если мы хотим понять, почему так происходит, давайте разберемся (заглянем под капот), как работает
        вызов методов (<code>obj.method()</code>).</p>
    </article>

    <article>
        <h2>Ссылочный тип: объяснение</h2>
        <p>Присмотревшись поближе, в выражении <code>obj.method()</code> можно заметить две операции:</p>
        <ol>
            <li>
                <p>Сначала оператор точка <code>'.'</code> возвращает свойство объекта - его метод (<code>obj.method</code>).</p>
            </li>
            <li>
                <p>Затем скобки <code>()</code> вызывают этот метод (исполняется код метода).</p>
            </li>
        </ol>
        <p>Итак, каким же образом информация о <code>this</code> передается из первой части во вторую?</p>
        <p>Если мы поместим эти операции в отдельные строки, то значение <code>this</code>, естественно, будет потеряно:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;name: 'John',<br>
            &nbsp;&nbsp;hi() {alert(this.name);}<br>
            };<br>
            <br>
            // Разделим получение метода объекта и его вызов в разных строках<br>
            let hi = user.hi;<br>
            hi(); // Ошибка, потому что значение this является undefined
        </code>
        <p>Здесь <code>hi = user.hi</code> сохраняет функцию в переменной, и далее в последней строке она вызывается
        полностью сама по себе, без объекта, так что нет <code>this</code>.</p>
        <p><b>Для работы вызова типа <code>user.hi()</code>, JavaScript используется трюк - точка <code>'.'</code>
        возвращает не саму функцию, а специальное значение «ссылочного типа», называемого «Reference type».</b></p>
        <p>Этот ссылочный тип (Reference type) является внутренним типом. Мы не можем явно использовать его, но он
        используется внутри языка.</p>
        <p>Значение ссылочного типа - это «триплет»: комбинация из трех значений <code>(base, name, strict)</code>, где:</p>
        <ul>
            <li>
                <p><code>base</code> - это объект.</p>
            </li>
            <li>
                <p><code>name</code> - это имя свойства объекта.</p>
            </li>
            <li>
                <p><code>strict</code> - это режим исполнения. Является true, если действует строгий режим
                (<code>use strict</code>).</p>
            </li>
        </ul>
        <p>Результатом доступа к свойству <code>user.hi</code> является не функция, а значение ссылочного типа.
        Для <code>user.hi</code> в строгом режиме оно будет таким:</p>
        <code>
            // Значение ссылочного типа (Reference type)<br>
            (user, 'hi', true)
        </code>
        <p>Когда скобки <code>()</code> применяются к значению ссылочного типа (происходит вызов), то они получают
        полную информацию об объекте и его методе, и могут поставить правильный <code>this</code> (<code>user</code>
        в данном случае, по <code>base</code>).</p>
        <p>Ссылочный тип - исключительно внутренний, промежуточный, используемый, чтобы передать информацию от точки
        <code>.</code> до вызывающий скобок <code>()</code>.</p>
        <p>При любой другой операции, например, присваивании <code>hi = user.hi</code>, ссылочный тип заменяется на
        собственное значение <code>user.hi</code> (функцию), и дальше работа уже идет только с ней. Поэтому дальнейший
        вызов происходит уже без <code>this</code>.</p>
        <p>Таким образом, значение <code>this</code> передается правильно, только если функцию вызывается напрямую
        с использованием точки <code>obj.method()</code> или квадратных скобок <code>obj['method']()</code>
        (они делают то же самое). Существуют различные способы решения этой проблемы: одним из таких является
        <code>func.bind()</code>.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Ссылочный тип - это внутренний тип языка.</p>
        <p>Чтение свойства, например, с точкой <code>.</code> в <code>obj.method()</code> возвращает не точное значение
        свойства, а специальное значение «ссылочного типа», в котором хранится как значение свойства, так и объект,
        из которого оно было взято.</p>
        <p>Это нужно для последующего вызова метода <code>()</code>, чтобы получить объект и установить для него
        <code>this</code>.</p>
        <p>Для всех остальных операций ссылочный тип автоматически становится значением свойства (в нашем случае функцией).</p>
        <p>Вся механика скрыта от наших глаз. Это имеет значение только в особых случаях, например, когда метод
        динамически извлекается из объекта с использованием выражения.</p>
    </article>
</body>
</html>