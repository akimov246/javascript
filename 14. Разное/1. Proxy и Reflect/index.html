<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Proxy и Reflect</title>
    <link href="../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Proxy и Reflect</h2>
        <p>Объект <code>Proxy</code> «оборачивается» вокруг другого объекта и может перехватывать (и, при желании,
        самостоятельно обрабатывать) разные действия с ним, например чтение/запись свойств и другие. Далее мы будем
        называть такие объекты «прокси».</p>
        <p>Прокси используются во многих библиотеках и некоторых браузерных фреймворках. В этой главе мы увидим много
        случаев применения прокси в решении реальных задач.</p>
        <p>Синтаксис:</p>
        <code>let proxy = new Proxy(target, handler);</code>
        <ul>
            <li>
                <p><code>target</code> - это объект, для которого нужно сделать прокси, может быть чем угодно, включая
                функции.</p>
            </li>
            <li>
                <p><code>handler</code> - конфигурация прокси: объект с «ловушками» («traps»): методами, которые перехватывают
                разные операции, например, ловушка <code>get</code> - для чтения свойства из <code>target</code>,
                ловушка <code>set</code> - для записи свойства в <code>target</code> и так далее.</p>
            </li>
        </ul>
        <p>При операциях над <code>proxy</code>, если в <code>handler</code> имеется соответствующая «ловушка», то она
        срабатывает, и прокси имеет возможность по-своему обработать ее, иначе операция будет совершена над оригинальным
        объектом <code>target</code>.</p>
        <p>В качестве начального примера создадим прокси без всяких ловушек:</p>
        <code>
            let target = {};<br>
            let proxy = new Proxy(target, {}); // Пустой handler<br>
            <br>
            proxy.test = 5; // Записываем в proxy (1)<br>
            alert(target.test); // 5, свойство появилось в target!<br>
            <br>
            alert(proxy.test); // 5, мы также можем прочитать его из прокси (2)<br>
            <br>
            for (let key in proxy) alert(key); // test, итерация работает (3)
        </code>
        <p>Так как нет ловушек, то все операции над <code>proxy</code> применяются к оригинальному объекту <code>target</code>.</p>
        <ol>
            <li>
                <p>Запись свойства <code>proxy.test=</code> устанавливает значение на <code>target</code>.</p>
            </li>
            <li>
                <p>Чтение свойства <code>proxy.test</code> возвращает значение из <code>target</code>.</p>
            </li>
            <li>
                <p>Итерация по <code>proxy</code> возвращает значения из <code>target</code>.</p>
            </li>
        </ol>
        <p>Как мы видим, без ловушек <code>proxy</code> является прозрачной оберткой над <code>target</code>.</p>
        <p><code>Proxy</code> - это особый, «экзотический» объект, у него нет собственных свойств. С пустым
        <code>handler</code> он просто перенаправляет все операции на <code>target</code>.</p>
        <p>Чтобы активировать другие его возможности, добавим ловушки.</p>
        <p>Что именно мы можем ими перехватить?</p>
        <p>Для большинства действий с объектами в спецификации JavaScript есть так называемый «внутренний метод»,
        который на самом низком уровне описывает, как его выполнять. Например, <code>[[Get]]</code> - внутренний
        метод для чтения свойства, <code>[[Set]]</code> - для записи свойства, и так далее. Эти методы используются
        только в спецификации, мы не можем обратиться напрямую к них по имени.</p>
        <p>Ловушки как раз перехватывают вызовы этих внутренних методов. Полный список методов, которые можно перехватывать,
        перечислен в <a target="_blank" href="https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots">спецификации
        Proxy</a>, а также в таблице ниже.</p>
        <p>Для каждого внутреннего метода в этой таблице указана ловушка, то есть имя метода, который мы можем добавить
        в параметр <code>handler</code>, при создании <code>new Proxy</code>, чтобы перехватывать данную операцию:</p>
        <table>
            <thead>
            <tr>
                <td>Внутренний метод</td>
                <td>Ловушка</td>
                <td>Что вызывает</td>
            </tr>
            </thead>
            <tr>
                <td><code>[[Get]]</code></td>
                <td><code>get</code></td>
                <td>Чтение свойства</td>
            </tr>
            <tr>
                <td><code>[[Set]]</code></td>
                <td><code>set</code></td>
                <td>Запись свойства</td>
            </tr>
            <tr>
                <td><code>[[HasProperty]]</code></td>
                <td><code>has</code></td>
                <td>Оператор <code>in</code></td>
            </tr>
            <tr>
                <td><code>[[Delete]]</code></td>
                <td><code>deleteProperty</code></td>
                <td>Оператор <code>delete</code></td>
            </tr>
            <tr>
                <td><code>[[Call]]</code></td>
                <td><code>apply</code></td>
                <td>Вызов функции</td>
            </tr>
            <tr>
                <td><code>[[Construct]]</code></td>
                <td><code>construct</code></td>
                <td>Оператор <code>new</code></td>
            </tr>
            <tr>
                <td><code>[[GetPrototypeOf]]</code></td>
                <td><code>getPrototypeOf</code></td>
                <td><code>Object.getPrototypeOf</code></td>
            </tr>
            <tr>
                <td><code>[[SetPrototypeOf]]</code></td>
                <td><code>setPrototypeOf</code></td>
                <td><code>Object.setPrototypeOf</code></td>
            </tr>
            <tr>
                <td><code>[[IsExtensible]]</code></td>
                <td><code>isExtensible</code></td>
                <td><code>Object.IsExtensible</code></td>
            </tr>
            <tr>
                <td><code>[[PreventExtensions]]</code></td>
                <td><code>preventExtensions</code></td>
                <td><code>Object.preventExtensions</code></td>
            </tr>
            <tr>
                <td><code>[[DefineOwnProperty]]</code></td>
                <td><code>defineProperty</code></td>
                <td><code>Object.defineProperty, Object.defineProperties</code></td>
            </tr>
            <tr>
                <td><code>[[GetOwnProperty]]</code></td>
                <td><code>getOwnPropertyDescriptor</code></td>
                <td><code>Object.getOwnPropertyDescriptor, for...in, Object.keys/values/entries</code></td>
            </tr>
            <tr>
                <td><code>[[OwnPropertyKeys]]</code></td>
                <td><code>ownKeys</code></td>
                <td><code>Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for...in, Object.keys/values/entries</code></td>
            </tr>
        </table>

        <article class="warning">
            <h2>Инварианты</h2>
            <p>JavaScript налагает некоторые условия - инварианты на реализацию внутренних методов и ловушек.</p>
            <p>Большинство из них касаются возвращаемых значений:</p>
            <ul>
                <li>
                    <p>Метод <code>[[Set]]</code> должен возвращать <code>true</code>, если значение успешно записано,
                    иначе <code>false</code>.</p>
                </li>
                <li>
                    <p>Метод <code>[[Delete]]</code> должен возвращать <code>true</code>, если значение было успешно
                    удалено, иначе <code>false</code>.</p>
                </li>
                <li>
                    <p>... и так далее, мы увидим больше в примерах ниже.</p>
                </li>
            </ul>
            <p>Есть и другие инварианты, например:</p>
            <ul>
                <li>
                    <p>Метод <code>[[GetPrototypeOf]]</code>, примененный к прокси, должен возвращать то же значение,
                    что и метод <code>[[GetPrototypeOf]]</code>, примеренный к оригинальному объекту. Другими словами,
                    чтение прототипа объекта прокси всегда должно возвращать прототип оригинального объекта.</p>
                </li>
            </ul>
            <p>Ловушки могут перехватывать вызовы этих методов, но должны выполнять указанные условия.</p>
            <p>Инварианты гарантируют корректное и последовательное поведение конструкций и методов языка. Полный список
            инвариантов можно найти в спецификации, хотя скорее всего вы не нарушите эти условия, если только не
            соберетесь делать что-то совсем уж странное.</p>
        </article>

        <p>Теперь давайте посмотрим, как это все работает, на реальных примерах.</p>
    </article>

    <article>
        <h2>Значение по умолчанию с ловушкой «get»</h2>
        <p>Чаще всего используются ловушки на чтение/запись свойств.</p>
        <p>Чтобы перехватить операцию чтения, <code>handler</code> должен иметь метод
        <code>get(target, property, receiver)</code>.</p>
        <p>Он срабатывает при попытке прочитать свойство объекта с аргументами:</p>
        <ul>
            <li>
                <p><code>target</code> - это оригинальный объект, который передавался первым аргументом в конструктор
                <code>new Proxy</code>.</p>
            </li>
            <li>
                <p><code>property</code> - это имя свойства.</p>
            </li>
            <li>
                <p><code>receiver</code> - если свойство объекта является геттером, то <code>receiver</code> - это
                объект, который будет использован как <code>this</code> при его вызове. Обычно это сам объект прокси
                (или наследующим от него объект).</p>
            </li>
        </ul>
        <p>Давайте применим ловушку <code>get</code>, чтобы реализовать «значение по умолчанию» для свойства объекта.</p>
        <p>Например, сделает числовой массив, так чтобы при чтении из него несуществующего элемента возвращался
        <code>0</code>.</p>
        <p>Обычно при чтении из массива несуществующего свойства возвращается <code>undefined</code>, но мы обернем
        обычный массив в прокси, который перехватывает операцию чтения свойства из массива и возвращает <code>0</code>,
        если такого элемента нет:</p>
        <code>
            let numbers = [0, 1, 2];<br>
            <br>
            numbers = new Proxy(numbers, {<br>
            &nbsp;&nbsp;get(target, prop) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (prop in target) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return target[prop];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0; // Значение по умолчанию<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            alert(numbers[1]); // 1<br>
            alert(numbers[23]); // 0 (нет такого элемента)
        </code>
        <p>Как видно, это очень легко сделать при помощи ловушки <code>get</code>.</p>
        <p>Мы модем использовать <code>Proxy</code> для реализации любой логики возврата значений по умолчанию.</p>
        <p>Представим, что у нас есть объект-словарь с фразами на английском и их перевод на испанский:</p>
        <code>
            let dictionary = {<br>
            &nbsp;&nbsp;'Hello': 'Hola',<br>
            &nbsp;&nbsp;'Bye': 'Adios'<br>
            };<br>
            <br>
            alert(dictionary['Hello']); // Hola<br>
            alert(dictionary['Welcome']); // undefined<br>
        </code>
        <p>Сейчас, если фразы в <code>dictionary</code> нет, при чтении возвращается <code>undefined</code>. Но на
        практике оставлять фразы непереведенными лучше, чем использовать <code>undefined</code>. Поэтому давайте
        сделаем так, чтобы при отсутствии перевода возвращалась оригинальная фраза на английском, вместо
        <code>undefined</code>.</p>
        <p>Чтобы достичь этого, обернем <code>dictionary</code> в прокси, перехватывающий операцию чтения:</p>
        <code>
            let dictionary = {<br>
            &nbsp;&nbsp;'Hello': 'Hola',<br>
            &nbsp;&nbsp;'Bye': 'Adios'<br>
            };<br>
            <br>
            dictionary = new Proxy(dictionary, {<br>
            &nbsp;&nbsp;get(target, phrase) { // Перехватываем чтение свойства в dictionary<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (phrase in target) { // Если перевод для фразы есть в словаре<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return target[phrase]; // Возвращаем его<br>
            &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Иначе возвращаем непереведенную фразу<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return phrase;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            // Запросим перевод произвольного выражения в словаре!<br>
            // В худшем случае оно не будет переведено<br>
            alert(dictionary('Hello')); // Hola<br>
            alert(dictionary('Welcome to Proxy')); // Welcome to Proxy (нет перевода)
        </code>

        <article class="note">
            <h2>Прокси следует использовать везде вместо <code>target</code></h2>
            <p>Пожалуйста, обратите внимание: прокси перезаписывает переменную:</p>
            <code>dictionary = new Proxy(dictionary, ...);</code>
            <p>Прокси должен заменить собой оригинальный объект повсюду. Никто не должен ссылаться на оригинальный
            объект после того, как он был проксирован. Иначе очень легко запутаться.</p>
        </article>
    </article>

    <article>
        <h2>Валидация с ловушкой «set»</h2>
        <p>Допустим, мы хотим сделать массив исключительно для чисел. Если в него добавляется значение иного типа,
        то это должно приводить к ошибке.</p>
        <p>Ловушка <code>set</code> срабатывает, когда происходит запись свойства.</p>
        <p><code>set(target, property, value, receiver)</code>:</p>
        <ul>
            <li>
                <p><code>target</code> - это оригинальный объект, который передавался первым аргументом в конструктор
                <code>new Proxy</code>.</p>
            </li>
            <li>
                <p><code>property</code> - имя свойства.</p>
            </li>
            <li>
                <p><code>value</code> - значение свойства.</p>
            </li>
            <li>
                <p><code>receiver</code> - аналогично ловушке <code>get</code>, этот аргумент имеет значение, только
                если свойство - сеттер.</p>
            </li>
        </ul>
        <p>Ловушка <code>set</code> должна вернуть <code>true</code>, если запись прошла успешно, и <code>false</code>
        в противном случае (будет сгенерирована ошибка <code>TypeError</code>).</p>
        <p>Давайте применим ее для проверки новых значений:</p>
        <code>
            let numbers = [];<br>
            <br>
            numbers = new Proxy(numbers, {<br>
            &nbsp;&nbsp;set(target, prop, val) { // Для перехвата записи свойства<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (typeof val === 'number') {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target[prop] = val;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
            &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            numbers.push(1); // Добавилось успешно<br>
            numbers.push(2); // Добавилось успешно<br>
            alert('Длина: ' + numbers.length); // Длина: 2<br>
            <br>
            numbers.push('тест'); // TypeError (ловушка set на прокси вернула false)<br>
            <br>
            alert('Интерпретатор никогда не доходит до этой строки (из-за ошибки в строке выше)');
        </code>
        <p>Обратите внимание, что встроенная функциональность массива по-прежнему работает! Значения добавляются методом
        <code>push</code>. Свойство <code>length</code> при этом увеличивается. Наш прокси ничего не ломает.</p>
        <p>Нам не нужно переопределять методы массива <code>push</code> и <code>unshift</code> и другие, чтобы
        добавлять туда проверку на тип, так как внутри себя они используют операцию <code>[[Set]]</code>, которая
        перехватывает прокси.</p>
        <p>Таким образом, код остается чистым и прозрачным.</p>

        <article class="warning">
            <h2>Не забывайте вернуть <code>true</code></h2>
            <p>Как сказано ранее, нужно соблюдать инварианты.</p>
            <p>Для <code>set</code> реализация ловушки должна возвращать <code>true</code> в случае успешной записи
            свойства.</p>
            <p>Если забыть это сделать или возвратить любое ложное значение, это приведет к ошибке <code>TypeError</code>.</p>
        </article>
    </article>

    <article>
        <h2>Перебор при помощи «ownKeys» и «getOwnPropertyDescriptor»</h2>
        <p><code>Object.keys</code>, цикл <code>for...in</code> и большинство других методов, которые работают со списком
        свойств объекта, используют внутренний метод <code>[[OwnPropertyKeys]]</code> (перехватываемый ловушкой
        <code>ownKeys</code>) для их получения.</p>
        <p>Такие методы различаются в деталях:</p>
        <ul>
            <li>
                <p><code>Object.getOwnPropertyNames(obj)</code> возвращает не-символичные ключи.</p>
            </li>
            <li>
                <p><code>Object.getOwnPropertySymbols(obj)</code> возвращает символичные ключи.</p>
            </li>
            <li>
                <p><code>Object.keys/values()</code> возвращает не-символичные ключи/значения с флагом
                <code>enumerable</code>.</p>
            </li>
            <li>
                <p><code>for...in</code> перебирает не-символичные ключи с флагом <code>enumerable</code>, а также
                ключи прототипов.</p>
            </li>
        </ul>
        <p>... Но все они начинают с этого списка.</p>
        <p>В примере ниже мы используем ловушку <code>ownKeys</code>, чтобы цикл <code>for...in</code> по объекту,
        равно как <code>Object.keys</code> и <code>Object.values</code> пропускали свойства, начинающиеся с
        подчеркивания <code>_</code>:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;name: 'Вася',<br>
            &nbsp;&nbsp;age: 30,<br>
            &nbsp;&nbsp;_password: '***'<br>
            };<br>
            <br>
            user = new Proxy(user, {<br>
            &nbsp;&nbsp;ownKeys(target) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return Object.keys(target).filter(key => !key.startsWith('_'));<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            // ownKeys исключил _password<br>
            for (let key in user) alert(key); // name, затем: age<br>
            <br>
            // Аналогичный эффект для этих методов:<br>
            alert(Object.keys(user)); // name,age<br>
            alert(Object.values(user)); // Вася,30
        </code>
        <p>Как видно, работает.</p>
        <p>Впрочем, если мы попробуем возвратить ключ, которого в объекте на самом деле нет, то <code>Object.keys</code>
        его не выдаст:</p>
        <code>
            let user = {};<br>
            <br>
            user = new Proxy(user, {<br>
            &nbsp;&nbsp;ownKeys(target) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return ['a', 'b', 'c'];<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            alert(Object.keys(user)); // &ltпусто&gt
        </code>
        <p>Почему? Причина проста: <code>Object.keys</code> возвращает только свойства с флагом <code>enumerable</code>.
        Для того, чтобы определить, есть ли этот флаг, он для каждого свойства вызывает внутренний метод
        <code>[[GetOwnProperty]]</code>, который получает его дескриптор. А в данном случае свойство отсутствует,
        его дескриптор пуст, флага <code>enumerable</code> нет, поэтому оно пропускается.</p>
        <p>Чтобы <code>Object.keys</code> возвращал свойство, нужно либо чтобы свойство в объекте физически было,
        причем с флагом <code>enumerable</code>, либо перехватить вызов <code>[[GetOwnProperty]]</code>
        (это делает ловушка <code>getOwnPropertyDescriptor</code>), и там вернуть дескриптор с <code>enumerable: true</code>.</p>
        <p>Вот так будет работать:</p>
        <code>
            let user = {};<br>
            <br>
            user = new Proxy(user, {<br>
            &nbsp;&nbsp;ownKeys(target) { // Вызывается 1 раз для получения списка свойств<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return ['a', 'b', 'c'];<br>
            &nbsp;&nbsp;},<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;getOwnProperty(target, prop) { // Вызывается для каждого свойства<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enumerable: true,<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;configurable: true,<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ... другие флаги, возможно, value: ...<br>
            &nbsp;&nbsp;&nbsp;&nbsp;};<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            alert(Object.keys(user)); // a,b,c
        </code>
        <p>Еще раз заметим, что получение дескриптора нужно перехватывать только если свойство отсутствует в самом
        объекте.</p>
    </article>

    <article>
        <h2>Защищенные свойства с ловушкой «deleteProperty» и другими</h2>
        <p>Существует широко распространенное соглашение о том, что свойства и методы, название которых начинается
        с символа подчеркивания <code>_</code>, следует считать внутренним. К ним не следует обращаться снаружи объекта.</p>
        <p>Однако технически это все равно возможно:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;name: 'Вася',<br>
            &nbsp;&nbsp;age: 30,<br>
            &nbsp;&nbsp;_password: 'secret'<br>
            };<br>
            <br>
            alert(user.password); // secret
        </code>
        <p>Давайте применим прокси, чтобы защитить свойства, начинающиеся на <code>_</code>, от доступа извне.</p>
        <p>Нам будут нужны следующие ловушки:</p>
        <ul>
            <li>
                <p><code>get</code> - для того, чтобы сгенерировать ошибку при чтении такого свойства.</p>
            </li>
            <li>
                <p><code>set</code> - для того, чтобы сгенерировать ошибку при записи.</p>
            </li>
            <li>
                <p><code>deleteProperty</code> - для того, чтобы сгенерировать ошибку при удалении.</p>
            </li>
            <li>
                <p><code>ownKeys</code> - для того, чтобы исключить такие свойства из <code>for...in</code> и методов
                типа <code>Object.keys</code>.</p>
            </li>
        </ul>
        <p>Вот соответствующий код:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;name: 'Вася',<br>
            &nbsp;&nbsp;_password: 'secret'<br>
            };<br>
            <br>
            user = new Proxy(user, {<br>
            &nbsp;&nbsp;get(target, prop) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (prop.startsWith('_')) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Отказано в доступе');<br>
            &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let value = target[prop];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (typeof value === 'function') ? value.bind(target) : value; // (*)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;},<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;set(target, prop, val) { // Перехват записи свойства<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (prop.startsWith('_')) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Отказано в доступе');<br>
            &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target[prop] = val;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;},<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;deleteProperty(target, prop) { // Перехватываем удаление свойства<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (prop.startsWith('_')) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Отказано в доступе');<br>
            &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete target[prop];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;},<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;ownKeys(target) { // Перехватываем попытку итерации<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return Object.keys(target).filter(key => !prop.startsWith('_'));<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            // get не позволяет прочитать _password<br>
            try {<br>
            &nbsp;&nbsp;alert(user._password); // Error: Отказано в доступе<br>
            } catch(e) {alert(e.message);}<br>
            <br>
            // set не позволяет записать _password<br>
            try {<br>
            &nbsp;&nbsp;user._password = 'test'; // Error: Отказано в доступе<br>
            } catch(e) {alert(e.message);}<br>
            <br>
            // deleteProperty не позволяет удалить _password<br>
            try {<br>
            &nbsp;&nbsp;delete user[_password]; // Error: Отказано в доступе<br>
            } catch(e) {alert(message(e));}<br>
            <br>
            // ownKeys исключает _password из списка видимых для итерации свойств<br>
            for (let key in user) alert(key); // name
        </code>
        <p>Обратите внимание на важную деталь в ловушке <code>get</code> на строке <code>(*)</code>:</p>
        <code>
            get(target, prop) {<br>
            &nbsp;&nbsp;// ...<br>
            &nbsp;&nbsp;let value = target[prop];<br>
            &nbsp;&nbsp;return (typeof value === 'function') ? value.bind(target) : value; // (*)<br>
            }
        </code>
        <p>Зачем для функции вызывать <code>value.bind(target)</code>?</p>
        <p>Все дело в том, что метод самого объекта, например <code>user.checkPassword()</code>, должен иметь доступ к
        свойству <code>_password</code>:</p>
        <code>
            user = {<br>
            &nbsp;&nbsp;// ...<br>
            &nbsp;&nbsp;checkPassword(value) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;// Метод объекта должен иметь доступ на чтение _password<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return value === this._password;<br>
            &nbsp;&nbsp;}<br>
            }
        </code>
        <p>Вызов <code>user.checkPassword()</code> получает проксированный объект <code>user</code> в качестве
        <code>this</code> (объект перед точкой становится <code>this</code>), так что когда такой вызов обращается к
        <code>this._password</code>, ловушка <code>get</code> вступает в действие (она срабатывает при любом чтении
        свойства), и выбрасывается ошибка.</p>
        <p>Поэтому мы привязываем контекст к методам объекта - оригинальный объект <code>target</code> в строке
        <code>(*)</code>. Тогда их дальнейшие вызовы будут использовать <code>target</code> в качестве <code>this</code>,
        без всяких ловушек.</p>
        <p>Такое решение обычно работает, но не является идеальным, поскольку метод может передать оригинальный объект
        куда-то еще, и возможна путаница: где изначальный объект, а где - проксированный.</p>
        <p>К тому же, объект может проксироваться несколько раз (для добавления различных возможностей), и если
        передавать методу исходный, то могут быть неожиданности.</p>
        <p>Так что везде использовать такой прокси не стоит.</p>

        <article class="note">
            <h2>Приватные свойства в классах</h2>
            <p>Современные интерпретаторы JavaScript поддерживают приватные свойства в классах. Названия таких свойств
            должны начинаться с <code>#</code>. Для них не нужны подобные прокси.</p>
            <p>Впрочем, приватные свойства имеют свои недостатки. В частности, они не наследуются.</p>
        </article>
    </article>

    <article>
        <h2>«В диапазоне» с ловушкой «has»</h2>
        <p>Давайте посмотрим еще примеры.</p>
        <p>Предположим, у нас есть объект <code>range</code>, описывающий диапазон:</p>
        <code>
            let range = {<br>
            &nbsp;&nbsp;start: 1,<br>
            &nbsp;&nbsp;end: 10<br>
            };
        </code>
        <p>Мы бы хотели использовать оператор <code>in</code>, чтобы проверить, что некоторое число находится в указанном
        диапазоне.</p>
        <p>Ловушка <code>has</code> перехватывает вызовы <code>in</code>.</p>
        <p><code>has(target, property)</code>:</p>
        <ul>
            <li>
                <p><code>target</code> - это оригинальный объект, который передавался первым аргументом в конструктор
                <code>new Proxy</code>.</p>
            </li>
            <li>
                <p><code>property</code> - имя свойства.</p>
            </li>
        </ul>
        <p>Вот демо:</p>
        <code>
            let range = {<br>
            &nbsp;&nbsp;start: 1,<br>
            &nbsp;&nbsp;end: 10<br>
            };<br>
            <br>
            range = new Proxy(range, {<br>
            &nbsp;&nbsp;has(target, prop) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return prop >= target.start && prop <= target.end;<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            alert(5 in range); // true<br>
            alert(50 in range); // false
        </code>
        <p>Отлично выглядит, не правда ли? И очень просто в реализации.</p>
    </article>

    <article>
        <h2>Оборачиваем функции: «apply»</h2>
        <p>Мы можем оборачивать в прокси и функции.</p>
        <p>Ловушка <code>apply(target, thisArg, args)</code> активируется при вызове прокси как функции:</p>
        <ul>
            <li>
                <p><code>target</code> - это оригинальный объект (как мы помним, функция - это объект в языке JavaScript).</p>
            </li>
            <li>
                <p><code>thisArg</code> - это контекст <code>this</code>.</p>
            </li>
            <li>
                <p><code>args</code> - список аргументов.</p>
            </li>
        </ul>
        <p>Например, давайте вспомним декоратор <code>delay(f, ms)</code>, созданный нами в главе
        <a target="_blank" href="../../6.%20Продвинутая%20работа%20с%20функциями/9.%20Декораторы%20и%20переадресация%20вызова,%20call,%20apply/index.html">
            Декораторы и переадресация вызова, call/apply
        </a>.</p>
        <p>Тогда мы обошлись без создания прокси. Вызов <code>delay(f, ms)</code> возвращал функцию, которая передавала
        вызовы <code>f</code> после <code>ms</code> миллисекунд.</p>
        <p>Вот предыдущая реализация на основе функции:</p>
        <code>
            function delay(f, ms) {<br>
            &nbsp;&nbsp;// Возвращает обертку, которая вызывает функцию f через таймаут<br>
            &nbsp;&nbsp;return function() { // (*)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => f.apply(this, arguments), ms);<br>
            &nbsp;&nbsp;};<br>
            }<br>
            <br>
            function sayHi(user) {<br>
            &nbsp;&nbsp;alert(`Привет, ${user}!`);<br>
            }<br>
            <br>
            // После обертки вызовы sayHi будут срабатывать c задержкой в 3 секунды<br>
            sayHi = delay(sayHi, 3000);<br>
            <br>
            sayHi('Вася'); // Привет, Вася! (через 3 секунды)
        </code>
        <p>Как мы уже видели, это в целом работает. Функция-обертка в строке <code>(*)</code> вызывает нужную функцию
        с указанной задержкой.</p>
        <p>Но наша функция-обертка не перенаправляет операции чтения/записи свойства и другие. После обертывания
        доступ к свойствам оригинальной функции, таким как <code>name</code>, <code>length</code> и другим, будет потерян.</p>
        <code>
            function delay(f, ms) {<br>
            &nbsp;&nbsp;return function() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => f.apply(this, arguments), ms);<br>
            &nbsp;&nbsp;};<br>
            }<br>
            <br>
            function sayHi(user) {<br>
            &nbsp;&nbsp;alert(`Привет, ${user}!`);<br>
            }<br>
            <br>
            alert(sayHi.length); // 1 (в функции length - это число аргументов в ее объявлении)<br>
            <br>
            sayHi = delay(sayHi, 3000);<br>
            <br>
            alert(sayHi.length); // 0 (в объявлении функции-обертки ноль аргументов
        </code>
        <p>Прокси куда более мощные в этом смысле, поскольку они перенаправляют все к оригинальному объекту.</p>
        <p>Давайте используем прокси вместо функции-обертки:</p>
        <code>
            function delay(f, ms) {<br>
            &nbsp;&nbsp;return new Proxy(f, {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;apply(target, thisArg, args) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => target.apply(thisArg, args), ms);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;});<br>
            }<br>
            <br>
            function sayHi(user) {<br>
            &nbsp;&nbsp;alert(`Привет, ${user}!`);<br>
            }<br>
            <br>
            sayHi = delay(sayHi, 3000);<br>
            <br>
            alert(sayHi.length); // 1 (*) прокси перенаправляет чтение свойства length на исходную функцию<br>
            <br>
            sayHi('Вася'); // Привет, Вася! (через 3 секунды)
        </code>
        <p>Результат такой же, но сейчас не только вызовы, но и другие операции на прокси перенаправляются к оригинальной
        функции. Таким образом, операция чтения свойства <code>sayHi.length</code> возвращает корректное значение в
        строке <code>(*)</code> после проксирования.</p>
        <p>Мы получили лучшую обертку.</p>
        <p>Существуют и другие ловушки: полный список есть в начале этой главы. Использовать их можно по аналогии с
        вышеописанными.</p>
    </article>

    <article>
        <h2>Reflect</h2>
        <p><code>Reflect</code> - встроенный объект, упрощающий создание прокси.</p>
        <p>Ранее мы говорили о том, что внутренние методы, такие как <code>[[Get]]</code>, <code>[[Set]]</code> и другие,
        существуют только в спецификации, что к ним нельзя обратиться напрямую.</p>
        <p>Объект <code>Reflect</code> делает это возможным. Его методы - минимальные обертки вокруг внутренних методов.</p>
        <p>Вот примеры операций и вызовы <code>Reflect</code>, которые делают то же самое:</p>
        <table>
            <thead>
            <tr>
                <td>Операция</td>
                <td>Вызов <code>Reflect</code></td>
                <td>Внутренний метод</td>
            </tr>
            </thead>
            <tr>
                <td><code>obj[prop]</code></td>
                <td><code>Reflect.get(obj, prop)</code></td>
                <td><code>[[Get]]</code></td>
            </tr>
            <tr>
                <td><code>obj[prop] = set</code></td>
                <td><code>Reflect.set(obj, prop, value)</code></td>
                <td><code>[[Set]]</code></td>
            </tr>
            <tr>
                <td><code>delete obj[prop]</code></td>
                <td><code>Reflect.deleteProperty(obj, prop)</code></td>
                <td><code>[[Delete]]</code></td>
            </tr>
            <tr>
                <td><code>new F(value)</code></td>
                <td><code>Reflect.construct(F, value)</code></td>
                <td><code>[[Construct]]</code></td>
            </tr>
            <tr>
                <td>...</td>
                <td>...</td>
                <td>...</td>
            </tr>
        </table>
        <p>Например:</p>
        <code>
            let user = {};<br>
            <br>
            Reflect.set(user, 'name', 'Вася');<br>
            <br>
            alert(user.name); // Вася
        </code>
        <p>В частности, <code>Reflect</code> позволяет вызвать оператор (<code>new</code>, <code>delete</code>...)
        как функции (<code>Reflect.construct</code>, <code>Reflect.deleteProperty</code>, ...). Это интересная возможность,
        но здесь нам важно другое.</p>
        <p><b>Для каждого внутреннего метода, перехватываемого <code>Proxy</code>, есть соответствующий метод в
        <code>Reflect</code>, который имеет такое же имя и те же аргументы, что и ловушки <code>Proxy</code>.</b></p>
        <p>Поэтому мы можем использовать <code>Reflect</code>, чтобы перенаправить операцию на исходный объект.</p>
        <p>В этом примере обе ловушки <code>get</code> и <code>set</code> прозрачно (как будто их нет) перенаправляют
        операции чтения и записи на объект, при этом выводя сообщение:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;name: 'Вася'<br>
            };<br>
            <br>
            user = new Proxy(user, {<br>
            &nbsp;&nbsp;get(target, prop, receiver) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;alert(`GET ${prop}`);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return Reflect.get(target, prop, receiver); // (1)<br>
            &nbsp;&nbsp;},<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;set(target, prop, value, receiver) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;alert(`SET ${prop}=${value}`);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return Reflect.set(target, prop, value, receiver); // (2)<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            let name = user.name; // Выводит "GET name"<br>
            user.name = 'Петя'; // Выводит "SET name=Петя"
        </code>
        <p>Здесь:</p>
        <ol>
            <li>
                <p><code>Reflect.get</code> читает свойство объекта.</p>
            </li>
            <li>
                <p><code>Reflect.set</code> записывает свойство и возвращает <code>true</code> при успехе,
                иначе <code>false</code>.</p>
            </li>
        </ol>
        <p>То есть, все очень просто - если ловушка хочет перенаправить вызов на объект, то достаточно вызвать
        <code>Reflect.&ltметод&gt</code> с теме же аргументами.</p>
        <p>В большинстве случаев мы можем сделать все то же самое и без <code>Reflect</code>, например, чтение свойства
        <code>Reflect.get(target, prop, receiver)</code> можно заменить на <code>target[prop]</code>. Но некоторые
        нюансы легко упустить.</p>
    </article>

    <article>
        <h2>Прокси для геттера</h2>
        <p>Рассмотрим конкретный пример, демонстрирующий, чем лучше <code>Reflect.get</code>, и заодно разберемся,
        зачем в <code>get/set</code> нужен третий аргумент <code>receiver</code>, мы его ранее не использовали.</p>
        <p>Допустим, у нас есть объект <code>user</code> со свойством <code>_name</code> и геттером для него.</p>
        <p>Сделаем вокруг <code>user</code> прокси:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;_name: 'Гость',<br>
            &nbsp;&nbsp;get name() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return this._name;<br>
            &nbsp;&nbsp;}<br>
            };<br>
            <br>
            let userProxy = new Proxy(user, {<br>
            &nbsp;&nbsp;get(target, prop, receiver) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return target[prop];<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            alert(userProxy.name); // Гость
        </code>
        <p>Ловушка <code>get</code> здесь «прозрачная», она возвращает свойство исходного объекта и больше ничего не
        делает. Для нашего примера этого вполне достаточно.</p>
        <p>Казалось бы, все в порядке. Но давайте немного усложним пример.</p>
        <p>Если мы унаследуем от проксированного <code>user</code> объект <code>admin</code>, то мы увидим, что он
        ведет себя некорректно:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;_name: 'Гость',<br>
            &nbsp;&nbsp;get name() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return this._name;<br>
            &nbsp;&nbsp;}<br>
            };<br>
            <br>
            let userProxy = new Proxy(user, {<br>
            &nbsp;&nbsp;get(target, prop, receiver) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return target[prop]; // (*) target = user<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            let admin = {<br>
            &nbsp;&nbsp;__proto__: userProxy,<br>
            &nbsp;&nbsp;_name: 'Админ'<br>
            };<br>
            <br>
            // Ожидается: Админ<br>
            alert(admin.name); // Выводится Гость (?!?)
        </code>
        <p>Обращение к свойству <code>admin.name</code> должно возвращать строку <code>'Админ'</code>, а выводит
        <code>'Гость'</code>!</p>
        <p>В чем дело? Можем быть, мы делаем что-то не так с наследованием?</p>
        <p>Но если убрать прокси, то все будет работать как ожидается.</p>
        <p>На самом деле, проблема в прокси, в строке <code>(*)</code>.</p>
        <ol>
            <li>
                <p>При чтении <code>admin.name</code>, так как в объекте <code>admin</code> нет свойства
                <code>name</code>, оно ищется в прототипе.</p>
            </li>
            <li>
                <p>Прототипом является прокси <code>userProxy</code>.</p>
            </li>
            <li>
                <p>При чтении из прокси свойства <code>name</code> срабатывает ловушка <code>get</code> и возвращает
                его из исходного объекта как <code>target[prop]</code> в строке <code>(*)</code>.</p>
                <p>Вызов <code>target[prop]</code>, если <code>prop</code> - это геттер, запускает его в код
                в контексте <code>this=target</code>. Поэтому результатом является <code>this._name</code> из исходного
                объекта <code>target</code>, то есть из <code>user</code>.</p>
            </li>
        </ol>
        <p>Именно для исправления таких ситуаций нужен <code>receiver</code>, третий аргумент ловушки <code>get</code>.
        В нем хранится ссылка на правильный контекст <code>this</code>, который нужно передать геттеру. В данном случае
        это <code>admin</code>.</p>
        <p>Как передать геттеру контекст? Для обычной функции мы могли бы использовать <code>call/apply</code>, но это
        же геттер, его не вызывают, просто читают значение.</p>
        <p>Это может сделать <code>Reflect.get</code>. Все будет работать верно, если использовать его.</p>
        <p>Вот исправленный вариант:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;_name: 'Гость',<br>
            &nbsp;&nbsp;get name() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return this._name;<br>
            &nbsp;&nbsp;}<br>
            };<br>
            <br>
            let userProxy = new Proxy(user, {<br>
            &nbsp;&nbsp;get(target, prop, receiver) { // receiver = admin<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return Reflect.get(target, prop, receiver); // (*)<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            let admin = {<br>
            &nbsp;&nbsp;__proto__: userProxy,<br>
            &nbsp;&nbsp;_name: 'Админ'<br>
            };<br>
            <br>
            alert(admin.name); // Админ
        </code>
        <p>Сейчас <code>receiver</code>, содержащий ссылку на корректный <code>this</code> (то есть на <code>admin</code>),
        передается геттеру посредством <code>Reflect.get</code> в строке <code>(*)</code>.</p>
        <p>Можно переписать ловушку и короче:</p>
        <code>
            get(target, prop, receiver) {<br>
            &nbsp;&nbsp;return Reflect.get(...arguments);<br>
            }
        </code>
        <p>Методы в <code>Reflect</code> имеют те же названия, что и соответствующие ловушки, и принимают такие же
        аргументы. Это было специально задумано при разработке спецификации JavaScript.</p>
        <p>Так что <code>return Reflect...</code> дает простую и безопасную возможность перенаправить операцию
        на оригинальный объект и при этом предохраняет нас от возможных ошибок, связанных с этим действием.</p>
    </article>

    <article>
        <h2>Ограничения прокси</h2>
        <p>Прокси - уникальное средство для настройки поведения объектов на самом низком уровне. Но они не идеальны,
        есть некоторые ограничения.</p>
        <h3>Встроенные объекты: внутренние слоты</h3>
        <p>Многие встроенные объекты, например <code>Map</code>, <code>Set</code>, <code>Date</code>, <code>Promise</code>
        и другие используют так называемые «внутренние слоты».</p>
        <p>Это как свойства, но только для внутреннего использования в самой спецификации. Например, <code>Map</code>
        хранит элементы во внутреннем слоте <code>[[MapData]]</code>. Встроенные методы обращаются к слотам напрямую,
        не через <code>[[Get]]/[[Set]]</code>. Таким образом, прокси не может перехватить их.</p>
        <p>Почему это имеет значение? Они же все равно внутренние!</p>
        <p>Есть один нюанс. Есть встроенный объект проксируется, то в прокси не будет этих «внутренних слотов»,
        так что попытка вызвать на таком прокси внутренний метод приведет к ошибке.</p>
        <p>Пример:</p>
        <code>
            let map = new Map();<br>
            <br>
            let proxy = new Proxy(map, {});<br>
            <br>
            proxy.set('test', 1); // Будет ошибка
        </code>
        <p>Внутри себя объект типа <code>Map</code> хранит все данные во внутреннем слоте <code>[[MapData]]</code>.
        Прокси не имеет такого слота. Встроенный метод <code>Map.prototype.set</code> пытается получить доступ
        к своему внутреннему свойству <code>this.[[MapData]]</code>, но так как <code>this=proxy</code>, то не может
        его найти и завершается с ошибкой.</p>
        <p>К счастью, есть способ исправить это:</p>
        <code>
            let map = new Map();<br>
            <br>
            let proxy = new Proxy(map, {<br>
            &nbsp;&nbsp;get(target, prop, receiver) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;let value = Reflect.get(...arguments);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return typeof value === 'function' ? value.bind(target) : value;<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            proxy.set('test', 1);<br>
            alert(proxy.get('test')); // 1 (работает!)
        </code>
        <p>Сейчас все сработало, потому что <code>get</code> привязывает свойства-функции, такие как <code>map.set</code>,
        к оригинальному объекту <code>map</code>. Таким образом, когда реализация метода <code>set</code> попытается
        получить доступ к встроенному слоту <code>this.[[MapData]]</code>, то все пройдет благополучно.</p>

        <article class="note">
            <h2>Объект <code>Array</code> не использует внутренние слоты</h2>
            <p>Важным исключением является встроенный объект <code>Array</code>: он не использует внутренние слоты.
            Так сложилось исторически, ведь массивы были добавлены в язык очень давно.</p>
            <p>То есть описанная выше проблема не возникнет при проксировании массивов.</p>
        </article>

        <h3>Приватные поля</h3>
        <p>Нечто похожее происходит и с приватными полями классов.</p>
        <p>Например, метод <code>getName()</code> осуществляет доступ к приватному полю <code>#name</code>, после
        проксирования он перестает работать:</p>
        <code>
            class User {<br>
            &nbsp;&nbsp;#name = 'Гость';<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;getName() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return this.#name;<br>
            &nbsp;&nbsp;}<br>
            }<br>
            <br>
            let user = new User();<br>
            <br>
            user = new Proxy(user, {});<br>
            <br>
            alert(user.getName()); // Ошибка
        </code>
        <p>Причина все та же: приватные поля реализованы с использованием внутренних слотов. JavaScript не использует
        <code>[[Get]]]/[[Set]]</code> при доступе к ним.</p>
        <p>В вызове <code>getName()</code> значением <code>this</code> является проксированный <code>user</code>,
        в котором нет внутреннего слота с приватными полями.</p>
        <p>Решением, как и в предыдущем случае, является привязка контекста к методу:</p>
        <code>
            class User {<br>
            &nbsp;&nbsp;#name: 'Гость';<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;getName() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return this.#name;<br>
            &nbsp;&nbsp;}<br>
            }<br>
            <br>
            let user = new User();<br>
            <br>
            user = new Proxy(user, {<br>
            &nbsp;&nbsp;get(target, prop, receiver) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;let value = Reflect.get(...arguments);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return if typeof value === 'function' ? value.bind(target) : value;<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            alert(user.getName()); // Гость
        </code>
        <p>Однако, такое решение имеет ряд недостатков, о которых уже говорилось: методу передается оригинальный
        объект, который может быть передан куда-то еще, и это может поломать всю функциональность проксирования.</p>

        <h3>Прокси != оригинальный объект</h3>
        <p>Прокси и объект, который проксируется, являются двумя разными объектами. Это естественно, не правда ли?</p>
        <p>Если мы используем оригинальный объект как ключ, а затем проксируем его, то прокси не будет найден:</p>
        <code>
            let allUsers = new Set();<br>
            <br>
            class User {<br>
            &nbsp;&nbsp;constructor(name) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;allUsers.add(this);<br>
            &nbsp;&nbsp;}<br>
            }<br>
            <br>
            let user = new User('Вася');<br>
            <br>
            alert(allUsers.has(user)); // true<br>
            <br>
            user = new Proxy(user, {});<br>
            <br>
            alert(allUsers.has(user)); // false
        </code>
        <p>Как мы видим, после проксирования не получится найти объект <code>user</code> внутри множества
        <code>allUsers</code>, потому что прокси - это другой объект.</p>

        <article class="warning">
            <h2>Прокси не перехватывают проверку на строгое равенство <code>===</code></h2>
            <p>Прокси способны перехватывать много операторов, например <code>new</code> (ловушка <code>construct</code>),
            <code>in</code> (ловушка <code>has</code>), delete (ловушка <code>deleteProperty</code>) и так далее.</p>
            <p>Но нет способа перехватить проверку на строгое равенство. Объект строго равен только самому себе,
            и никаким другим значениям.</p>
            <p>Так что все операции и встроенный классы, которые используют строгую проверку объектов на равенство,
            отличат прокси от изначального объекта. Прозрачной замены в данном случае не произойдет.</p>
        </article>
    </article>

    <article>
        <h2>Отключаемые прокси</h2>
        <p><i>Отключаемый</i> (revocable) прокси - это прокси, который может быть отключен вызовом специальной функции.</p>
        <p>Допустим, у нас есть какой-то ресурс, и мы бы хотели иметь возможность закрыть к нему доступ в любой момент.</p>
        <p>Для того, чтобы решить поставленную задачу, мы можем использовать отключаемый прокси, без ловушек.
        Такой прокси будет передавать все операции на проксируемый объект, и у нас будет возможность в любой момент
        отключить это.</p>
        <p>Синтаксис:</p>
        <code>let {proxy, revoke} = Proxy.revocable(target, handler);</code>
        <p>Вызов возвращает объект с <code>proxy</code> и функцией <code>revoke</code>, которая отключает его.</p>
        <p>Вот пример:</p>
        <code>
            let object = {<br>
            &nbsp;&nbsp;data: 'Важные данные'<br>
            };<br>
            <br>
            let {proxy, revoke} = Proxy.revocable(object, {});<br>
            <br>
            // Передаем прокси куда-нибудь вместо оригинального объекта...<br>
            alert(proxy.data); // Важные данные<br>
            <br>
            // Позже в коде<br>
            revoke();<br>
            <br>
            // Прокси больше не работает (отключен)<br>
            alert(proxy.data); // Ошибка
        </code>
        <p>Вызов <code>revoke()</code> удаляет все внутренние ссылки на оригинальный объект из прокси, так что между
        ними больше нет связи, и оригинальный объект теперь может быть очищен сборщиком мусора.</p>
        <p>Мы можем хранить функцию <code>revoke</code> в <code>WeakMap</code>, чтобы легко найти ее по объекту прокси:</p>
        <code>
            let revokes = new WeakMap();<br>
            <br>
            let object = {<br>
            &nbsp;&nbsp;data: 'Важные данные'<br>
            };<br>
            <br>
            let {proxy, revoke} = Proxy.revocable(object, {});<br>
            <br>
            revokes.set(proxy, revoke);<br>
            <br>
            // Позже в коде<br>
            revoke = revokes.get(proxy);<br>
            revoke();<br>
            <br>
            alert(proxy.data); // Ошибка (прокси отключен)
        </code>
        <p>Преимущество такого подхода в том, что мы не должны таскать функцию <code>revoke</code> повсюду. Мы получаем
        ее при необходимости из <code>revokes</code> по объекту прокси.</p>
        <p>Мы использовали <code>WeakMap</code> вместо <code>Map</code>, чтобы не блокировать сборку мусора.
        Если прокси объект становится недостижимым (то есть на него больше нет ссылок), то <code>WeakMap</code>
        позволяет сборщику мусора удалить его из памяти вместе с соответствующей функцией <code>revoke</code>,
        которая в этом случае больше не нужна.</p>
    </article>

    <article>
        <h2>Ссылки</h2>
        <ul>
            <li>
                <p>Спецификация: <a target="_blank" href="https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots">Proxy</a>
                <a target="_blank" href="https://tc39.es/ecma262/#sec-reflection">Reflect</a>.</p>
            </li>
            <li>
                <p>MDN: <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>
                <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect</a>.</p>
            </li>
        </ul>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Прокси - это обертка вокруг объекта, которая «по умолчанию» перенаправляет операции над ней на объект,
        но имеет возможность перехватывать их.</p>
        <p>Проксировать можно любой объект, включая классы и функции.</p>
        <p>Синтаксис:</p>
        <code>
            let proxy = new Proxy(target, {<br>
            &nbsp;&nbsp;// Ловушки<br>
            };
        </code>
        <p>... Затем обычно используют прокси везде вместо оригинального объекта <code>target</code>. Прокси не имеет
        собственных свойств или методов. Он просто перехватывает операцию, если имеется соответствующая ловушка,
        а иначе перенаправляет ее сразу на объект <code>target</code>.</p>
        <p>Мы можем перехватывать:</p>
        <ul>
            <li>
                <p>Чтение (<code>get</code>), запись (<code>set</code>), удаление (<code>deleteProperty</code>)
                свойства (даже не существующего).</p>
            </li>
            <li>
                <p>Вызов функции (<code>apply</code>).</p>
            </li>
            <li>
                <p>Оператор <code>new</code> (ловушка <code>construct</code>).</p>
            </li>
            <li>
                <p>И многие другие операции (полный список приведен в начале главы, а также в документации).</p>
            </li>
        </ul>
        <p>Это позволяет нам создавать «виртуальные» свойства и методы, реализовывать значения по умолчанию,
        наблюдаемые объекты, функции-декораторы и многое другое.</p>
        <p>Мы также можем оборачивать один и тот же объект много раз в разные прокси, добавляя ему различные
        аспекты функциональности.</p>
        <p><code>Reflect</code> API создано как дополнение к <code>Proxy</code>. Для любой ловушки из <code>Proxy</code>
        существует метод в <code>Reflect</code> с такими же аргументами. Нам следует использовать его, если нужно
        перенаправить вызов на оригинальный объект.</p>
        <p>Прокси имеют некоторые ограничения:</p>
        <ul>
            <li>
                <p>Встроенные объекты используют так называемые «внутренние слоты», доступ к которым нельзя проксировать.
                Однако, ранее в этой главе был показан один способ, как обойти это ограничение.</p>
            </li>
            <li>
                <p>То же самое можно сказать и о приватных полях классов, так как они реализованы на основе слотов.
                То есть вызовы проксированных методов должны иметь оригинальный объект в качестве <code>this</code>,
                чтобы получить к ним доступ.</p>
            </li>
            <li>
                <p>Проверка объектов на строгое равенство <code>===</code> не может быть перехвачена.</p>
            </li>
            <li>
                <p>Производительность: конкретные показатели зависят от интерпретатора, но в целом получение свойства
                с помощью простейшего прокси занимает в несколько раз больше времени. В реальности это имеет значение
                только для некоторых «особо нагруженных» объектов.</p>
            </li>
        </ul>
    </article>
</body>
</html>

<script src="script.js"></script>