<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Eval: выполнение строки кода</title>
    <link href="../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Eval: выполнение строки кода</h2>
        <p>Встроенная функция <code>eval</code> позволяет выполнять строку кода.</p>
        <p>Синтаксис:</p>
        <code>let result = eval(code);</code>
        <p>Например:</p>
        <code>
            let code = 'alert("Привет")';
            eval(code); // Привет
        </code>
        <p>Строка кода может быть большой, содержать переводы строк, объявления функций, переменные и т.п.</p>
        <p>Результатом <code>eval</code> будет результат выполнения последней инструкции.</p>
        <p>Например:</p>
        <code>
            let value = eval('1+1');<br>
            alert(value); // 2
        </code>
        <br>
        <code>
            let value = eval('let i = 0; ++i');<br>
            alert(value);
        </code>
        <p>Код в <code>eval</code> выполняется в текущем лексическом окружении, поэтому ему доступным внешние переменные:</p>
        <code>
            let a = 1;<br>
            <br>
            function f() {<br>
            &nbsp;&nbsp;let a = 2;<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;eval('alert(a)'); // 2<br>
            }<br>
            <br>
            f();
        </code>
        <p>Значения внешних переменных можно изменять:</p>
        <code>
            let x = 5;<br>
            eval('x = 10');<br>
            alert(x); // 10, значение изменено
        </code>
        <p>В строгом режиме у <code>eval</code> имеется свое лексическое окружение. Поэтому функции и переменные,
        объявленные внутри <code>eval</code>, нельзя увидеть снаружи:</p>
        <code>
            eval('let x = 5; function f() {}');<br>
            <br>
            alert(typeof x); // undefined (нет такой переменной)<br>
            // функция f тоже невидима
        </code>
        <p>Без <code>use strict</code> у <code>eval</code> не будет отдельного лексического окружения, поэтому
        <code>x</code> и <code>f</code> будут видны из внешнего кода.</p>
    </article>

    <article>
        <h2>Использование «eval»</h2>
        <p>В современной разработке на JavaScript <code>eval</code> используется весьма редко. Есть даже известное
        выражение - «eval is evil» («eval - это зло»).</p>
        <p>Причина такого отношения достаточно проста: давным-давно JavaScript был не очень развитым языком, и многие
        вещи можно было сделать только с помощью <code>eval</code>. Но та эпоха закончилась более десяти лет назад.</p>
        <p>На данный момент нет никаких причин, чтобы продолжать использовать <code>eval</code>. Если кто-то все еще
        делает это, то очень вероятно, что они легко смогут заменить <code>eval</code> более современными конструкциями
        или JavaScript-модулями.</p>
        <p>Пожалуйста, имейте в виду, что код в <code>eval</code> способен получать доступ к внешним переменным, и это
        может иметь побочные эффекты.</p>
        <p>Минификаторы кода (инструменты, используемые для сжатия JS-кода перед тем, как отправить его конечным пользователям)
        заменяют локальные переменные на другие с более короткими именами для оптимизации. Обычно это безопасная манипуляция,
        но не тогда, когда в коде используется <code>eval</code>, так как код из <code>eval</code> может изменять значения
        локальных переменных. Поэтому минификаторы не трогают имена переменных, которые могут быть доступны из <code>eval</code>.
        Это ухудшает степень сжатия кода.</p>
        <p>Использование внутри <code>eval</code> локальных переменных из внешнего кода считается плохим решением, так как
        это усложняет задачу по поддержке такого кода.</p>
        <p>Существует два пути, как гарантированно избежать подобных проблем.</p>
        <p><b>Если код внутри <code>eval</code> не использует внешние переменные, то вызывайте его так -
        <code>window.eval(...):</code></b></p>
        <p>В этом случае код выполняется в глобальной области видимости:</p>
        <code>
            let x = 1;<br>
            {<br>
            &nbsp;&nbsp;let x = 5;<br>
            &nbsp;&nbsp;window.eval('alert(x)'); // 1 (глобальная переменная)<br>
            }
        </code>
        <p><b>Если коду внутри <code>eval</code> нужны локальные переменные, поменяйте <code>eval</code> на
        <code>new Function</code> и передавайте необходимые данные как аргументы:</b></p>
        <code>
            let f = new Function('a', 'alert(a)');<br>
            <br>
            f(a); // 5
        </code>
        <p>Конструкция <code>new Function</code> создает функцию из строки в глобальной области видимости. Так что
        локальные переменные для нее невидимы, но всегда можно передать их как аргументы. Получается очень аккуратный
        код, как в примере выше.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Вызов <code>eval(code)</code> выполняет строку кода и возвращает результат последней инструкции.</p>
        <ul>
            <li>
                <p>Это редко используется в современном JavaScript, так как в этом обычно нет необходимости.</p>
            </li>
            <li>
                <p>Возможен доступ к внешним локальным переменным. Это считается плохой практикой.</p>
            </li>
            <li>
                <p>Чтобы выполнить строку кода с помощью <code>eval</code> в глобальной области видимости,
                используйте <code>window.eval(code)</code>.</p>
            </li>
            <li>
                <p>Или же, если ваш код нуждается в каких-то данных из внешней области видимости, то используйте
                <code>new Function</code>, передав эти данные в качестве аргументов.</p>
            </li>
        </ul>
    </article>
</body>
</html>

<script src="script.js"></script>