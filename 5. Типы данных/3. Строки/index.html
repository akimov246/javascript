<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Строки</title>
    <link href="../../style.css" type="text/css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Строки</h2>
        <p>В JavaScript любые текстовые данные являются строками.</p>
        <p>Внутренний формат для строк - всегда UTF-16, вне зависимости от кодировки страницы.</p>
    </article>

    <article>
        <h2>Кавычки</h2>
        <p>В JavaScript есть различные типы кавычек.</p>
        <p>Строку можно создать с помощью одинарных, двойных либо обратных кавычек.</p>
        <p>Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, то в такую строку
        мы сможем вставлять произвольные выражения, обернув их <code>${...}</code>.</p>
        <p>Еще одна преимущество обратных кавычек - они могут занимать более одной строки.</p>
        <p>Обратные кавыки также позволяют задавать «шаблонную функцию» перед первой обратной кавычкой. Используемый синтаксис
        <code>func`string`</code>. Автоматически вызываемая функция <code>func</code> получает строку и встроенные в нее выражения
        и может их обработать.</p>
    </article>

    <article>
        <h2>Спецсимволы</h2>
        <p>Многострочные строки также можно создавать с помощью одинарных и двойных кавычек, используя так называемый
        «символ перевода строки», который записывается как <code>\n</code>.</p>
        <p>Есть и другие, реже используемые спецсимволы:</p>
        <table>
            <thead>
                <tr>
                    <th>Символ</th>
                    <th>Описание</th>
                </tr>
            </thead>
            <tr>
                <td>
                    <code>\n</code>
                </td>
                <td>
                    Перевод строки
                </td>
            </tr>
            <tr>
                <td>
                    <code>\'</code>, <code>\"</code>, <code>\`</code>
                </td>
                <td>
                    Кавычки
                </td>
            </tr>
            <tr>
                <td>
                    <code>\\</code>
                </td>
                <td>Обратный слеш</td>
            </tr>
            <tr>
                <td><code>\t</code></td>
                <td>Знак табуляции</td>
            </tr>
            <tr>
                <td><code>\b</code>, <code>\f</code>, <code>\v</code></td>
                <td>Backspace, From Feed и Vertical Tab - оставлены для обратной совместимости, сейчас не используются.</td>
            </tr>
        </table>
        <p>Как вы можете видеть, все спецсимволы начинаются с обратного слеша, <code>\</code> - так называемого «символа
        экранирования».</p>
        <p>Разумеется, требование экранировать относится только к таким же кавычкам, как те, в которые заключена строка.
        Так что мы можем применить и более элегантное решение, использовав для этой строки двойные или обратные кавычки.</p>
        <p>Заметим, что обратный слеш <code>\</code> служит лишь для корректного прочтения строки интерпретатором, но он
        не записывается в строку после ее прочтения. Когда строка сохраняется в оперативную память, в нее не добавляется символ
        <code>\</code>.</p>
    </article>

    <article>
        <h2>Длина строки</h2>
        <p>Свойство <code>length</code> содержит длину строки:</p>
        <code>alert('My\n'.length); // 3</code>
        <p>Обратите внимание, <code>\n</code> - это один спецсимвол, поэтому тут все правильно: длина строки <code>3</code>.</p>

        <article class="warning">
            <h2><code>length</code> - это свойство</h2>
            <p>Бывает так, что люди с практикой в других языках случайно пытаются вызвать его, добавляя круглые скобки:
            они пишут <code>str.length()</code> вместо <code>str.length</code>. Это не работает.</p>
            <p>Так как <code>str.length</code> - это числовое свойство, а не функция, добавлять скобки не нужно.</p>
        </article>
    </article>

    <article>
        <h2>Доступ к символам</h2>
        <p>Получить символ, который занимает позицию <code>pos</code>, можно с помощью квадратных скобок: <code>[pos]</code>.
        Также можно использовать метод <code>str.at(pos)</code>. Первый символ занимает нулевую позицию.</p>
        <p>Преимущество метода <code>.at(pos)</code> заключается в том, что он допускает отрицательную позицию.
        Если <code>pos</code> - отрицательное число, то отсчет ведется с конца строки.</p>
        <p>Таким образом, <code>.at(-1)</code> означает последний символ, а <code>.at(-2)</code> - тот, что перед ним, и т.д.</p>
        <p>Квадратные скобки всегда возвращают <code>undefined</code> для отрицательных индексов.</p>
        <p>Также можно перебрать строку посимвольно, используя <code>for...of</code>:</p>
        <code>
            for (let char of 'Hello') {<br>
            &nbsp;&nbsp;alert(char);<br>
            }
        </code>
    </article>

    <article>
        <h2>Строки неизменяемы</h2>
        <p>Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка
        создана - она такая навсегда.</p>
        <p>Можно создать новую строку и записать ее в ту же самую переменную вместо старой.</p>
    </article>

    <article>
        <h2>Изменение регистра</h2>
        <p>Методы <code>toLowerCase()</code> и <code>toUpperCase()</code> меняют регистр символов:</p>
        <code>alert('Interface'.toLowerCase()); // interface</code><br>
        <code>alert('Interface'.toUpperCase()); // INTERFACE</code>
        <p>Если мы хотим перевести в нижний регистр какой-то конкретный символ:</p>
        <code>alert('Interface'[0].toLowerCase()); // 'i'</code>
    </article>

    <article>
        <h2>Поиск подстроки</h2>
        <p>Существует несколько способов поиска подстроки.</p>
        <p><b>str.indexOf</b></p>
        <p>Первый метод - <code>str.indexOf(substr, pos)</code>.</p>
        <p>Он ищет подстроку <code>substr</code> в строке <code>str</code>, начиная с позиции <code>pos</code>, и возвращает
        позицию, на которой располагается совпадение, либо <code>-1</code> при отсутствии совпадений.</p>
        <p>Необязательный второй аргумент позволяет начать поиск с определенно позиции.</p>
        <p>Чтобы найти все вхождения подстроки, нужно запустить <code>indexOf</code> в цикле. Каждый раз, получив очередную
        позицию, начинаем новый поиск со следующей:</p>
        <code>
            let str = 'Ослик Иа-Иа посмотрел на виадук';<br>
            <br>
            let target = 'Иа';<br>
            <br>
            let pos = 0;<br>
            while (true) {<br>
            &nbsp;&nbsp;let foundPos = str.indexOf(target, pos);<br>
            &nbsp;&nbsp;if (foundPos === - 1) break;<br>
            <br>
            &nbsp;&nbsp;alert(`Найдено тут: ${foundPos}`);<br>
            &nbsp;&nbsp;pos = foundPos + 1;<br>
            }
        </code>

        <article class="note">
            <h2><code>str.lastIndexOf(substr, position)</code></h2>
            <p>Также есть похожий метод <code>str.lastIndexOf(substr, position), который ищет с конца строки к ее началу.</code></p>
            <p>Он используется тогда, когда нужно получить самое последнее вхождение: перед концом строки или начинающееся
            до (включительно) определенной позиции.</p>
        </article>
    </article>

    <article>
        <h2>Трюк с побитовым НЕ</h2>
        <p>Существует старый трюк с использованием побитового оператора НЕ - <code>~</code>. Он преобразует число в 32-разрядное
        целое со знаком. Дробная часть, в случае, если она присутствует, отбрасывается. Затем всем биты числа инвертируются.</p>
        <p>На практике это означает простую вещь: для 32-разрядных целых чисел значение <code>~n</code> равно <code>-(n + 1)</code>.</p>
        <p>Таким образом, <code>~n</code> равняется 0 только при <code>n == -1</code> (для любого <code>n</code>, входящего в
        32-разрядные целые числа со знаком).</p>
        <p>Соответственно, прохождение проверки <code>if (~str.indexOf('...'))</code> означает, что результат <code>indexOf</code>
        отличен от <code>-1</code>, совпадение есть.</p>
        <p>Это иногда применяют, чтобы сделать проверку <code>indexOf</code> компактнее.</p>
        <p>Обычно использовать возможности языка каким-либо неочевидным образом не рекомендуется, но этот трюк широко используется
        в старом коде, поэтому его важно понимать.</p>
        <p>Просто запомните: <code>if (~str.indexOf(...))</code> означает «если найдено».</p>
        <p>Впрочем, если быть точнее, из-за того, что большие числа обрезаются до 32 битов оператором <code>~</code>,
        существуют другие числа, для которых результат тоже будет <code>0</code>, самое маленькое из которых -
        <code>~4294967295=0</code>. Поэтому такая проверка будет правильно работать только для строк меньшей длины.</p>
        <p>На данный момент такой трюк можно встретить только в старом коде, потому что в новом он просто не нужен: есть
        метод <code>.includes</code>.</p>
    </article>

    <article>
        <h2>includes, startsWith, endsWith</h2>
        <p>Более современный метод <code>str.includes(substr, pos)</code> возвращает <code>true</code>, если в строке
        <code>str</code> есть подстрока <code>substr</code>, либо <code>false</code>, если нет.</p>
        <p>Это правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна.</p>
        <p>Необязательный второй аргумент <code>str.includes</code> позволяет начать поиск с определенной позиции.</p>
        <p>Методы <code>str.startsWith</code> и <code>str.endsWith</code> проверяют, соответственно, начинается ли и
        заканчивается ли строка определенной строкой.</p>
    </article>

    <article>
        <h2>Получение подстроки</h2>
        <p>В JavaScript есть 3 метода для получения подстроки: <code>substring</code>, <code>substr</code> и <code>slice</code>.</p>
        <ul>
            <li>
                <p><code>str.slice(start [, end])</code></p>
                <p>Возвращает часть строки от <code>start</code> до (не включая) <code>end</code>.</p>
                <p>Если аргумент <code>end</code> отсутствует, <code>slice</code> возвращает символы до конца строки.</p>
                <p>Также для <code>start/end</code> можно задавать отрицательные значения. Это означает, что позиция определена
                как заданное количество символов с <i>конца строки</i>.</p>
            </li>
            <li>
                <p><code>str.substring(start [, end])</code></p>
                <p>Возвращает часть строки <i>между</i> <code>start</code> и <code>end</code> (не включая) <code>end</code>.</p>
                <p>Это почти то же, что и <code>slice</code>, но можно задавать <code>start</code> больше <code>end</code>.</p>
                <p>Если <code>start</code> больше <code>end</code>, то метод <code>substring</code> сработает так, как если бы
                аргументы были поменяны местами.</p>
                <p>Отрицательные значения <code>substring</code>, в отличие от <code>slice</code>, не поддерживает, они
                интерпретируются как <code>0</code>.</p>
            </li>
            <li>
                <p><code>str.substr(start [, length])</code></p>
                <p>Возвращает часть строки от <code>start</code> длины <code>length</code>.</p>
                <p>В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции.</p>
                <p>Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца.</p>
                <p>Этот метод находится в <b>Annex B</b> спецификации языка. Это означает, что его должны поддерживать
                только браузерные движки JavaScript, и использовать его не рекомендуется. Но на практике он поддерживается
                везде.</p>
            </li>
        </ul>
        <table>
            <thead>
                <tr>
                    <td>Метод</td>
                    <td>Выбирает...</td>
                    <td>Отрицательные значения</td>
                </tr>
            </thead>
            <tr>
                <td><code>slice(start, end)</code></td>
                <td>от <code>start</code> до <code>end</code> (не включая <code>end</code>)</td>
                <td>Можно передавать отрицательные значения</td>
            </tr>
            <tr>
                <td><code>substring(start, end)</code></td>
                <td>Между <code>start</code> и <code>end</code> (не включая <code>end</code>)</td>
                <td>Отрицательные значения равнозначны <code>0</code></td>
            </tr>
            <tr>
                <td><code>substr(start, length)</code></td>
                <td><code>length</code> символов, начиная от <code>start</code></td>
                <td>Значение <code>start</code> может быть отрицательным</td>
            </tr>
        </table>

        <article class="note">
            <h2>Какой метод выбрать?</h2>
            <p>Все эти методы эффективно выполняют задачу. Формально у метода <code>substr</code> есть небольшой недостаток:
            он описан не в собственно спецификации JavaScript, а в приложении к ней - Annex B. Это приложение описывает возможности
            языка для использования в браузерах, существующие в основном по историческим причинам. Таким образом, в другом
            окружении, отличном от браузера, он может не поддерживаться. Однако на практике он работает везде.</p>
            <p>Из двух других вариантов, <code>slice</code> более гибок, он поддерживает отрицательные аргументы, и его короче писать.
            Так что, в принципе, можно запомнить только его.</p>
        </article>
    </article>

    <article>
        <h2>Сравнение строк</h2>
        <p>Как мы знаем, строки сравниваются посимвольно в алфавитном порядке.</p>
        <p>Тем не менее есть некоторые нюансы:</p>
        <ol>
            <li>
                <p>Строчные буквы больше заглавных:</p>
                <code>alert('a' > 'Z'); // true</code>
            </li>
            <li>
                <p>Буквы, имеющие диакритические знаки, идут «не по порядку»:</p>
                <code>alert('Österreich' > 'Zealand'); // true</code>
                <p>Это может привести к своеобразным результатам при сортировке названий стран: нормально было бы ожидать,
                что <code>Zealand</code> будет после <code>Österreich</code> в списке.</p>
            </li>
        </ol>
        <p>Чтобы разобраться что происходит, давайте ознакомимся с внутренним представлением строк в JavaScript.</p>
        <p>Строки кодируются в UTF-16. Таким образом, у любого символа есть соответствующий код. Есть специальные методы,
        позволяющие получить символ по его коду и наоборот.</p>
        <ul>
            <li>
                <p><code>str.codePointAt(pos)</code></p>
                <p>Возвращает код символа, находящегося на позиции <code>pos</code>.</p>
            </li>
            <li>
                <p><code>String.fromCodePoint(code)</code></p>
                <p>Создает символ по его коду <code>code</code>.</p>
            </li>
        </ul>
        <p>Символы сравниваются по их кодам. Больший код - больший символ.</p>
        <ul>
            <li>Все строчные буквы идут после заглавных, так как их коды больше.</li>
            <li>Некоторые буквы, такие как <code>Ö</code>, вообще находятся вне основного алфавита. У этой буквы код больше,
            чем у любой буквы от <code>a</code> до <code>z</code>.</li>
        </ul>
    </article>

    <article>
        <h2>Правильное сравнение</h2>
        <p>«Правильный» алгоритм сравнения строк сложнее, чем может показаться, так как разные языки используют разные
        алфавиты.</p>
        <p>Поэтому браузеру нужно знать, какой язык использовать для сравнения.</p>
        <p>К счастью, все современные браузеры поддерживают стандарт ECMA 402, обеспечивающий правильное сравнение строк
        на разных языках с учетом их правил.</p>
        <p>Для этого есть соответствующий метод.</p>
        <p>Вызов <code>str.localeCompare(str2)</code> возвращает число, которое показывает, какая строка больше в соответствии
        с правилами языка:</p>
        <ul>
            <li>Отрицательное число, если <code>str</code> меньше <code>str2</code>.</li>
            <li>Положительное число, если <code>str</code> больше <code>str2</code>.</li>
            <li><code>0</code>, если строки равны.</li>
        </ul>
        <p>Например:</p>
        <code>alert('Österreich'.localeCompare('Zealand')); // -1</code>
        <p>У этого метода есть два дополнительных аргумента, которые указаны в
        <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare" target="_blank">документации</a>.
        Первый позволяет указать язык (по умолчанию берется из окружения) - от него зависит порядок букв. Второй - определить
        дополнительные правила, такие как чувствительность к регистру, а также следует ли учитывать различия между
        <code>'a'</code> и <code>'á'</code>.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <ul>
            <li>Есть три типа кавычек. Строки, использующие обратные кавычки, могут занимать более одной строки в коде
            и включать выражения <code>${...}</code>.</li>
            <li>Строки в JavaScript кодируются в UTF-16.</li>
            <li>Есть специальные символы, такие как разрыв строки <code>\n</code>.</li>
            <li>Для получения символа используйте <code>[]</code> или метод <code>at()</code>.</li>
            <li>Для получения подстроки используйте <code>slice</code>, <code>substring</code> или <code>substr</code>.</li>
            <li>Для того чтобы перевести строку в нижний или верхний регистр, используйте <code>toLowerCase()/toUpperCase()</code>.</li>
            <li>Для поиска подстроки используйте <code>indexOf(substr, pos)</code> или <code>includes/startsWith/endsWith</code>,
            когда надо только проверить, есть ли вхождение.</li>
            <li>Чтобы сравнить строки с учетом правил языка, используйте <code>localeCompare()</code>.</li>
        </ul>
        <p>Строки также имеют еще кое-какие полезные методы:</p>
        <ul>
            <li><code>str.trim()</code> - убирает пробелы в начале и конце строки.</li>
            <li><code>str.repeat(n)</code> - повторяет строку <code>n</code> раз.</li>
            <li>... И другие, которые вы можете найти в <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank">справочнике</a>.</li>
        </ul>
    </article>
</body>
</html>

<script src="script.js"></script>