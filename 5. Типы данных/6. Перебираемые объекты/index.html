<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Перебираемые объекты</title>
    <link href="../../style.css" type="text/css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Перебираемые объекты</h2>
        <p><i>Перебираемые</i> (или <i>итерируемые</i>) объекты - это обобщение массивов. Концепция, которая позволяет
        использовать любой объект в цикле <code>for...of</code>.</p>
        <p>Конечно же, сами массивы являются перебираемыми объектами. Но есть и много других встроенных перебираемых
        объектов, например, строки.</p>
        <p>Если объект не является массивом, но представляет из себя коллекцию каких-то элементов (список, набор), то удобно
        использовать цикл <code>for...of</code> для их перебора.</p>
    </article>

    <article>
        <h2>Symbol.iterator</h2>
        <p>Мы легко поймем принцип устройства перебираемых объектов, создав один из них.</p>
        <p>Например, у нас есть объект. Это не массив, но он выглядит подходящим для <code>for...of</code>.</p>
        <p>Например, объект <code>range</code>, который представляет собой диапазон чисел:</p>
        <code>
            let range = {<br>
            &nbsp;&nbsp;from = 1,<br>
            &nbsp;&nbsp;to: 5<br>
            };
        </code>
        <p>Чтобы сделать <code>range</code> итерируемым (и позволить <code>for...of</code> работать с ним), нам нужно добавить
        в объект метод с именем <code>Symbol.iterator</code> (специальный встроенный <code>Symbol</code>, созданный
        как раз для этого).</p>
        <ol>
            <li>Когда цикл <code>for...of</code> запускается, он вызывает этот метод один раз (или выдает ошибку, если метод
            не найден). Этот метод должен вернуть <i>итератор</i> - объект с методом <code>next</code>.</li>
            <li>Дальше <code>for...of</code> работает <i>только с этим возвращенным объектом</i>.</li>
            <li>Когда <code>for...of</code> хочет получить следующее значение, он вызывает метод <code>next()</code>
            этого объекта.</li>
            <li>Результат метода <code>next()</code> должен иметь вид <code>{done: Boolean, value: any}</code>, где
            <code>done=true</code> обозначает, что цикл завершен, в противном случае <code>value</code> содержит
            очередное значение.</li>
        </ol>
        <p>Вот полная реализация <code>range</code> с пояснениями:</p>
        <code>
            let range = {<br>
            &nbsp;&nbsp;from = 1,<br>
            &nbsp;&nbsp;to: 5<br>
            };<br>
            <br>
            // 1. вызов for...of сначала вызывает эту функцию<br>
            range[Symbol.iterator] = function() {<br>
            &nbsp;&nbsp;// ... она возвращает объект итератора<br>
            &nbsp;&nbsp;// 2. Далее, for...of работает только с этим итератором,<br>
            &nbsp;&nbsp;// запрашивая у него новые значения<br>
            &nbsp;&nbsp;return {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;current: this.from,<br>
            &nbsp;&nbsp;&nbsp;&nbsp;last: this.to,<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;// 3. next() вызывается на каждой итерации цикла for...of<br>
            &nbsp;&nbsp;&nbsp;&nbsp;next() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;// 4. он должен вернуть значение в виде объекта {done: Boolean, value: any}<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (this.current <= this.last) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {done: false, value: this.current++};
            &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {done: true};<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;}<br>
            };
        </code>
        <p>Обратите внимание на ключевую особенность итераторов: разделение ответственности.</p>
        <ul>
            <li>У самого <code>range</code> нет метода <code>next()</code>.</li>
            <li>Вместо этого другой объект, так называемый «итератор», создается вызовом <code>range[Symbol.iterator]()</code>,
            и именно его <code>next()</code> генерирует значения.</li>
        </ul>
        <p>Таким образом, объект итератор отделен от самого итерируемого объекта.</p>
        <p>Технически мы можем объединить их и использовать сам <code>range</code> как итератор, чтобы упростить код.</p>
        <p>Например, вот так:</p>
        <code>
            let range = {<br>
            &nbsp;&nbsp;from: 1,<br>
            &nbsp;&nbsp;to: 5,<br>
            <br>
            &nbsp;&nbsp;[Symbol.iterator]() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;this.current = from;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;resurn this;<br>
            &nbsp;&nbsp;},<br>
            <br>
            &nbsp;&nbsp;next() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (this.current <= this.to) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {done: false, value: this.current++};<br>
            &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {done: true};<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;}<br>
            };
        </code>
        <p>Теперь <code>range[Symbol.iterator]()</code> возвращает сам объект <code>range</code>: у него есть необходимый
        метод <code>next()</code>, и он запоминает текущее состояние итерации в <code>this.current</code>. Короче?
        Да. Иногда такой способ тоже хорош.</p>
        <p>Недостаток такого подхода в том, что теперь мы не можем использовать этот объект в двух параллельных циклах
        <code>for...of</code>: у них будет общее текущее состояние итерации, потому что теперь существует лишь один
        итератор - сам объект. Но необходимость в двух циклах <code>for...of</code>, выполняемых одновременно, возникает редко,
        даже при наличии асинхронных операций.</p>

        <article class="note">
            <h2>Бесконечные итераторы</h2>
            <p>Можно сделать бесконечный итератор. Например, <code>range</code> будет бесконечным при
            <code>range.to = Infinity</code>. Или мы можем создать итерируемый объект, который генерирует бесконечную
            последовательность псевдослучайных чисел. Это бывает полезно.</p>
            <p>Метод <code>next</code> не имеет ограничений, он может возвращать все новые и новые значения, это нормально.</p>
            <p>Конечно де, цикл <code>for...of</code> с таким итерируемым объектом будет бесконечным. Но мы всегда можем прервать
            его, используя <code>break</code>.</p>
        </article>
    </article>

    <article>
        <h2>Строка - перебираемый объект</h2>
        <p>Среди встроенных перебираемых объектов наиболее широко используются массивы и строки.</p>
        <p>Для строки <code>for...of</code> перебирает символы.</p>
    </article>

    <article>
        <h2>Явный вызов итератора</h2>
        <p>Чтобы понять устройство итератора чуть глубже, давайте посмотрим, как их использовать явно.</p>
        <p>Мы будем перебирать строку точно так же, как цикл <code>for...of</code>, но вручную, прямыми вызовами.
        Нижеприведенный код получает строковый итератор и берет из него значения:</p>
        <code>
            let str = 'Hello';<br>
            <br>
            let iterator = str[Symbol.iterator]();<br>
            <br>
            while (true) {<br>
            &nbsp;&nbsp;let result = iterator.next();<br>
            &nbsp;&nbsp;if (result.done) break;<br>
            &nbsp;&nbsp;alert(result.value);<br>
            }
        </code>
        <p>Такое редко бывает необходимо, но это дает нам больше контроля над процессом, чем <code>for...of</code>.
        Например, мы можем разбить процесс итерации на части: перебрать немного элементов, затем остановиться, сделать что-то
        еще и потом продолжить.</p>
    </article>

    <article>
        <h2>Итерируемые объекты и псевдомассивы</h2>
        <p>Есть два официальных термина, которые очень похожи, но в то же время сильно различаются. Поэтому убедитесь,
        что вы как следует поняли их, чтобы избежать путаницы.</p>
        <ul>
            <li>
                <i>Итерируемые объекты</i> - это объекты, которые реализуют метод <code>Symbol.iterator</code>.
            </li>
            <li><i>Псевдомассивы</i> - это объекты, у которых есть индексы и свойство <code>length</code>, то есть,
            они выглядят как массивы.</li>
        </ul>
        <p>При использовании JavaScript в браузере или других окружениях мы можем встретить объекты, которые являются
        итерируемыми или псевдомассивами, или и тем, и другим.</p>
        <p>Например, строки итерируемы (для них работает <code>for...of</code>) и являются псевдомассивами (они индексированы
        и есть <code>length</code>).</p>
        <p>Но итерируемый объект может быть не псевдомассивом. И наоборот: псевдомассив может не быть итерируемым.</p>
        <p>Например, объект <code>range</code> из примера выше - итерируемый, но не является псевдомассивом, потому что у
        него нет индексированных свойств и <code>length</code>.</p>
        <p>А вот объект, который является псевдомасиивом, но его нельзя итерировать:</p>
        <code>
            let arrayLike = {<br>
            &nbsp;&nbsp;0: 'Hello',<br>
            &nbsp;&nbsp;1: 'World',<br>
            &nbsp;&nbsp;length: 2<br>
            };<br>
            // Symbol.iterator отсутствует
        </code>
        <p>Что у них общего? И итерируемые объекты, и псевдомассивы - это обычно <i>не массивы</i>, у них нет методов
        <code>push</code>, <code>pop</code> и т.д. Довольно неудобно, если у нас есть такой объект и мы хотим работать с ним
        как с массивом. Например, мы хотели бы работать с <code>range</code>, используя методы массивов. Как этого достичь?</p>
    </article>

    <article>
        <h2>Array.from</h2>
        <p>Есть универсальный метод <code>Array.from</code>, который принимает итерируемый объект или псевдомассив и делает
        из него «настоящий» <code>Array</code>. После этого мы уже можем использовать методы массивов.</p>
        <p><code>Array.from</code> проверяет является ли принимаемый объект итерируемым объектом или псевдомассивом,
        затем создает новый массив и копирует туда все элементы.</p>
        <p>Полный синтаксис <code>Array.from</code> позволяет указать необязательную «трансформирующую» функцию:</p>
        <code>Array.from(obj[, mapFn, thisArg])</code>
        <p>Необязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед добавлением
        в массив, а <code>thisArg</code> позволяет установить <code>this</code> для этой функции.</p>
        <p>В отличие от <code>split</code>, метод <code>Array.from</code> в работе опирается на итерируемость строки,
        и поэтому, как и <code>for...of</code>, он корректно работает с суррогатными парами.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Объекты, которые можно использовать в цикле <code>for...of</code>, называются <i>итерируемыми</i>.</p>
        <ul>
            <li>
                <p>Технически итерируемые объекты должны иметь метод <code>Symbol.iterator</code>.</p>
                <ul>
                    <li>Результат вызова <code>obj[Symbol.iterator]</code> называется <i>итератором</i>. Он управляет
                    процессом итерации.</li>
                    <li>Итератор должен иметь метод <code>next()</code>, который возвращает <code>{done: Boolean, value: any}</code>,
                    где <code>done: true</code> сигнализирует об окончании процесса итерации, в противном случае
                    <code>value</code> - следующее значение.</li>
                </ul>
            </li>
            <li>Метод <code>Symbol.iterator</code> автоматически вызывается циклом <code>for...of</code>, но можно вызвать его
            и напрямую.</li>
            <li>Встроенные итерируемые объекты, такие как строки или массивы, также реализуют метод <code>Symbol.iterator</code>.</li>
            <li>Строковый итератор знает про суррогатные пары.</li>
        </ul>
        <p>Объекты, имеющие индексированные свойства и <code>length</code>, называются <i>псевдомассивами</i>. Они также
        могут иметь другие свойства и методы, но у них нет встроенных методов массивов.</p>
        <p>Если мы заглянем в спецификацию, мы увидим, что большинство встроенных методов рассчитывают на то, что они будут
        работать с итерируемыми объектами или псевдомассивами вместо «настоящих» массивов, потому что эти объекты более абстрактны.</p>
        <p><code>Array.from(obj[, mapFn, thisArg])</code> создает настоящий <code>Array</code> из итерируемого объекта или
        псевдомассива <code>obj</code>, и затем мы можем применять к нему методы массивов. Необязательные аргументы <code>mapFn</code>
        и <code>thisArg</code> позволяют применять функцию с задаваемым контекстом к каждому элементу.</p>
    </article>
</body>
</html>