<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Методы прототипов, объекты без свойства __proto__</title>
    <link href="../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Методы прототипов, объекты без свойства __proto__</h2>
        <p>Свойство <code>__proto__</code> считается устаревшим, и по стандарту оно должно поддерживаться только браузерами.</p>
        <p>Современные же методы это:</p>
        <ul>
            <li><code>Object.create(proto[, descriptors])</code> - создает пустой объект со свойством <code>[[Prototype]]</code>,
            указанным как <code>proto</code>, и необязательными дескрипторами свойств <code>descriptors</code>.</li>
            <li><code>Object.getPrototypeOf(obj)</code> - возвращает свойство <code>[[Prototype]]</code> объекта
            <code>obj</code>.</li>
            <li><code>Object.setPrototypeOf(obj, proto)</code> - устанавливает свойство <code>[[Prototype]]</code>
            объекта <code>obj</code> как <code>proto</code>.</li>
        </ul>
        <p>Эти методы нужно использовать вместо <code>__proto__</code>.</p>
        <p>Например:</p>
        <code>
            let animal = {<br>
            &nbsp;&nbsp;eats: true<br>
            };<br>
            <br>
            // Создаем новый объект с прототипом animal<br>
            let rabbit = Object.create(animal);<br>
            <br>
            alert(rabbit.eats); // true<br>
            <br>
            alert(Object.getPrototypeOf(rabbit) === animal); // true Получаем прототип объекта rabbit<br>
            <br>
            Object.setPrototypeOf(rabbit, {}); // Заменяем прототип объекта rabbit на {}
        </code>
        <p>У <code>Object.create</code> есть необязательный второй аргумент: дескрипторы свойств. Мы можем добавить
        дополнительной свойство новому объекту таким образом:</p>
        <code>
            let animal = {<br>
            &nbsp;&nbsp;eats: true<br>
            };<br>
            <br>
            let rabbit = Object.create(animal, {<br>
            &nbsp;&nbsp;jumps: {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;value: true<br>
            &nbsp;&nbsp;}<br>
            });<br>
            <br>
            alert(rabbit.jumps); // true
        </code>
        <p>Мы также можем использовать <code>Object.create</code> для «продвинутого» клонирования объекта, более мощного,
        чем копирование свойств в цикле <code>for...in</code>:</p>
        <code>
            // Клон obj с тем же прототипом (с поверхностным копированием свойств)<br>
            let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
        </code>
        <p>Такой вызов создает точную копию объекта <code>obj</code>, включая все свойства: перечисляемые и неперечисляемые,
        геттеры/сеттеры для свойств - и все это с правильным свойством <code>[[Prototype]]</code>.</p>
    </article>

    <article>
        <h2>Краткая история</h2>
        <p>Если перечислить все способы управления прототипом, то их будет много! И многие из них делают одно и то же!</p>
        <p>Почему так?</p>
        <p>В силу исторических причин.</p>
        <ul>
            <li>Свойство <code>prototype</code> функции-конструктора существует с совсем давних времен.</li>
            <li>Позднее, в 2012 году, в стандарте появился метод <code>Object.create</code>. Это давало возможность
            создавать объекты с указанным прототипом, но не позволяло устанавливать/получать его. Тогда браузеры
            реализовали нестандартный аксессор <code>__proto__</code>, который позволил устанавливать/получать
            прототип в любое время.</li>
            <li>Позднее, в 2015 году, в стандарт были добавлены <code>Object.setPrototypeOf</code> и
            <code>Object.getPrototypeOf</code>, заменяющие собой аксессор <code>__proto__</code>, который упоминается
            в Приложении Б стандарта, которое не обязательно к поддержке в небраузерных окружениях. При этом
            де-факто <code>__proto__</code> все еще поддерживается везде.</li>
        </ul>
        <p>В итоге сейчас у нас есть все эти способы для работы с прототипом.</p>
        <p>Почему же <code>__proto__</code> был заменен на функции <code>getPrototypeOf/setPrototypeOf</code>?</p>

        <article class="warning">
            <h2>Не меняйте <code>[[Prototype]]</code> существующих объектов, если важна скорость</h2>
            <p>Технически мы можем установить/получить <code>[[Prototype]]</code> в любое время. Но обычно мы
            устанавливаем прототип только раз во время создания объекта, а после не меняем: <code>rabbit</code>
            наследует от <code>animal</code>, и это не изменится.</p>
            <p>В JavaScript движки хорошо оптимизированы для этого. Изменение прототипа «на лету» с помощью
            <code>Object.setPrototypeOf</code> или <code>obj.__proto__=</code> - очень медленная операция, которая
            ломает внутренние оптимизации для операций доступа к свойствам объекта. Так что лучше избегайте этого
            кроме тех случаев, когда вы знаете, что делаете, или же когда скорость JavaScript для вас не имеет
            никакого значения.</p>
        </article>
    </article>

    <article>
        <h2>«Простейший» объект</h2>
        <p>Как мы знаем, объекты можно использовать как ассоциативные массивы для хранения пар ключ/значение.</p>
        <p>... Но если мы попробуем хранить <i>созданные пользователями</i> ключи (например, словари с пользовательским
        вводом), мы можем заметить интересный сбой: все ключи работают как ожидается, за исключением <code>__proto__</code>:</p>
        <p>Посмотрите на примере:</p>
        <code>
            let obj = {};<br>
            <br>
            let key = prompt('key?', '__proto__');<br>
            obj[key] = 'some value';<br>
            <br>
            alert(obj[key]); // [object Object], не 'some value'!
        </code>
        <p>Если пользователь введет <code>__proto__</code>, присвоение проигнорируется!</p>
        <p>И это не должно удивлять нас. Свойство <code>__proto__</code> особенное: оно должно быть либо объектом,
        либо <code>null</code>, а строка не может стать прототипом.</p>
        <p>Но мы не намеревались реализовать такое поведение, не так ли? Мы хотим хранить пары ключ/значение,
        и ключ с именем <code>__proto__</code> не был сохранен надлежащим образом. Так что это ошибка!</p>
        <p>Конкретно в этом примере последствия не так ужасны, но если мы присваиваем объектные значения,
        то прототип и в самом деле может быть изменен. В результате дальнейшее выполнение пойдет совершенно непредсказуемым
        образом.</p>
        <p>Что хуже всего - разработчики не задумываются о такой возможности совсем. Это делает такие ошибки сложными
        для отлавливания или даже превращает их в уязвимости, особенно когда JavaScript используется на сервере.</p>
        <p>Неожиданные вещи также могут случаться также при присвоении свойства <code>toString</code>, которое
        по умолчанию функция, и других свойств, которые тоже на самом деле являются встроенными методами.</p>
        <p>Как же избежать проблемы?</p>
        <p>Во-первых, мы можем переключиться на использование коллекции <code>Map</code>, и тогда все будет в порядке.</p>
        <p>Но и <code>Object</code> может также хорошо подойти, потому что создатели языка уже давно продумали решение
        проблемы.</p>
        <p>Свойство <code>__proto__</code> - не обычное, а аксессор, заданные в <code>Object.prototype</code>.</p>
        <p>Так что при чтении или установке <code>obj.__proto__</code> вызывается соответствующий геттер/сеттер
        из прототипа <code>obj</code>, и именно он устанавливает/получает свойство <code>[[Prototype]]</code>.</p>
        <p>Теперь, если мы хотим использовать объект, как ассоциативный массив, мы можем сделать это с помощью
        небольшого трюка:</p>
        <code>
            let obj = Object.create(null);<br>
            <br>
            let key = prompt('key?', '__proto__');<br>
            obj[key] = 'some value';<br>
            <br>
            alert(obj[key]); // 'some value'
        </code>
        <p><code>Object.create(null)</code> создает пустой объект без прототипа (<code>[[Prototype]]</code> будет
        <code>null</code>).</p>
        <p>Таким образом не будет унаследованного геттера/сеттера для <code>__proto__</code>. Теперь это свойство
        обрабатывается как обычное свойство, и приведенный выше пример работает правильно.</p>
        <p>Мы можем назвать такой объект «простейшим» или «чистым словарным объектом», потому что он еще проще,
        чем обычные объекты <code>{...}</code>.</p>
        <p>Недостаток в том, что у таких объектов не будет встроенных методов объекта, таких как <code>toString</code>.</p>
        <p>... Но обычно это нормально для ассоциативных массивов.</p>
        <p>Обратите внимание, что большинство методов, связанных с объектами, имеют вид
        <code>Object.something(...)</code>. К примеру, <code>Object.keys(obj)</code>. Подобные методы не находятся
        в прототипе, так что они продолжают работать для таких объектов.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Современные способы установки и прямого доступа к прототипу это:</p>
        <ul>
            <li><code>Object.create(proto[, descriptors])</code> - создает пустой объект со свойством <code>[Prototype]]</code>,
            указанным как <code>proto</code> (может быть <code>null</code>), и необязательными дескрипторами свойств.</li>
            <li><code>Object.getPrototypeOf(obj)</code> - возвращает свойство <code>[[Prototype]]</code> объекта
            <code>obj</code> (то же самое, что и геттер <code>__proto__</code>).</li>
            <li><code>Object.setPrototypeOf(obj, proto)</code> - устанавливает свойство <code>[[Prototype]]</code>
            объекта <code>obj</code> как <code>proto</code> (то же самое, что и сеттер <code>__proto__</code>).</li>
        </ul>
        <p>Встроенные геттер/сеттер <code>__proto__</code> не безопасен, если мы хотим использовать созданные пользователями
        ключи в объекте. Как минимум потому, что пользователь может ввести <code>'__proto__'</code> как ключ, от чего
        может возникнуть ошибка. Если повезет - последствия будут легкими, но, вообще говоря, они непредсказуемы.</p>
        <p>Так что мы можем использовать либо <code>Object.create(null)</code> для создания «простейшего» объекта,
        либо использовать коллекцию <code>Map</code>.</p>
        <p>Кроме этого, <code>Object.create</code> дает нам легкий способ создать поверхностную копию со всеми
        дескрипторами:</p>
        <code>
            let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
        </code>
        <p>Мы также явно увидели, что <code>__proto__</code> - это геттер/сеттер для свойства <code>[[Prototype]]</code>,
        и находится он в <code>Object.prototype</code>, как и другие методы.</p>
        <p>Мы можем создавать объекты без прототипов с помощью <code>Object.create(null)</code>. Такие объекты можно
        использовать как «чистые словари», у них нет проблем с использованием строки <code>__proto__</code> в качестве
        ключа.</p>
        <p>Еще методы:</p>
        <ul>
            <li>
                <code>Object.keys(obj)</code>/<code>Object.values(obj)</code>/<code>Object.entries(obj)</code> - возвращают
                массив всех перечисляемых собственных строковых ключей/значений/пар ключ-значение.
            </li>
            <li>
                <code>Object.getOwnPropertySymbols(obj)</code> - возвращает массив всех собственных символьных ключей.
            </li>
            <li>
                <code>Object.getOwnPropertyNames(obj)</code> - возвращает массив всех собственных строковых ключей.
            </li>
            <li>
                <code>Reflect.ownKeys(obj)</code> - возвращает массив всех собственных ключей.
            </li>
            <li><code>obj.hasOwnProperty(key)</code> - возвращает <code>true</code>, если у <code>obj</code> есть
            собственное (не унаследованное) свойство с именем <code>key</code>.</li>
        </ul>
        <p>Все методы, которые возвращают свойства объектов (такие как <code>Object.keys</code> и другие),
        возвращают «собственные» свойства. Если мы хотим получить унаследованные, можно воспользоваться циклом
        <code>for...in</code>.</p>
    </article>
</body>
</html>

<script src="script.js"></script>