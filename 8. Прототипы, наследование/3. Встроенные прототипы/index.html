<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Встроенные прототипы</title>
    <link href="../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Встроенные прототипы</h2>
        <p>Свойство <code>prototype</code> широко используется внутри самого языка JavaScript. Все встроенные
        функции-конструкторы используют его.</p>
    </article>

    <article>
        <h2>Object.prototype</h2>
        <p>Давайте выведем пустой объект:</p>
        <code>
            let obj = {};<br>
            alert(obj); // [object Object]
        </code>
        <p>Где код, который генерирует строку <code>[object Object]</code>? Это встроенный метод <code>toString</code>,
        но где он? <code>obj</code> ведь пуст!</p>
        <p>... Но краткая аннотация <code>obj = {}</code> - это то же самое, что и <code>obj = new Object()</code>,
        где <code>Object</code> - встроенная функция-конструктор для объектов с собственным свойством <code>prototype</code>,
        которое ссылается на огромный объект с методом <code>toString</code> и другими.</p>
        <p>Когда вызывается <code>new Object()</code> (или создается объект с помощью литерала <code>{...}</code>),
        свойство <code>[[Prototype]]</code> этого объекта устанавливается на <code>Object.prototype</code>.</p>
        <p>Таким образом, когда вызывается <code>obj.toString()</code>, метод берется из <code>Object.prototype</code>.</p>
        <p>Мы можем проверить это так:</p>
        <code>
            let obj = {};<br>
            <br>
            alert(obj.__proto__ == Object.prototype); // true<br>
            // obj.toString === obj.__proto__.toString === Object.prototype.toString
        </code>
        <p>Обратите внимание, что по цепочке прототипов выше <code>Object.prototype</code> больше нет свойства
        <code>[[Prototype]]</code>:</p>
        <code>alert(Object.prototype.__proto__); // null</code>
    </article>

    <article>
        <h2>Другие встроенные прототипы</h2>
        <p>Другие встроенные объекты, такие как <code>Array</code>, <code>Date</code>, <code>Function</code> и другие,
        также хранят свои методы в прототипах.</p>
        <p>Например, при создании массива <code>[1, 2, 3]</code> внутренне используется конструктор массива <code>Array</code>.
        Поэтому прототипом массива становится <code>Array.prototype</code>, предоставляя ему свои методы.
        Это позволяет эффективно использовать память.</p>
        <p>Согласно спецификации, наверху иерархии встроенных прототипов находится <code>Object.prototype</code>.
        Поэтому иногда говорят, что «все наследует от объектов».</p>
        <p>Некоторые методы в прототипах могут пересекаться, например, у <code>Array.prototype</code> есть свой метод
        <code>toString</code>, который выводит элементы массива через запятую.</p>
        <p>Как мы видели ранее, у <code>Object.prototype</code> есть свой метод <code>toString</code>, но так как
        <code>Array.prototype</code> ближе в цепочке прототипов, то берется именно вариант для массивов.</p>
        <p>Другие встроенные объекты устроены аналогично. Даже функции - они объекты встроенного конструктора
        <code>Function</code>, и все их методы (call/apply и другие) берутся из <code>Function.prototype</code>.</p>
    </article>

    <article>
        <h2>Примитивы</h2>
        <p>Самое сложное происходит со строками, числами и булевыми значениями.</p>
        <p>Как мы помним, они не объекты. Но если мы попытаемся получить доступ к их свойствам, то тогда будет
        создан временный объект-обертка, с использованием встроенных конструкторов <code>String</code>,
        <code>Number</code> и <code>Boolean</code>, который предоставит методы и после этого исчезнет.</p>
        <p>Эти объекты создаются невидимо для нас, и большая часть движков оптимизирует этот процесс, но
        спецификация описываем это именно таким образом. Методы этих объектов также находятся в прототипах,
        доступных как <code>String.prototype</code>, <code>Number.prototype</code> и <code>Boolean.prototype</code>.</p>

        <article class="warning">
            <h2>Значения <code>null</code> и <code>undefined</code> не имеют объектов-оберток</h2>
            <p>Специальные значения <code>null</code> и <code>undefined</code> стоят особняком. У них нет объектов-оберток,
            так что методы и свойства им недоступны. Также у них нет соответствующих прототипов.</p>
        </article>
    </article>

    <article>
        <h2>Изменение встроенных прототипов</h2>
        <p>Встроенные прототипы можно изменять. Например, если добавить метод к <code>String.prototype</code>,
        метод становится доступен для всех строк:</p>
        <code>
            String.prototype.show = function() {<br>
            &nbsp;&nbsp;alert(this);<br>
            };<br>
            <br>
            'BOOM!'.show(); // BOOM!
        </code>
        <p>В течение процесса разработки у вас могут возникнуть идеи о новых встроенных методах, которые нам хотелось
        бы иметь, и искушение добавить их во встроенные прототипы. Это плохая идея.</p>

        <article class="warning">
            <h2>Важно:</h2>
            <p>Прототипы глобальны, поэтому очень легко могут возникнуть конфликты. Если две библиотеки добавляют
            метод <code>String.prototype.show</code>, то одна из них перепишет другой метод.</p>
            <p>Так что в общем, изменение встроенных прототипов считается плохой идеей.</p>
        </article>

        <p><b>В современном программировании есть только один случай, в котором одобряется изменение встроенных прототипов.
        Это создание полифилов.</b></p>
        <p>Полифил - это термин, который означает эмуляцию метода, который существует в спецификации JavaScript,
        но еще не поддерживается текущим движком JavaScript.</p>
        <p>Тогда мы можем реализовать его сами и добавить во встроенный прототип.</p>
        <p>Например:</p>
        <code>
            if (!String.prototype.repeat) {<br>
            &nbsp;&nbsp;String.prototype.repeat = function(n) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return new Array(n + 1).join(this);<br>
            &nbsp;&nbsp;};<br>
            }<br>
            <br>
            alert('La'.repeat(3)); // LaLaLa
        </code>
    </article>

    <article>
        <h2>Заимствование у прототипов</h2>
        <p>В главе «Декораторы и переадресация вызова, call/apply» мы говорили о заимствовании методов.</p>
        <p>Это когда мы берем метод из одного объекта и копируем его в другой.</p>
        <p>Некоторые методы встроенных прототипов часто одалживают.</p>
        <p>Например, если мы создаем объект, похожий на массив (псевдомассив), мы можем скопировать некоторые методы из
        <code>Array</code> в этот объект.</p>
        <p>Пример:</p>
        <code>
            let obj = {<br>
            &nbsp;&nbsp;0: 'Hello',<br>
            &nbsp;&nbsp;1: 'World!',<br>
            &nbsp;&nbsp;length: 2:<br>
            };<br>
            <br>
            obj.join = Array.prototype.join;<br>
            <br>
            alert(obj.join(',')); // Hello,World!
        </code>
        <p>Это работает, потому что внутреннего алгоритма встроенного метода <code>join</code> важны только корректность
        индексов и свойство <code>length</code>, но не проверяет, является ли объект на самом деле массивом.
        И многие встроенные методы работают так же.</p>
        <p>Альтернативная возможность - мы можем унаследовать от массива, установив <code>obj.__proto__</code>
        как <code>Array.prototype</code>, таким образом все методы <code>Array</code> станут автоматически доступны
        в <code>obj</code>.</p>
        <p>Но это будет невозможно, если <code>obj</code> уже наследует от другого объекта. Помните, мы можем наследовать
        только от одного объекта одновременно.</p>
        <p>Заимствование методов - гибкий способ, позволяющий смешивать функциональность разных объектов по необходимости.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <ul>
            <li>
                Все встроенные объекты следуют одному шаблону:
                <ul>
                    <li>Методы хранятся в прототипах (<code>Array.prototype</code>, <code>Object.prototype</code>,
                    <code>Date.prototype</code> и т.д.)</li>
                    <li>Сами объекты хранят только данные (элементы массивов, свойства объектов, даты).</li>
                </ul>
            </li>
            <li>Примитивы также хранят свои методы в прототипах объектов-оберток: <code>Number.prototype</code>,
            <code>String.prototype</code>, <code>Boolean.prototype</code>. Только у значений <code>undefined</code>
            и <code>null</code> не объектов-оберток.</li>
            <li>Встроенные прототипы могут быть изменены или дополнены новыми методами. Но не рекомендуется менять их.
            Единственная допустимая причина - добавление нового метода из стандарта, которые еще не поддерживается
            движком JavaScript.</li>
        </ul>
    </article>
</body>
</html>

<script src="script.js"></script>