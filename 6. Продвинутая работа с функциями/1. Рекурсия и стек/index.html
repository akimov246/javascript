<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Рекурсия и стек</title>
    <link href="../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Рекурсия</h2>
        <p>Общее количество вложенных вызовов (включая первый) называют <i>глубиной рекурсии</i>.</p>
        <p>Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов,
        некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов - за пределами возможностей.
        Существуют автоматические оптимизации, помогающие избежать переполнения стека вызовов, но они еще не поддерживаются везде
        и работают только для простых случаев.</p>
        <p>Это ограничивает применения рекурсии, но она все равно широко распространена: для большого числа задач
        рекурсивный способ решения дает более простой код, который легче поддерживать.</p>
    </article>

    <article>
        <h2>Контекст выполнения, стек</h2>
        <p>Теперь мы рассмотрим, как работают рекурсивные методы. Для этого заглянем «под капот» функций.</p>
        <p>Информация о процессе выполнения запущенной функции хранится в ее <i>контексте выполнения</i> (execution context).</p>
        <p><b>Контекст выполнения</b> - специальная внутренняя структура данных, которая содержит информацию о вызове функции.
        Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции,
        значение <code>this</code> и прочую служебную информацию.</p>
        <p>Один вызов функции имеет ровно один контекст выполнения, связанный с ним.</p>
        <p>Когда функция производит вложенный вызов, происходит следующее:</p>
        <ul>
            <li>Выполнение текущей функции приостанавливается.</li>
            <li>Контекст выполнения, связанный с ней, запоминается в специальной структуре данных - <i>стеке контекстов
            выполнения</i>.</li>
            <li>Выполняются вложенные вызовы, для каждого из которых создается свой контекст выполнения.</li>
            <li>После их завершения старый контекст достается из стека, и выполнение внешней функции возобновляется с того места,
            где она была остановлена.</li>
        </ul>
        <p><b>Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.</b></p>
        <p>Но переделка рекурсии в цикл может быть нетривиальной, особенно когда в функции в зависимости от условий
        используются различные рекурсивные подвызовы, результаты которых объединяются, или когда ветвление более сложное.
        Оптимизация может быть ненужной и совершенно нестоящей усилий.</p>
        <p>Часто код с использованием рекурсии более короткий, легкий для понимания и поддержки. Оптимизация требуется
        не везде, как правило, нам важен хороший код, поэтому она и используется.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <ul>
            <li>
                <p><i>Рекурсия</i> - это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции
                могут быть использованы для элегантного решения определенных задач.</p>
                <p>Когда функция вызывает саму себя, это называется <i>шагом рекурсии</i>. База рекурсии - это такие
                аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных
                вызовов.</p>
            </li>
            <li>
                <p>Рекурсивно определяемая структура данных - это структура данных, которая может быть определена с
                использованием самое себя.</p>
                <p>Например, связанный список может быть определен как структура данных, состоящая из объекта, содержащего
                ссылку на список (или <code>null</code>).</p>
                <code>list = { value, next -> list }</code>
                <p>Деревья, такие как дерево HTML-элементов или дерево отделов из этой главы, также являются рекурсивными:
                у них есть ветви, и каждая ветвь может содержать другие ветви.</p>
            </li>
        </ul>
        <p>Любая рекурсивная функция может быть переписана в итеративную. И это иногда требуется для оптимизации работы.
        Но для многих задач рекурсивное решение достаточно быстрое и простое в написании и поддержке.</p>
    </article>
</body>
</html>

<script src="script.js"></script>