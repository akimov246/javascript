<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Остаточные параметры и оператор расширения</title>
    <link href="../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Остаточные параметры (<code>...</code>)</h2>
        <p>Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена.</p>
        <p>Например:</p>
        <code>
            function sum(a, b) {<br>
            &nbsp;&nbsp;return a + b;<br>
            }<br>
            <br>
            alert(sum(1, 2, 3, 4, 5));
        </code>
        <p>Лишние аргументы не вызовут ошибку. Но, конечно, посчитаются только первые два.</p>
        <p><i>Остаточные параметры</i> могут быть обозначены через три точки <code>...</code>. Буквально это значит:
        «собери оставшиеся параметры и положи их в массив».</p>
        <p>Например, соберем все аргументы в массив <code>args</code>:</p>
        <code>
            function sumAll(...args) {<br>
            &nbsp;&nbsp;let sum = 0;<br>
            <br>
            &nbsp;&nbsp;for (let arg of args) sum += arg;<br>
            <br>
            &nbsp;&nbsp;return sum;<br>
            }
        </code>
        <p>Мы можем положить первые несколько параметров в переменные, а остальные - собрать в массив.</p>
        <article class="warning">
            <h2>Остаточные параметры должны располагаться в конце</h2>
            <p>Остаточные параметры собирают все остальные аргументы, поэтому бессмысленно писать что-либо после них.
            Это вызовет ошибку.</p>
        </article>
    </article>

    <article>
        <h2>Переменная «arguments»</h2>
        <p>Все аргументы функции находятся в псевдомассиве <code>arguments</code> под своими порядковыми номерами.</p>
        <p>Например:</p>
        <code>
            function showName() {<br>
            &nbsp;&nbsp;alert(arguments.length);<br>
            &nbsp;&nbsp;alert(arguments[0]);<br>
            &nbsp;&nbsp;alert(arguments[1]);<br>
            }<br>
            <br>
            showName('Юлий', 'Цезарь'); // 2, Юлий, Цезарь<br>
            showName('Илья'); // 1, Илья, undefined
        </code>
        <p>Раньше в языке не было остаточных параметров, и получить все аргументы функции можно было только с помощью
        <code>arguments</code>. Этот способ все еще работает, мы можем найти его в старом коде.</p>
        <p>Но у него есть один недостаток. Хотя <code>arguments</code> похож на массив, и его тоже можно перебирать,
        это все же не массив. Он не поддерживает методы массивов, поэтому мы не можем, например, вызвать
        <code>arguments.map(...)</code>.</p>
        <p>К тому же, <code>arguments</code> всегда содержит все аргументы функции - мы не можем получить их часть.
        А остаточные параметры позволяют это сделать.</p>
        <p>Соответственно, для более удобной работы с аргументами лучше использовать остаточные параметры.</p>

        <article class="note">
            <h2>Стрелочные функции не имеют <code>arguments</code></h2>
            <p>Если мы обратимся к <code>arguments</code> из стрелочной функции, то получим аргументы внешней
            «нормальной» функции.</p>
            <p>Пример:</p>
            <code>
                function f() {<br>
                &nbsp;&nbsp;let showArg = () => alert(arguments[0]);<br>
                showArg(2);<br>
                }<br>
                <br>
                f(1); // 1
            </code>
            <p>Как мы помним, у стрелочных функций нет собственного <code>this</code>. Теперь мы знаем, что нет и своего
            объекта <code>arguments</code>.</p>
        </article>
    </article>

    <article>
        <h2>Оператор расширения</h2>
        <p>Мы узнали как получить массив из списка параметров.</p>
        <p>Но иногда нужно сделать в точности противоположное.</p>
        <p>Например, есть встроенная функция <code>Math.max</code>. Она возвращает наибольшее число из списка:</p>
        <code>alert(Math.max(3, 5, 1)); // 5</code>
        <p>Допустим, у нас есть массив чисел <code>[3, 5, 1]</code>. Как вызвать для него <code>Math.max</code>?</p>
        <p>Просто так их не вставишь - <code>Math.max</code> ожидает получить список чисел, а не один массив.</p>
        <p>Конечно, мы можем вводить числа вручную. Но, во-первых, это плохо выглядит, а, во-вторых, мы не всегда знаем,
        сколько будет аргументов. Их может быть как очень много, так и не быть совсем.</p>
        <p>И тут нам поможет <i>оператор расширения</i>. Он похож на остаточные параметры - тоже использует <code>...</code>,
        но делает совершенно противоположное.</p>
        <p>Когда <code>...arr</code> используется при вызове функции, он «расширяет» перебираемый объект <code>arr</code>
        в список аргументов.</p>
        <p>Для <code>Math.max</code>:</p>
        <code>
            let arr = [3, 5, 1];<br>
            <br>
            alert(Math.max(...arr)); // 5
        </code>
        <p>Этим же способом мы можем передать несколько итерируемых объектов:</p>
        <code>
            let arr1 = [1, -2, 3, 4];<br>
            let arr2 = [8, 3, -8, 1];<br>
            <br>
            alert(Math.max(...arr1, ...arr2)); // 8
        </code>
        <p>Мы даже можем комбинировать оператор расширения с обычными значениями:</p>
        <code>
            let arr1 = [1, -2, 3, 4];<br>
            let arr2 = [8, 3, -8, 1];<br>
            <br>
            alert(Math.max(1, ...arr1, 2, ...arr2, 25)); // 25
        </code>
        <p>Оператор расширения можно использовать и для слияния массивов:</p>
        <code>
            let arr = [3, 5, 1];<br>
            let arr2 = [8, 9, 15];<br>
            <br>
            let merge = [0, ...arr, 2, ...arr2];
        </code>
        <p>В примерах выше мы использовали массив, чтобы продемонстрировать свойства оператора расширения,
        но он работает с любым перебираемым объектом.</p>
        <p>Например, оператор расширения подойдет для того, чтобы превратить строку в массив символов:</p>
        <code>
            let str = 'Привет';<br>
            alert([...str]); // П,р,и,в,е,т
        </code>
        <p>Посмотрим что происходит. Под капотом оператор расширения использует итераторы, чтобы перебирать элементы.
        Так же, как делает <code>for...of</code>.</p>
        <p>Цикл <code>for...of</code> перебирает строку как последовательность символов, поэтому из <code>...str</code>
        Получается <code>'П', 'р', 'и', 'в', 'е', 'т'</code>. Получившиеся символы собираются в массив при помощи
        стандартного объявления массива: <code>[...str]</code>.</p>
        <p>Для этой задачи мы можем использовать и <code>Array.from</code>. Он тоже преобразует перебираемый объект
        в массив:</p>
        <code>
            let str = 'Привет';<br>
            alert(Array.from(str)); // П,р,и,в,е,т
        </code>
        <p>Результат аналогичен <code>[...str]</code>.</p>
        <p>Но между <code>Array.from(obj)</code> и <code>[...obj]</code> есть разница:</p>
        <ul>
            <li><code>Array.from</code> работает как с псевдомассивами, так и с итерируемыми объектами.</li>
            <li>Оператор расширения работает только с итерируемыми массивами.</li>
        </ul>
        <p>Выходит, что если нужно сделать из чего угодно массив, то <code>Array.from</code> - более универсальный метод.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Когда мы видим <code>...</code> в коде, это могут быть как остаточные параметры, так и оператор расширения.</p>
        <p>Как отличить их друг от друга:</p>
        <ul>
            <li>Если <code>...</code> располагается в конце списка параметров функции, то это «остаточные параметры».
            Он собирает остальные неуказанные аргументы и делает из них массив.</li>
            <li>Если <code>...</code> встретился в вызове функции или где-либо еще, то это «оператор расширения».
            Он извлекает элементы из массива.</li>
        </ul>
        <p>Полезно запомнить:</p>
        <ul>
            <li>Остаточные параметры используются, чтобы создавать новые функции с неопределенным числом аргументов.</li>
            <li>С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с
            обычным списком аргументов.</li>
        </ul>
        <p>Все эти конструкции помогают легко преобразовывать наборы значений в массивы и обратно.</p>
        <p>К аргументам функции можно обращаться и по-старому - через псевдомассив <code>arguments</code>.</p>
    </article>
</body>
</html>