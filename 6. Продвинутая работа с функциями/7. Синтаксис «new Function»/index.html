<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Синтаксис «new Function»</title>
    <link href="../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Синтаксис «new Function»</h2>
        <p>Существует еще один вариант объявления функции. Он используется крайне редко, но иногда другого решения не найти.</p>
    </article>

    <article>
        <h2>Синтаксис</h2>
        <p>Синтаксис для объявления функции:</p>
        <code>let func = new Function([arg1, arg2, ...argN], functionBody);</code>
        <p>Функция создается с заданными аргументами <code>arg1...argN</code> и телом <code>functionBody</code>.</p>
        <p>Это проще понять на конкретном примере. Здесь объявлена функция с двумя аргументами:</p>
        <code>
            let sum = new Function('a', 'b', 'return a + b');<br>
            <br>
            alert(sum(1, 2)); // 3
        </code>
        <p>А вот функция без аргументов, в этом случае достаточно указать только тело:</p>
        <code>
            let sayHi = new Function('alert("Привет!")');<br>
            <br>
            sayHi();
        </code>
        <p>Главное отличие от других способов объявления функции, которые были рассмотрены ранее, заключается в том,
        что функция создается полностью на лету, из строки, переданной во время выполнения.</p>
        <p><code>new Function</code> позволяет превратить любую строку в функцию. Например, можно получить новую
        функцию с сервера и затем выполнить ее:</p>
        <code>
            let str = ... код, полученный с сервера динамически ... <br>
            <br>
            let func = new Function(str);<br>
            func();
        </code>
        <p>Это используется в очень специфических случаях, например, когда мы получаем код с сервера для динамической
        компиляции функции из шаблона, в сложных веб-приложениях.</p>
    </article>

    <article>
        <h2>Замыкание</h2>
        <p>Обычно функция запоминает, где родилась, в специальном свойстве <code>[[Environment]]</code>. Это ссылка
        на лексическое окружение, в котором она создана.</p>
        <p>Но когда функция создается с использованием <code>new Function</code>, в ее <code>[[Environment]]</code>
        записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное.
        Поэтому такая функция имеет доступ только к глобальным переменным.</p>
        <code>
            function getFunc() {<br>
            &nbsp;&nbsp;let value = 'test';<br>
            <br>
            &nbsp;&nbsp;let func = new Function('alert(value))');<br>
            <br>
            &nbsp;&nbsp;return func;<br>
            }<br>
            <br>
            getFunc()(); // Ошибка: value не определено
        </code>
        <p>Эта особенность <code>new Function</code> выглядит странно, но оказывается очень полезной на практике.</p>
        <p>Представьте, что нужно создать функцию из строки. Код этой функции неизвестен во время написания скрипта
        (поэтому не используем обычные функции), а будет определен только в процессе выполнения. Мы можем получить
        код с сервера или с другого ресурса.</p>
        <p>Наша новая функция должна взаимодействовать с основным скриптом.</p>
        <p>Что если бы она имела доступ к внешним переменным?</p>
        <p>Проблема в том, что перед отправкой JavaScript-кода на реально работающие проекты код сжимается с помощью
        <i>минификатора</i> - специальной программы, которая уменьшает размер кода, удаляя комментарии, лишние пробелы,
        и, что самое главное, локальным переменным даются укороченные имена.</p>
        <p>Например, если в функции объявлена переменная <code>let userName</code>, то минификатор изменяет ее на
        <code>let a</code> (или другую букву, если она не занята) и изменяет ее везде. Обычно так делать безопасно,
        потому что переменная является локальной, и никто снаружи не имеет к ней доступ. И внутри функции минификатор
        заменяет каждое ее упоминание. Минификаторы достаточно умные. Они не просто осуществляют «тупой» поиск-замену,
        они анализируют структуру кода, и поэтому ничего не ломается.</p>
        <p>Так что если бы даже <code>new Function</code> и имел доступ к внешним переменным, она не смогла бы найти
        переименованную <code>userName</code>.</p>
        <p><b>Если бы <code>new Function</code> имела доступ к внешним переменным, при этом были бы проблемы с
        минификаторами</b>.</p>
        <p>Кроме того, такой код был бы архитектурно хуже и более подвержен ошибкам.</p>
        <p>Чтобы передать что-то в функцию, созданную как <code>new Function</code>, можно использовать ее аргументы.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Синтаксис:</p>
        <code>let func = new Function([arg1, arg2, ...argN], functionBody);</code>
        <p>По историческим причинам аргументы также могут быть объявлены через запятую в одной строке.</p>
        <p>Эти 3 объявления ниже эквивалентны:</p>
        <code>
            new Function('a', 'b', 'return a + b'); // Стандартный синтаксис<br>
            new Function('a,b', 'return a + b'); // Через запятую в одной строке<br>
            new Function('a , b', 'return a + b'); // Через запятую с пробелами в одной строке
        </code>
        <p>Функции, объявленные через <code>new Function</code>, имеют <code>[[Environment]]</code>, ссылающийся на
        глобальное лексическое окружение, а не на родительское. Поэтому они не могут использовать внешние локальные
        переменные. Но это очень хорошо, потому что страхует нас от ошибок. Переданные явно параметры - гораздо лучшее
        архитектурное решение, которое не вызывает проблем у минификаторов.</p>
    </article>
</body>
</html>