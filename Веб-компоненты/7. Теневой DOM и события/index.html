<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Теневой DOM и события</title>
    <link href="../../style.css" rel="stylesheet">
    <script defer src="../../highlightElements.js"></script>
</head>
<body>
    <article>
        <h2>Теневой DOM и события</h2>
        <p>Смысл создания теневого DOM дерева - это инкапсуляция внутренних деталей компонента.</p>
        <p>Допустим, клик произошел внутри теневого DOM на компоненте <code>&lt;button-example&gt;</code>. Но скрипты основного
        документа ничего не знают о внутреннем устройстве теневой DOM-структуры, в особенности, если компонент
        создан сторонней библиотекой.</p>
        <p>Поэтому, чтобы не нарушать инкапсуляцию, браузер <i>меняет у этого события целевой элемент</i>.</p>
        <p><b>События, которые произошли в теневом DOM, но пойманы снаружи этого DOM, имеют элемент-хозяин в качестве
        целевого элемента <code>event.target</code>.</b></p>
        <p>Рассмотрим простой пример:</p>
<pre><code class="language-html">&lt;button-example&gt;&lt;/button-example&gt;

&lt;script&gt;</code>
    <code class="language-javascript">customElements.define('button-example', class extends HTMLElement {
        connectedCallback() {
            this.attachShadow({mode: 'open'});
            this.shadowRoot.innerHTML = `
                &lt;p&gt;&lt;button&gt;Нажми меня&lt;/button&gt;&lt;/p&gt;
            `;
            this.shadowRoot.firstElementChild.onclick = (event) => {
                alert(`Внутренний целевой элемент: ${event.target.tagName}`);
            }
    });

    document.onclick = (event) => {
        alert(`Внешний целевой элемент: ${event.target.tagName}`);
    }</code>
<code class="language-html">&lt;/script&gt;</code></pre>
        <div style="margin: 0.5rem">
            <button-example></button-example>
        </div>
        <script>
            customElements.define('button-example', class extends HTMLElement {
                connectedCallback() {
                    this.attachShadow({mode: 'open'});
                    this.shadowRoot.innerHTML = `
                        <p><button>Нажми меня</button></p>
                    `;
                    this.shadowRoot.firstElementChild.addEventListener('click', function(event) {
                        alert(`Внутренний целевой элемент: ${event.target.tagName}`);
                    });
                }
            });

            document.querySelector('button-example').addEventListener('click', function(event) {
                alert(`Внешний целевой элемент: ${event.target.tagName}`);
            });
        </script>
        <p>Если нажать на кнопку, то выведется следующее:</p>
        <ol>
            <li>
                <p>Внутренний целевой элемент: <code>BUTTON</code> - внутренний обработчик событий получает правильный
                целевой элемент - элемент, находящийся внутри теневого DOM.</p>
            </li>
            <li>
                <p>Внешний целевой элемент: <code>BUTTON-EXAMPLE</code> - обработчик событий на уровне документа получает
                элемент-хозяин в качестве целевого.</p>
            </li>
        </ol>
        <p>Хорошо, что браузер подменяет целевые элементы событий. Потому что внешний документ ничего не знает о внутреннем
        устройстве компонента. С его (внешнего документа) точки зрения, событий происходит на <code>&lt;button-example&gt;</code>.</p>
        <p><b>Подмена целевого элемента не происходит, если событие берет начало на элементе из слота, который фактически
        находится в обычном, светлом DOM.</b></p>
        <p>Например, если пользователь кликнет на <code>&lt;span slot="username"&gt;</code> в примере ниже - целевой элемент
        события будет именно этот <code>span</code> для обоих обработчиков - теневого и обычного (светлого):</p>
<pre><code class="language-html">&lt;user-card id="userCard"&gt;
    &lt;span slot="username"&gt;John Smith&lt;/span&gt;
&lt;/user-card&gt;

&lt;script&gt;</code>
    <code class="language-javascript">customElements.define('user-card', class extends HTMLElement {
        connectedCallback() {
            this.attachShadow({mode: 'open'});
            this.shadowRoot.innerHTML = `
                &lt;div&gt;
                    &lt;b&gt;Имя:&lt;/b&gt; &lt;slot name="username"&gt;&lt;/slot&gt;
                &lt;/div&gt;
            `;

            this.shadowRoot.firstElementChild.onclick = (event) => {
                alert(`Внутренний целевой элемент: ${event.target.tagName}`);
            }
        }
    });

    userCard.onclick = (event) => {
        alert(`Внешний целевой элемент: ${event.target.tagName}`);
    }</code>
<code class="language-html">&lt;/script&gt;</code></pre>
        <user-card id="userCard">
            <span slot="username">John Smith</span>
        </user-card>
        <script>
            customElements.define('user-card', class extends HTMLElement {
                connectedCallback() {
                    this.attachShadow({mode: 'open'});
                    this.shadowRoot.innerHTML = `
                        <div>
                            <b>Имя:</b> <slot name="username"></slot>
                        </div>
                        <style>
                            div {
                                border: 3px solid var(--border-color-grey);
                                border-radius: 0.5rem;
                                width: max-content;
                                padding: 0.5rem;
                            }

                            div b {
                                cursor: pointer;
                            }

                            ::slotted(span) {
                                cursor: pointer;
                            }
                        </style>
                    `;

                    this.shadowRoot.firstElementChild.addEventListener('click', function(event) {
                        alert(`Внутренний целевой элемент: ${event.target.tagName}`);
                    });
                }
            });
            userCard.addEventListener('click', function(event) {
                alert(`Внешний целевой элемент: ${event.target.tagName}`);
            });
        </script>
        <p>Если клик произойдет на <code>"John Smith"</code>, то для обоих обработчиков - внутреннего и внешнего - целевым
        элементом будет <code>&lt;span slot="username"&gt;</code>. Это элемент обычного (светлого) DOM, так что
        подмены не происходит.</p>
        <p>С другой стороны, если клик произойдет на элементе, который находится в теневом DOM, например, на
        <code>&lt;b&gt;Имя:&lt;/b&gt;</code>, то как только всплытие выйдет за пределы теневой DOM-структуры, его
        <code>event.target</code> станет <code>&lt;user-card&gt;</code>.</p>
    </article>

    <article>
        <h2>Всплытие и метод event.composedPath()</h2>
        <p>Для обеспечения всплытия событий используется развернутый DOM.</p>
        <p>Таким образом, если у нас есть элемент в слоте, и событие происходит где-то внутри него, то оно всплывает
        до <code>&lt;slot&gt;</code> и выше.</p>
        <p>Полный путь к изначальному целевому элементу, со всеми теневыми элементами, можно получить, воспользовавшись
        методом <code>event.composedPath()</code>. Как видно из названия, этот метод возвращает путь после композиции.</p>
        <p>В примере выше развернутое DOM-дерево будет таким:</p>
<pre><code class="language-html">&lt;user-card id="userCard"&gt;
    #shadow-root
    &lt;div&gt;
        &lt;b&gt;Имя:&lt;/b&gt;
        &lt;slot name="username"&gt;
            &lt;span slot="username"&gt;John Smith&lt;/span&gt;
        &lt;/slot&gt;
    &lt;/div&gt;
&lt;/user-card&gt;</code></pre>
        <p>Так что при клике по <code>&lt;span slot="username"&gt;</code> вызов метода <code>event.composedPath()</code>
        вернет массив: [<code>span</code>, <code>slot</code>, <code>div</code>, <code>shadow-root</code>,
        <code>user-card</code>, <code>body</code>, <code>html</code>, <code>document</code>, <code>window</code>].
        Что в точности отражает цепочку родителей от целевого элемента в развернутой DOM-структуре после композиции.</p>

        <article class="warning">
            <h3>Детали теневого DOM-дерева доступны только для деревьев с <code>{mode: 'open'}</code></h3>
            <p>Если теневое DOM-дерево было создано с <code>{mode: 'closed'}</code>, то после композиции путь будет
            начинаться с элемента-хозяина: <code>user-card</code> и дальше вверх по дереву.</p>
            <p>Этот метод следует тем же принципам, что и остальные. Внутреннее устройство закрытых DOM-деревьев
            совершенно скрыто.</p>
        </article>

    </article>

    <article>
        <h2>Свойство: event.composed</h2>
        <p>Большинство событий успешно всплывают сквозь границу теневого DOM. Но не все.</p>
        <p>Это поведение регулируется с помощью свойства <code>composed</code> объекта события. Если оно <code>true</code>,
        то событие пересекает границу. Иначе, оно может быть поймано лишь внутри теневого DOM.</p>
        <p>Если посмотреть в
        <a target="_blank" href="https://www.w3.org/TR/uievents">спецификацию UI Events</a>, то большинство событий
        имеют <code>composed: true</code>:</p>
        <ul>
            <li>
                <p><code>blur</code>, <code>focus</code>, <code>focusin</code>, <code>focusout</code>.</p>
            </li>
            <li>
                <p><code>click</code>, <code>dblclick</code>.</p>
            </li>
            <li>
                <p><code>mousedown</code>, <code>mouseup</code>, <code>mousemove</code>, <code>mouseout</code>,
                <code>mouseover</code>.</p>
            </li>
            <li>
                <p><code>wheel</code>.</p>
            </li>
            <li>
                <p><code>beforeinput</code>, <code>input</code>, <code>keydown</code>, <code>keyup</code>.</p>
            </li>
        </ul>
        <p>Все событий курсора и сенсорные нажатия также имеют <code>composed: true</code>.</p>
        <p>Хотя есть и события, имеющие <code>composed: false</code>:</p>
        <ul>
            <li>
                <p><code>mouseenter</code>, <code>mouseleave</code> (они вообще не всплывают).</p>
            </li>
            <li>
                <p><code>load</code>, <code>unload</code>, <code>abort</code>, <code>error</code>.</p>
            </li>
            <li>
                <p><code>select</code>.</p>
            </li>
            <li>
                <p><code>slotchange</code>.</p>
            </li>
        </ul>
        <p>Эти события могут быть пойманы только на элементах того же DOM, в котором находится целевой элемент события.</p>
    </article>

    <article>
        <h2>Генерация событий</h2>
        <p>Когда мы генерируем свое событие, то, чтобы оно всплывало за пределы компонента, нужно установить оба
        свойства: <code>bubbles</code> и <code>composed</code> - в значение <code>true</code>.</p>
        <p>Например, здесь мы создаем элемент <code>div#inner</code> в теневом DOM-дереве элемента <code>div#outer</code>
        и генерируем на нем два события. Только одно с флагом <code>composed: true</code> выйдет наружу, в документ:</p>
<pre><code class="language-html">&lt;div id="outer"&gt;&lt;/div&gt;

&lt;script&gt;</code>
    <code class="language-javascript">outer.attachShadow({mode: 'open});

    let inner = document.createElement('div');
    inner.id = 'inner';
    outer.shadowRoot.append(inner);

    /*
    div(id=outer)
        #shadow-root
            div(id=inner)
    */

    document.addEventListener('test', (event) => alert(event.detail));

    inner.dispatchEvent(new CustomEvent('test', {
        bubbles: true,
        composed: true,
        detail: 'composed'
    }));

    inner.dispatchEvent(new CustomEvent('test', {
        bubbles: true,
        composed: false,
        detail: 'not composed'
    }));</code>
<code class="language-html">&lt;/script&gt;</code></pre>
        <div style="margin: 0.5rem">
            <button>Запустить пример</button>
            <div id="outer"></div>
        </div>
        <script>
            document.currentScript.previousElementSibling.firstElementChild.addEventListener('click', function() {
                let inner = document.createElement('div');
                inner.id = 'inner';
                outer.attachShadow({mode: 'open'});
                outer.shadowRoot.append(inner);

                document.addEventListener('test', (event) => alert(`${event.target.tagName}#${event.target.id}: ${event.detail}`));

                inner.dispatchEvent(new CustomEvent('test', {
                    bubbles: true,
                    composed: true,
                    detail: 'composed'
                }));

                inner.dispatchEvent(new CustomEvent('test', {
                    bubbles: true,
                    composed: false,
                    detail: 'not composed'
                }))
            });
        </script>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Только те события пересекают границы теневого DOM, у которых флаг <code>composed</code> установлен в значение
        <code>true</code>.</p>
        <p>У большинства встроенных событий стоит <code>composed: true</code>, это описано в соответствующих спецификациях:</p>
        <ul>
            <li>
                <p>UI Events <a target="_blank" href="https://www.w3.org/TR/uievents">https://www.w3.org/TR/uievents</a>.</p>
            </li>
            <li>
                <p>Touch Events <a target="_blank" href="https://w3c.github.io/touch-events">https://w3c.github.io/touch-events</a>.</p>
            </li>
            <li>
                <p>Pointer Events <a target="_blank" href="https://www.w3.org/TR/pointerevents">https://www.w3.org/TR/pointerevents</a>.</p>
            </li>
            <li>
                <p>... И так далее.</p>
            </li>
        </ul>
        <p>У некоторых встроенных событий все же стоит <code>composed: false</code>:</p>
        <ul>
            <li>
                <p><code>mouseenter</code>, <code>mouseleave</code> (вообще не сплывают).</p>
            </li>
            <li>
                <p><code>load</code>, <code>unload</code>, <code>abort</code>, <code>error</code>.</p>
            </li>
            <li>
                <p><code>select</code>.</p>
            </li>
            <li>
                <p><code>slotchange</code>.</p>
            </li>
        </ul>
        <p>Эти события могут быть пойманы только на элементах, принадлежащих тому же DOM-дереву.</p>
        <p>Если мы генерируем свое событие <code>CustomEvent</code>, то должны явно поставить флаг <code>composed: true</code>.</p>
        <p>Обратите внимание, что в случае вложенных компонентов теневые DOM могут быть вложены друг в друга.
        События с флагом <code>composed</code> всплывают через границу всех теневых DOM. Поэтому, если событие
        предназначено только для ближайшего внешнего компонента-родителя, мы можем инициировать его на элементе-хозяине
        и установить флаг <code>composed: false</code>. Тогда оно будет уже вне теневого DOM компонента, но не всплывет
        наружу в «еще более внешний» DOM.</p>
    </article>
</body>
</html>