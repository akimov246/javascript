<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Слоты теневого DOM, композиция</title>
    <link href="../../style.css" rel="stylesheet">
    <script defer src="../../highlightElements.js"></script>
</head>
<body>
    <article>
        <h2>Слоты теневого DOM, композиция</h2>
        <p>Многим типам компонентов, таким как вкладки, меню, галереи изображений и другие, нужно какое-то содержимое для
        отображения.</p>
        <p>Так же, как встроенный в браузер <code>&lt;select&gt;</code> ожидает получить контент пунктов
        <code>&lt;option&gt;</code>, компонент <code>&lt;custom-tabs&gt;</code> может ожидать, что будет передано
        фактическое содержимое вкладок, а <code>&lt;custom-menu&gt;</code> - пунктов меню.</p>
        <p>Код, использующий меню <code>&lt;custom-menu&gt;</code>, может выглядеть так:</p>
<pre><code class="language-html">&lt;custom-menu&gt;
    &lt;title&gt;Сладости&lt;/title&gt;
    &lt;item&gt;Леденцы&lt;/item&gt;
    &lt;item&gt;Фруктовые тосты&lt;/item&gt;
    &lt;item&gt;Кексы&lt;/item&gt;
&lt;/custom-menu&gt;</code></pre>
        <p>... Затем компонент должен правильно его отобразить - как обычное меню с заданным названием и пунктами,
        обрабатывать события меню и т.д.</p>
        <p>Как это реализовать?</p>
        <p>Можно попробовать проанализировать содержимое элемента и динамически скопировать и переставить DOM-узлы.
        Это возможно, но если мы будем перемещать элементы в теневой DOM, CSS-стили документа не будут применяться,
        и мы потеряем визуальное оформление. Кроме того, нужно будет писать дополнительный код.</p>
        <p>К счастью, нам этого делать не нужно. Теневой DOM поддерживает элементы <code>&lt;slot&gt;</code>, которые
        автоматически наполняются контентом из обычного, «светлого» DOM-дерева.</p>
    </article>

    <article>
        <h2>Именованные слоты</h2>
        <p>Давайте рассмотрим работу слотов на простом примере.</p>
        <p>Теневой DOM <code>&lt;user-card&gt;</code> имеет два слота, заполняемые из обычного DOM:</p>
<pre><code class="language-html">&lt;script&gt;</code>
    <code class="language-javascript">customElements.define('user-card', class extends HTMLElement) {
        connectedCallback() {
            this.attachShadow({mode: 'open'});
            this.shadowRoot.innerHTML = `
                &lt;div&gt;Имя:
                    &lt;slot name="username"&gt;&lt;/slot&gt;
                &lt;/div&gt;
                &lt;div&gt;Дата рождения:
                    &lt;slot name="birthday"&gt;&lt;/slot&gt;
                &lt;/div&gt;
            `;
        }
    });</code>
<code class="language-html">&lt;/script&gt;

&lt;user-card&gt;
    &lt;span slot="username"&gt;Иван Иванов&lt;/span&gt;
    &lt;span slot="birthday"&gt;01.01.2001&lt;/span&gt;
&lt;/user-card&gt;</code></pre>
        <user-card>
            <span slot="username">Иван Иванов</span>
            <span slot="birthday">01.01.2001</span>
        </user-card>
        <script>
            customElements.define('user-card', class extends HTMLElement {
                connectedCallback() {
                    this.attachShadow({mode: 'open'});
                    this.shadowRoot.innerHTML = `
                        <div style="margin: 0.5rem; border: 3px solid var(--border-color-grey); width: max-content; padding: 0.5rem; border-radius: 0.5rem">
                            <div>Имя:
                                <slot name="username"></slot>
                            </div>
                            <div>Дата рождения:
                                <slot name="birthday"></slot>
                            </div>
                        </div>
                    `;
                }
            });
        </script>
        <p>В теневом DOM <code>&lt;slot name="X"&gt;</code> определяет «точку вставки» - место, где отображаются элементы
        с <code>slot="X"</code>.</p>
        <p>Затем браузер выполняет «композицию»: берет элементы из обычного DOM-дерева и отображает их в соответствующих
        слотах теневого DOM-дерева. В результате мы получаем именно то, что хотели - компонент, который можно наполнить
        данными.</p>
        <p>После выполнения скрипта структура DOM выглядит следующим образом (без учета композиции):</p>
<pre><code class="language-html">&lt;user-card&gt;
    #shadow-root
        &lt;div&gt;Имя:
            &lt;slot name="username"&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;slot name="birthday"&gt;&lt;/slot&gt;
        &lt;/div&gt;
    &lt;span slot="username"&gt;Иван Иванов&lt;/span&gt;
    &lt;span slot="birthday"&gt;01.01.2001&lt;/span&gt;
&lt;/user-card&gt;</code></pre>
        <p>Мы создали теневой DOM, он изображен под <code>#shadow-root</code>. Теперь у элемента есть два DOM-дерева:
        обычное («светлое») и теневое.</p>
        <p>Чтобы отобразить содержимое, для каждого <code>&lt;slot name="..."&gt;</code>в теневом DOM браузер
        ищет <code>slot="..."</code> с таким же именем в обычном DOM. Эти элементы отображаются внутри слотов:</p>
        <img src="images/shadow-dom-user-card.svg" alt style="width: 40vw">
        <p>В результате выстраивается так называемое «развернутое» (flattened) DOM-дерево:</p>
<pre><code class="language-html">&lt;user-card&gt;
    #shadow root
        &lt;div&gt;Имя:
            &lt;slot name="username"&gt;
                &lt;!-- Элемент слота вставляется в слот --&gt;
                &lt;span slot="username"&gt;Иван Иванов&lt;/span&gt;
            &lt;/slot&gt;
        &lt;/div&gt;
        &lt;div&gt;Дата рождения:
            &lt;slot name="birthday"&gt;
                &lt;span slot="birthday"&gt;01.01.2001&lt;/span&gt;
            &lt;/slot&gt;
        &lt;/div&gt;
&lt;/user-card&gt;</code></pre>
        <p>... Но развернутое DOM-дерево существует только для целей отображения и обработки событий. Это то, что
        мы видим на экране. Оно, в некотором смысле, «виртуальное». Фактически в документе расположение узлов не меняется.</p>
        <p>Это можно легко проверить, запустив <code>querySelectorAll</code>: все узлы находятся на своих местах.</p>
<pre><code class="language-javascript">// Узлы светлого DOM находятся в том же месте, в &lt;user-card&gt;
alert(document.querySelectorAll('user-card span').length); // 2</code></pre>
        <p>Так что развернутый DOM составляется из теневого, вставкой в слоты. Браузер использует его для рендеринга
        и при всплытии событий (об этом позже). Но JavaScript видит документ «как есть» - до построения развернутого
        DOM-дерева.</p>

        <article class="warning">
            <h3>Атрибут <code>slot="..."</code> могут иметь только дети первого уровня</h3>
            <p>Атрибут <code>slot="..."</code> работает только на непосредственных детях элемента-хозяина теневого
            дерева (в нашем примере это элемент <code>&lt;user-card&gt;</code>). Для вложенных элементов он игнорируется.</p>
            <p>Например, здесь второй <code>&lt;span&gt;</code> игнорируется (так как он не является потомком верхнего
            уровня элемента <code>&lt;user-card&gt;</code>):</p>
<pre><code class="language-html">&lt;user-card&gt;
    &lt;span slot="username"&gt;Иван Иванов&lt;/span&gt;
    &lt;div&gt;
        &lt;!-- Некорректный слот, должен быть на верхнем уровне &lt;user-card&gt;: --&gt;
        &lt;span slot="birthday"&gt;01.01.2001&lt;/span&gt;
    &lt;/div&gt;
&lt;/user-card&gt;</code></pre>
        </article>

        <p>Если в светлом DOM есть несколько элементов с одинаковым именем слота, они добавляются в слот один за другим.</p>
        <p>Например, этот код:</p>
<pre><code class="language-html">&lt;user-card&gt;
    &lt;span slot="username"&gt;Иван&lt;/span&gt;
    &lt;span slot="username"&gt;Иванов&lt;/span&gt;
&lt;/user-card&gt;</code></pre>
        <p>Даст такой развернутый DOM с двумя элементами в <code>&lt;slot name="username"&gt;</code>:</p>
<pre><code class="language-html">&lt;user-card&gt;
    #shadow-root
        &lt;div&gt;Имя:
            &lt;slot name="username"&gt;
                &lt;span slot="username"&gt;Иван&lt;/span&gt;
                &lt;span slot="username"&gt;Иванов&lt;/span&gt;
            &lt;/slot&gt;
        &lt;/div&gt;
        &lt;div&gt;Дата рождения:
            &lt;slot name="birthday"&gt;&lt;/slot&gt;
        &lt;/div&gt;
&lt;/user-card&gt;</code></pre>
    </article>

    <article>
        <h2>Содержимое слота «по умолчанию»</h2>
        <p>Если мы добавляем данные в <code>&lt;slot&gt;</code>, это становится содержимым «по умолчанию». Браузер отображает
        его, если в светлом DOM-дереве отсутствуют данные для заполнения слота.</p>
        <p>Например, в этой части теневого дерева текст <code>Аноним</code> отображается, если в светлом дереве нет
        значения <code>slot="username"</code>.</p>
<pre><code class="language-html">&lt;div&gt;Имя:
    &lt;slot name="username"&gt;Аноним&lt;/slot&gt;
&lt;/div&gt;</code></pre>
    </article>

    <article>
        <h2>Слот по умолчанию (первый без имени)</h2>
        <p>Первый <code>&lt;slot&gt;</code> в теневом дереве без атрибута <code>name</code> является слотом по умолчанию.
        Он будет отображать данные со всех узлов светлого дерева, не добавленные в другие слоты.</p>
        <p>Например, давайте добавим слот по умолчанию в наш элемент <code>&lt;user-card&gt;</code>. Он будет собирать
        всю информацию о пользователе, не занесенную в другие слоты:</p>
<pre><code class="language-html">&lt;script&gt;</code>
    <code class="language-javascript">customElements.define('user-card', class extends HTMLElement {
        connectedCallback() {
            this.attachShadow({mode: 'open'});
            this.shadowRoot.innerHTML = `
            &lt;div&gt;Имя:
                &lt;slot name="username"&gt;&lt;/slot&gt;
            &lt;/div&gt;
            &lt;div&gt;Дата рождения:
                &lt;slot name="birthday"&gt;&lt;/slot&gt;
            &lt;/div&gt;
            &lt;fieldset&gt;
                &lt;legend&gt;Другая информация&lt;/legend&gt;
                &lt;slot&gt;&lt;/slot&gt;
            &lt;/fieldset&gt;
            `;
        }
    });</code>
<code class="language-html">&lt;/script&gt;

&lt;user-card&gt;
    &lt;div&gt;Я люблю плавать.&lt;/div&gt;
    &lt;span slot="username"&gt;Иван Иванов&lt;/span&gt;
    &lt;span slot="birthday"&gt;01.01.2001&lt;/span&gt;
    &lt;div&gt;... И играть в волейбол!&lt;/div&gt;
&lt;/user-card&gt;</code></pre>
        <script>
            customElements.define('user-card-with-default-slot', class extends HTMLElement {
                connectedCallback() {
                    this.attachShadow({mode: 'open'});
                    this.shadowRoot.innerHTML = `
                    <div style="margin: 0.5rem; border: 3px solid var(--border-color-grey); width: max-content; padding: 0.5rem; border-radius: 0.5rem">
                        <div>Имя:
                            <slot name="username"></slot>
                        </div>
                        <div>Дата рождения:
                            <slot name="birthday"></slot>
                        </div>
                        <fieldset style="border: 3px solid var(--border-color-grey); margin-top: 0.5rem">
                            <legend>Другая информация</legend>
                            <slot></slot>
                        </fieldset>
                    </div>
                    `;
                }
            });
        </script>
        <user-card-with-default-slot>
            <div>Я люблю плавать.</div>
            <span slot="username">Иван Иванов</span>
            <span slot="birthday">01.01.2001</span>
            <div>... И играть в волейбол.</div>
        </user-card-with-default-slot>
        <p>Все содержимое обычного дерева, не добавленное в слоты, попало в <code>&lt;fieldset&gt;</code> «Другая информация».</p>
        <p>Элементы добавляются в слот по очереди, один за другим, поэтому оба элемента данных, которые не были
        добавлены в слоты, попадают в слот по умолчанию.</p>
        <p>Развернутое DOM-дерево выглядит так:</p>
<pre><code class="language-html">&lt;user-card&gt;
    #shadow-root
        &lt;div&gt;Имя:
            &lt;slot name="username"&gt;
                &lt;span slot="username"&gt;Иван Иванов&lt;/span&gt;
            &lt;/slot&gt;
        &lt;/div&gt;
        &lt;div&gt;Дата рождения:
            &lt;slot name="birthday"&gt;
                &lt;span slot="birthday"&gt;01.01.2001&lt;/span&gt;
            &lt;/slot&gt;
        &lt;/div&gt;
        &lt;fieldset&gt;
            &lt;legend&gt;Другая информация&lt;/legend&gt;
            &lt;slot&gt;
                &lt;div&gt;Я люблю плавать.&lt;/div&gt;
                &lt;div&gt;... И играть в волейбол!&lt;/div&gt;
            &lt;/slot&gt;
        &lt;/fieldset&gt;
&lt;/user-card&gt;</code></pre>
    </article>

    <article>
        <h2>Пример меню</h2>
        <p>Давайте вернемся к меню <code>&lt;custom-menu&gt;</code>, упомянутому в начале главы.</p>
        <p>Мы можем использовать слоты для распределения элементов.</p>
        <p>Вот разметка для меню <code>&lt;custom-menu&gt;</code>:</p>
<pre><code class="language-html">&lt;custom-menu&gt;
    &lt;span slot="title"&gt;Сладости&lt;/span&gt;
    &lt;li slot="item"&gt;Леденцы&lt;/li&gt;
    &lt;li slot="item"&gt;Фруктовые тосты&lt;/li&gt;
    &lt;li slot="item"&gt;Кексы&lt;/li&gt;
&lt;/custom-menu&gt;</code></pre>
        <p>Шаблон теневого DOM-дерева с правильными слотами:</p>
<pre><code class="language-html">&lt;template id="tmpl"&gt;
    &lt;style&gt; /* Стили меню */ &lt;/style&gt;
    &lt;div class="menu"&gt;
        &lt;slot name="title"&gt;&lt;/slot&gt;
        &lt;ul&gt;&lt;slot name="item"&gt;&lt;/slot&gt;&lt;/ul&gt;
    &lt;/div&gt;
&lt;/template&gt;</code></pre>
        <ol>
            <li>
                <p><code>&lt;span slot="title"&gt;</code> попадает в <code>&lt;slot name="title"&gt;</code>.</p>
            </li>
            <li>
                <p>В шаблоне много элементов <code>&lt;li slot="item"&gt;</code>, но только один слот
                <code>&lt;slot name="item"&gt;</code>. Поэтому все такие <code>&lt;li slot="item"&gt;</code>
                добавляются в <code>&lt;slot name="item"&gt;</code> один за другим, формируя список.</p>
            </li>
        </ol>
        <p>Развернутое DOM-дерево становится таким:</p>
<pre><code class="language-html">&lt;custom-menu&gt;
    #shadow-root
        &lt;style&gt; /* Стили меню */ &lt;/style&gt;
        &lt;div class="menu"&gt;
            &lt;slot name="title"&gt;
                &lt;span slot="title"&gt;Сладости&lt;/span&gt;
            &lt;/slot&gt;
            &lt;ul&gt;
                &lt;slot name="item"&gt;
                    &lt;li slot="item"&gt;Леденцы&lt;/li&gt;
                    &lt;li slot="item"&gt;Фруктовые тосты&lt;/li&gt;
                    &lt;li slot="item"&gt;Кексы&lt;/li&gt;
                &lt;/slot&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
&lt;/custom-menu&gt;</code></pre>
        <p>Можно заметить, что в валидном DOM-дереве тег <code>&lt;li&gt;</code> должен быть прямым потомком
        тега <code>&lt;ul&gt;</code>. Но это развернутый DOM, который описывает то, как компонент отображается,
        в нем такая ситуация нормальна.</p>
        <p>Осталось только добавить обработчик <code>click</code> для открытия и закрытия списка, и меню
        <code>&lt;custom-menu&gt;</code> готово:</p>
<pre><code class="language-javascript">customElements.define('custom-menu', class extends HTMLElement {
    connectedCallback() {
        this.attachShadow({mode: 'open'});

        // tmpl - шаблон для теневого DOM-дерева (выше)
        this.shadowRoot.append(tmpl.content.cloneNode(true));

        // Мы не можем выбирать узлы светлого DOM, поэтому обработаем клики на слоте
        this.shadowRoot.querySelector('slot[name="title"]).onclick = () => {
            // Открыть/закрыть меню
            this.shadowRoot.querySelector('.menu').classList.toggle('closed');
        };
    }
});</code></pre>
        <template>
            <style>
                .menu {
                    margin: 0.5rem;
                    border: 3px solid var(--border-color-grey);
                    width: max-content;
                    padding: 0 0.5rem 0.5rem 0.5rem;
                    border-radius: 0.5rem;
                    height: max-content;
                    overflow: hidden;
                }

                .menu.closed {
                    height: 2ch;
                }

                slot[name='title'] {
                    cursor: pointer;
                    font-weight: bold;
                }

                slot[name='title']:before {
                    content: '📁';
                }

                ul {
                    margin: 0;
                }
            </style>
            <div class="menu">
                <slot name="title"></slot>
                <ul>
                    <slot name="item"></slot>
                </ul>
            </div>
        </template>

        <script>
            customElements.define('custom-menu', class extends HTMLElement {
                connectedCallback() {
                    this.attachShadow({mode: 'open'});

                    this.shadowRoot.append(document.querySelector('template').content.cloneNode(true));

                    this.shadowRoot.querySelector('slot[name="title"]').addEventListener('click', () => {
                        this.shadowRoot.querySelector('.menu').classList.toggle('closed');
                        this.shadowRoot.querySelector('.menu').scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    });
                }
            });
        </script>

        <custom-menu>
            <span slot="title">Сладости</span>
            <li slot="item">Леденцы</li>
            <li slot="item">Фруктовые тосты</li>
            <li slot="item">Кексы</li>
        </custom-menu>
        <p>Конечно, мы можем расширить функционал меню, добавив события, методы и т.д.</p>
    </article>

    <article>
        <h2>Обновление слотов</h2>
        <p>Что если внешний код хочет динамически добавить или удалить пункты меню?</p>
        <p><b>Браузер наблюдает за слотами и обновляет отображение при добавлении или удалении элементов в слотах.</b></p>
        <p>Также, поскольку узлы светлого DOM-дерева не копируются, а только отображаются в слотах, изменения внутри
        них сразу же становятся видны.</p>
        <p>Таким образом, нам ничего не нужно делать для обновления отображения. Но если код компонента хочет
        узнать об изменениях в слотах, можно использовать событие <code>slotchange</code>.</p>
        <p>Например, здесь пункт меню вставляется динамически через 1 секунду, и заголовок меняется через 2 секунды:</p>
<pre><code class="language-html">&lt;custom-menu id="menu"&gt;
    &lt;span slot="title"&gt;Сладости&lt;/span&gt;
&lt;/custom-menu&gt;

&lt;script&gt;</code>
    <code class="language-javascript">customElements.define('custom-menu', class extends HTMLElement {
        connectedCallback() {
            this.attachShadow({mode: 'open'});
            this.shadowRoot.innerHTML = `
                &lt;div class="menu"&gt;
                    &lt;slot name="title"&gt;&lt;/slot&gt;
                    &lt;ul&gt;
                        &lt;slot name="item"&gt;&lt;/slot&gt;
                    &lt;/ul&gt;
                &lt;/div&gt;
            `;

            // shadowRoot не может иметь обработчиков событий, поэтому используем первый потомок
            this.shadowRoot.firstElementChild.addEventListener('slotchange', event => alert("slotchange: " + event.target.name));
        }
    });

    setTimeout(() => {
        menu.insertAdjacentHTML('beforeend', '&lt;li slot="item"&gt;Леденцы&lt;/li&gt;');
    }, 1000);

    setTimeout(() => {
        menu.querySelector('[slot="title"]').innerHTML = 'Новое меню';
    }, 2000);</code>
<code class="language-html">&lt;/script&gt;</code></pre>
        <div style="margin: 0.5rem">
            <button>Запустить пример</button>
        </div>
        <script>
            document.currentScript.previousElementSibling.firstElementChild.addEventListener('click', function(event) {
                while (event.target.parentElement.children.length > 1) {
                    event.target.parentElement.lastElementChild.remove();
                }
                event.target.parentElement.insertAdjacentHTML('beforeend',
                    '<custom-menu><span slot="title">Сладости</span></custom-menu>');

                event.target.nextElementSibling.shadowRoot.querySelector('.menu').addEventListener('slotchange', (event) => {
                    alert(`slotchange: ${event.target.name}`);
                });

                setTimeout(() => event.target.nextElementSibling.insertAdjacentHTML('beforeend',
                '<li slot="item">Леденцы</li>'), 1000);

                setTimeout(() => event.target.nextElementSibling.querySelector('[slot="title"]').innerHTML = 'Новое меню', 5000);
            });
        </script>
        <p>Отображение меню обновляется каждый раз без нашего вмешательства.</p>
        <p>Здесь есть два события <code>slotchange</code>:</p>
        <ol>
            <li>
                <p>При инициализации:</p>
                <p><code>slotchange: title</code> запускается сразу же, как только <code>slot="title"</code> из обычного
                дерева попадает в соответствующий слот.</p>
            </li>
            <li>
                <p>Через 1 секунду:</p>
                <p><code>slotchange: item</code> запускается, когда добавляется новый элемент <code>&lt;li slot="item&gt;</code>.</p>
            </li>
        </ol>
        <p>Обратите внимание, что событие <code>slotchange</code> не запускается через 2 секунды, когда меняется
        контент <code>slot="title"</code>. Это происходит потому, что сам слот не меняется. Мы изменяем содержимое элемента,
        который находится в слоте, а это совсем другое.</p>
        <p>Если мы хотим отслеживать внутренние изменения обычного DOM-дерева из JavaScript, можно также использовать
        более обобщенный механизм:
        <a target="_blank" href="../../Браузер.%20Документ,%20события,%20интерфейсы/6.%20Разное/1.%20MutationObserver.%20Наблюдатель%20за%20изменениями/index.html">MutationObserver</a>.</p>
    </article>

    <article>
        <h2>API слотов</h2>
        <p>И, наконец, давайте поговорим о методах JavaScript, связанных со слотами.</p>
        <p>Как мы видели раньше, JavaScript смотрит на «реальный», а не развернутый DOM. Но если у теневого дерева
        стоит <code>{mode: 'open'}</code>, то мы можем выяснить какие элементы находятся в слоте, и наоборот,
        определить слот по элементу, который в нем находится:</p>
        <ul>
            <li>
                <p><code>node.assignedSlot</code> - возвращает элемент <code>&lt;slot&gt;</code>, в котором находится
                <code>node</code>.</p>
            </li>
            <li>
                <p><code>slot.assignedNodes({flatten: true/false})</code> - DOM-узлы, которые находятся в слоте. Опция
                <code>flatten</code> имеет значение по умолчанию <code>false</code>. Если явно изменить значение на
                <code>true</code>, она просматривает развернутый DOM глубже и возвращает вложенные слоты, если есть
                вложенные компоненты, и резервный контент, если в слоте нет узлов.</p>
            </li>
            <li>
                <p><code>slot.assignedElements({flatten: true/false})</code> - DOM-элементы, которые находятся в слоте
                (то же самое, что выше, но только узлы-элементы).</p>
            </li>
        </ul>
        <p>Эти методы можно использовать не только для отображения содержимого, которое находится в слотах, но и для
        его отслеживания в JavaScript.</p>
        <p>Например, если компонент <code>&lt;custom-menu&gt;</code> хочет знать что он показывает, он может отследить
        событие <code>slotchange</code> и получить пункты меню из <code>slot.assignedElements</code>:</p>
<pre><code class="language-html">&lt;custom-menu id="menu"&gt;
    &lt;span slot="title"&gt;Сладости&lt;/span&gt;
    &lt;li slot="item"&gt;Леденцы&lt;/li&gt;
    &lt;li slot="item"&gt;Фруктовые тосты&lt;/li&gt;
&lt;/custom-menu&gt;

&lt;script&gt;</code>
    <code class="language-javascript">customElements.define('custom-menu', class extends HTMLElement {
        constructor() {
            this.items = [];
        }

        connectedCallback() {
            this.attachShadow({mode: 'open'});
            this.shadowRoot.innerHTML = `
            &lt;div class="menu"&gt;
                &lt;slot name="title"&gt;&lt;/slot&gt;
                &lt;ul&gt;
                    &lt;slot name="item"&gt;&lt;/slot&gt;
                &lt;/ul&gt;
            &lt;/div&gt;`;

            // Слотовый элемент добавляется/удаляется/заменяется
            this.shadowRoot.firstElementChild.addEventListener('slotchange', (event) => {
                let slot = event.target;
                if (slot.name === 'item') {
                    this.items = slot.assignedElements().map(element => element.textContent);
                    alert(`Items: ${this.items}`);
                }
            });
        }
    });

    // Пункты меню обновятся через 1 секунду
    setTimeout(() => {
        menu.insertAdjacentHTML('beforeend', '&lt;li slot="item"&gt;Кексы&lt;/li&gt;');
    }, 1000);</code>
<code class="language-html">&lt;/script&gt;</code></pre>
        <div style="margin: 0.5rem">
            <button>Запустить пример</button>
        </div>
        <script>
            document.currentScript.previousElementSibling.firstElementChild.addEventListener('click', function(event) {
                while (event.target.parentElement.children.length > 1) {
                    event.target.parentElement.lastElementChild.remove();
                }

                event.target.parentElement.insertAdjacentHTML('beforeend',
                '<custom-menu><span slot="title">Сладости</span><li slot="item">Леденцы</li><li slot="item">Фруктовые тосты</li></custom-menu>');

                console.log(event.target.parentElement.lastElementChild.shadowRoot);
                event.target.parentElement.lastElementChild.shadowRoot.querySelector('.menu').addEventListener('slotchange', (event) => {
                    let slot = event.target;

                    if (slot.name === 'item') {
                        let items = slot.assignedElements().map(element => element.textContent);
                        alert(`Items: ${items}`);
                    }
                 });

                setTimeout(() => {
                    event.target.parentElement.lastElementChild.insertAdjacentHTML('beforeend', '<li slot="item">Кексы</li>');
                }, 3000);
            });
        </script>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Обычно, если у элемента есть теневое дерево, то содержимое обычного, светлого DOM не показывается.
        Слоты позволяют показать элементы светлого DOM на заданных местах в теневом DOM.</p>
        <p>Существует два вида слотов:</p>
        <ul>
            <li>
                <p>Именованные слоты: <code>&lt;slot name="X"&gt;...&lt;/slot&gt;</code> - получают элементы светлого
                DOM с <code>slot="X"</code>.</p>
            </li>
            <li>
                <p>Слот по умолчанию: первый <code>&lt;slot&gt;</code> без имени (последующие неименованные слоты
                игнорируются) - показывает элементы элементов светлого дерева, которые не находятся в других слотах.</p>
            </li>
            <li>
                <p>Если одному слоту назначено несколько элементов, они добавляются один за другим.</p>
            </li>
            <li>
                <p>Содержимое элемента <code>&lt;slot&gt;</code> используется как резервное. Оно отображается, если в слоте
                нет элементов из светлого дерева.</p>
            </li>
        </ul>
        <p>Процесс отображения элементов внутри слота называется «композицией». В результате композиции строится
        «развернутый DOM».</p>
        <p>При композиции не происходит перемещения узлов - с точки зрения JavaScript, DOM остается прежним.</p>
        <p>JavaScript может получить доступ к слотам с помощью следующих методов:</p>
        <ul>
            <li>
                <p><code>slot.assignedNodes()</code>, <code>slot.assignedElements()</code> - возвращает узлы/элементы,
                которые находятся внутри <code>slot</code>.</p>
            </li>
            <li>
                <p><code>node.assignedSlot</code> - обратный метод, возвращает слот по узлу.</p>
            </li>
        </ul>
        <p>Если мы хотим знать что показываем, мы можем отследить контент слота следующими способами:</p>
        <ul>
            <li>
                <p>Событие <code>slotchange</code> запускается, когда слот наполняется контентом в первый раз, и при
                каждой операции добавления/удаления/замещения элемента в слоте, за исключением его потомков. Сам слот
                будет <code>event.target</code>.</p>
            </li>
            <li>
                <p><a target="_blank" href="../../Браузер.%20Документ,%20события,%20интерфейсы/6.%20Разное/1.%20MutationObserver.%20Наблюдатель%20за%20изменениями/index.html">MutationObserver</a> для
                более глубокого просмотра содержимого элемента в слоте и отслеживания изменений в нем.</p>
            </li>
        </ul>
        <p>Теперь когда мы научились показывать элементы светлого DOM в теневом DOM, давайте посмотрим как их правильно
        стилизовать. Основное правило звучит так: теневые элементы стилизуются внутри, а обычные элементы - снаружи.
        Однако, есть заметные исключения.</p>
        <p>Мы рассмотрим их подробно в следующей главе.</p>
    </article>
</body>
</html>