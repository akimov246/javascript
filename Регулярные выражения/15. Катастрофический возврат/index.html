<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Катастрофический возврат</title>
    <link href="../../style.css" rel="stylesheet">
    <script defer src="../../highlightElements.js"></script>
</head>
<body>
    <article>
        <h2>Катастрофический возврат</h2>
        <p>Некоторые регулярные выражения, простые с виду, могут выполняться очень долго, и даже «подвешивать»
        интерпретатор JavaScript.</p>
        <p>Рано или поздно с этим сталкивается любой разработчик, потому что нечаянно создать такое регулярное выражение -
        проще простого.</p>
        <p>Типичный симптом: регулярное выражение обычно работает нормально, но иногда, с некоторыми строками,
        «подвешивает» интерпретатор и потребляет 100% процессора.</p>
        <p>Как правило, веб-браузер при этом предлагает «убить» скрипт и перезапустить зависшую страницу. Явно плохая
        ситуация.</p>
        <p>Ну а для серверного JavaScript это может стать серьезной уязвимостью, если регулярные выражения используются
        для обработки пользовательских данных.</p>
    </article>

    <article>
        <h2>Пример</h2>
        <p>Допустим, у нас есть строка, и мы хотим проверить, что она состоит из слов <code>\w+</code>, после каждого
        слова может быть пробел <code>\s?</code>.</p>
        <p>Используем регулярное выражение <code>^(\w+\s?)*$</code>, которое задает 0 или более таких слов.</p>
        <p>Проверим, чтобы убедиться, что оно работает:</p>
<pre class="executable"><code class="language-javascript">let regexp = /^(\w+\s?)*$/;

alert(regexp.test('A good string')); // true
alert(regexp.test('Bad characters: $@#')); // false</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                        event.target.querySelector('button').addEventListener('click', function() {
                            let regexp = /^(\w+\s?)*$/;

                            alert(regexp.test('A good string'));
                            alert(regexp.test('Bad characters: $@#'));
                        });
                    });
        </script>
        <p>Результат верный. Однако, на некоторых строках оно выполняется очень долго. Так долго, что интерпретатор
        JavaScript «зависает» с потреблением 100% процессора.</p>
        <p>Если вы запустите пример ниже, то, скорее всего, ничего не увидите, так как JavaScript «подвиснет». В
        браузере он перестанет реагировать на другие события, и, скорее всего, понадобится перезагрузить страницу,
        так что осторожно с этим:</p>
<pre class="executable"><code class="language-javascript">let regexp = /^(\w+\s?)*$/;
let str = 'An input string that takes a long time or even makes this regexp to hang!';

// Этот поиск будет выполняться очень, очень долго
alert(regexp.test(str));</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                        event.target.querySelector('button').addEventListener('click', function() {
                            let regexp = /^(\w+\s?)*$/;
                            let str = 'An input string that takes a long time or even makes this regexp to hang!';
                            alert(regexp.test(str));
                        });
                    });
        </script>
        <p>Некоторые движки регулярных выражений могут справиться с таким поиском, но большинство из них - нет.</p>
    </article>

    <article>
        <h2>Упрощенный пример</h2>
        <p>В чем же дело? Почему регулярное выражение «зависает»?</p>
        <p>Чтобы это понять, упростим пример: уберем из него пробелы <code>\s?</code>. Получится <code>^(\w+)*$</code>.</p>
        <p>И, для большей наглядности, заменим <code>\w</code> на <code>\d</code>. Получившееся регулярное выражение
        тоже будет «зависать», например:</p>
<pre class="executable"><code class="language-javascript">let regexp = /^(\d+)*$/;

let str = '012345678901234567890123456789!';

// Этот поиск будет выполняться очень, очень долго
alert(regexp.test(str));</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                        event.target.querySelector('button').addEventListener('click', function() {
                            let regexp = /^(\d+)*$/;
                            let str = '012345678901234567890123456789!';
                            alert(regexp.test(str));
                        });
                    });
        </script>
        <p>В чем же дело, что не так с регулярным выражением?</p>
        <p>Внимательный читатель, посмотрев на <code>(\d+)*</code>, наверняка удивится, ведь оно какое-то странное.
        Квантификатор <code>*</code> здесь выглядит лишним. Если хочется найти число, то с тем же успехом можно искать
        <code>\d+</code>.</p>
        <p>Действительно, это регулярное выражение носит искусственный характер, но, разобравшись с ним, мы поймем
        и практический пример, данный выше. Причина их медленной работы одинакова. Поэтому оставим как есть.</p>
        <p>Что же происходит во время поиска <code>^(\d+)*$</code> в строке <code>123456789!</code> (укоротим для ясности),
        почему все так долго?</p>
        <ol>
            <li>
                <p>Первым делом движок регулярных выражений пытается найти <code>\d+</code>. Плюс <code>+</code>
                является жадным по умолчанию, так что он хватает все цифры, какие может:</p>
<pre><code>\d+.......
(123456789)!</code></pre>
                <p>Затем движок пытается применить квантификатор <code>*</code>, но больше цифр нет, так что звездочка
                ничего не дает.</p>
                <p>Далее по шаблону ожидается конец строки <code>$</code>, а в тексте символ <code>!</code>, так что
                соответствий нет:</p>
<pre><code>           X
\d+........$
(123456789)!</code></pre>
            </li>
            <li>
                <p>Так как соответствий не найдено, то «жадный» квантификатор <code>+</code> уменьшает количество повторений,
                возвращается на один символ назад.</p>
                <p>Теперь <code>\d+</code> - это все цифры, за исключением последней:</p>
<pre><code>\d+.......
(12345678)9!</code></pre>
            </li>
            <li>
                <p>Далее движок снова пытается продолжить поиск, начиная уже с позиции (<code>9</code>).</p>
                <p>Звездочка <code>(\d+)*</code> теперь может быть применена - она дает второе число <code>9</code>:</p>
<pre><code>\d+.......\d+
(12345678)(9)!</code></pre>
                <p>Затем движок ожидает найти <code>$</code>, но это ему не удается, ведь строка оканчивается на <code>!</code>:</p>
<pre><code>             X
\d+.......\d+$
(12345678)(9)!</code></pre>
            </li>
            <li>
                <p>Так как совпадений нет, то поисковый движок продолжает отступать назад. Общее правило таково:
                последний жадный квантификатор уменьшает количество повторений до тех пор, пока это возможно.
                Затем понижается предыдущий «жадный» квантификатор и т.д.</p>
                <p>Перебираются все возможные комбинации. Вот их примеры.</p>
                <p>Когда первое число <code>\d+</code> содержит 7 цифр, а дальше число из 2 цифр:</p>
<pre><code>             X
\d+......\d+.$
(1234567)(89)!</code></pre>
                <p>Когда первое число содержит 7 цифр, а дальше два числа по 1 цифре:</p>
<pre><code>               X
\d+......\d+\d+$
(1234567)(8)(9)!</code></pre>
                <p>Когда первое число содержит 6 цифр, а дальше одно число из 3 цифр:</p>
<pre><code>             X
\d+.....\d+..$
(123456)(789)!</code></pre>
                <p>Когда первое число содержит 6 цифр, а затем два числа:</p>
<pre><code>               X
\d+.....\d+.\d+$
(123456)(78)(9)!</code></pre>
                <p>... И так далее.</p>
            </li>
        </ol>
        <p>Существует много способов как разбить на числа набор цифр <code>123456789</code>. Есть быть точным,
        их <code>2ⁿ-1</code>, где <code>n</code> - длина набора.</p>
        <p>В случае <code>n=20</code> их порядка миллиона, при <code>n=30</code> - еще в тысячу раз больше. На их перебор
        и тратится время.</p>
        <p>Что же делать?</p>
        <p>Может нам стоит использовать «ленивый» режим?</p>
        <p>К сожалению, нет: если мы заменим <code>\d+</code> на <code>\d+?</code>, то регулярное выражение все еще будет
        «зависать». Поменяется только порядок перебора, но не общее количество комбинаций.</p>
        <p>Некоторые движки регулярных выражений содержат хитрые проверки и специальные алгоритмы, которые позволяют
        избежать полного перебора в таких ситуациях или кардинально ускорить его, но не все движки и не всегда.</p>
    </article>

    <article>
        <h2>Назад к словам и строкам</h2>
        <p>В начальном примере, когда мы ищем слова по шаблону <code>^(\w+\s?)*$</code> в строке вида
        <code>An input that hangs!</code>, происходит то же самое.</p>
        <p>Дело в том, что каждое слово может быть представлено как в виде одного <code>\w+</code>, так и нескольких:</p>
<pre><code>(input)
(inpu)(t)
(inp)(u)(t)
(in)(p)(ut)
...</code></pre>
        <p>Человеку очевидно, что совпадения быть не может, так как эта строка заканчивается на восклицательный знак
        <code>!</code>, а по регулярному выражению в конце должен быть символ <code>\w</code> или пробел
        <code>\s</code>. Но движок этого не знает.</p>
        <p>Он перебирает все комбинации того, как регулярное выражение <code>(\w+\s?)*</code> может «захватить»
        каждое слово, включая варианты как с пробелами <code>(\w+\s)*</code>, так и без <code>(\w+)*</code>
        (пробелы <code>\s?</code> ведь не обязательны). Этих вариантов очень много, отсюда и сверхдолгое время выполнения.</p>
    </article>

    <article>
        <h2>Как исправить?</h2>
        <p>Есть два основных подхода как это исправить.</p>
        <p>Первый - уменьшить количество возможных комбинаций.</p>
        <p>Перепишем регулярное выражение так: <code>^(\w+\s)*\w*$</code> - то есть, будем искать любое количество слов
        с пробелом <code>(\w+\s)*</code>, после которого идет (но не обязательно) обычное слово <code>\w*</code>.</p>
        <p>Это регулярное выражение эквивалентно предыдущему (ищет то же самое), и на этот раз все работает:</p>
<pre class="executable"><code class="language-javascript">let regexp = /^(\w+\s)*\w*$/;
let str = 'An input string that takes a long time or even makes this regex to hang!';

alert(regexp.test(str)); // false</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                        event.target.querySelector('button').addEventListener('click', function() {
                            let regexp = /^(\w+\s)*\w*$/;
                            let str = 'An input string that takes a long time or even makes this regex to hang!';
                            alert(regexp.test(str));
                        });
                    });
        </script>
        <p>Почему же проблема исчезла?</p>
        <p>Теперь звездочка <code>*</code> стоит после <code>\w+\s</code> вместо <code>\w+\s?</code>. Стало невозможно
        разбить одно слово на несколько разных <code>\w+</code>. Исчезли и потери времени на перебор таких комбинаций.</p>
        <p>Например, с предыдущим шаблоном <code>(\w+\s?)*</code> слово <code>string</code> могло быть представлено
        как два подряд <code>\w+</code>:</p>
<pre><code>\w+\w+
string</code></pre>
        <p>Предыдущий шаблон из-за необязательности <code>\s</code> допускал варианты <code>\w+</code>, <code>\w+\s</code>,
        <code>\w+\w+</code> и т.п.</p>
        <p>С переписанными шаблоном <code>(\w+\s)*</code>, такое невозможно: может быть <code>\w+\s</code> или
        <code>\w+\s\w+\s</code>, но не <code>\w+\w+</code>. Так что общее количество комбинаций сильно уменьшается.</p>
    </article>

    <article>
        <h2>Запрет возврата</h2>
        <p>Переписывать регулярное выражение не всегда удобно, и не всегда очевидно, как это сделать.</p>
        <p>Альтернативный подход заключается в том, чтобы запретить возврат для квантификатора.</p>
        <p>Движок регулярных выражений проверяет множество вариантов, которые для человека являются очевидно ошибочными.</p>
        <p>Например, в шаблоне <code>(\d+)*$</code> для человека очевидно, что в <code>(\d+)*</code> не нужно «откатывать»
        <code>+</code>. От того, что вместо одного <code>\d+</code> у нас будет два независимых <code>\d+\d+</code>,
        ничего не изменится:</p>
<pre><code>\d+........
(123456789)!

\d+...\d+....
(1234)(56789)!</code></pre>
        <p>Если говорить об изначальном примере <code>^(\w+\s?)*$</code>, то хорошо бы исключить возврат для <code>\w+</code>.
        То есть, для <code>\w+</code> нужно искать только одно слово целиком, максимально возможной длины. Не нужно
        уменьшать количество повторений <code>\w+</code>, пробовать разбить слово на два <code>\w+\w+</code>, и т.п.</p>
        <p>В современных регулярных выражениях для решения этой проблемы придумали захватывающие (possessive)
        квантификаторы, которые такие же как жадные, но не делают возврат (то есть, по сути, они даже проще, чем жадные).</p>
        <p>Также есть «атомарные скобочные группы» - средство, запрещающее возврат внутри скобок.</p>
        <p>К сожалению, в JavaScript они не поддерживаются, но есть другое средство.</p>
    </article>

    <article>
        <h2>Опережающая проверка в помощь!</h2>
        <p>Мы можем исключить возврат с помощью опережающей проверки.</p>
        <p>Шаблон, захватывающий максимальное количество повторений <code>\w</code> без возврата, выглядит так:
        <code>(?=(\w+))\1</code>.</p>
        <p>Расшифруем его:</p>
        <ul>
            <li>
                <p>Опережающая проверка <code>?=</code> ищет максимальное количество <code>\w</code>, доступных с текущей
                позиции.</p>
            </li>
            <li>
                <p>Содержимое скобок вокруг <code>?=...</code> не запоминается движком, поэтому оборачиваем
                <code>\w+</code> внутри в дополнительные скобки, чтобы движок регулярных выражений запомнил их содержимое.</p>
            </li>
            <li>
                <p>... И чтобы далее в шаблоне на него ссылаться обратной ссылкой <code>\1</code>.</p>
            </li>
        </ul>
        <p>То есть, мы смотрим вперед - и если там есть слово <code>\w+</code>, то ищем его же <code>\1</code>.</p>
        <p>Зачем? Все дело в том, что опережающая проверка находит слово <code>\w+</code> целиком, и мы захватываем
        его в шаблоне посредством <code>\1</code>. Поэтому мы реализовали, по сути, захватывающий квантификатор
        <code>+</code>. Такой шаблон захватывает только полностью слово <code>\w+</code>, не его часть.</p>
        <p>Например, в слове <code>JavaScript</code> он не может захватить только <code>Java</code>, и оставить
        <code>Script</code> для совпадения с остатком шаблона.</p>
        <p>Вот, посмотрите, сравнение двух шаблонов:</p>
<pre class="executable"><code class="language-javascript">alert('JavaScript'.match(/\w+Script/)); // JavaScript
alert('JavaScript'.match(/(?=(\w+))\1Script/)); // null</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                        event.target.querySelector('button').addEventListener('click', function() {
                            alert('JavaScript'.match(/\w+Script/));
                            alert('JavaScript'.match(/(?=(\w+))\1Script/));
                        });
                    });
        </script>
        <ol>
            <li>
                <p>В первом варианте <code>\w+</code> сначала забирает слово <code>JavaScript</code> целиком, потом
                <code>+</code> постепенно отступает, чтобы попробовать найти оставшуюся часть шаблона, и в конце
                концов находит (при этом <code>\w+</code> будет соответствовать <code>Java</code>).</p>
            </li>
            <li>
                <p>Во втором варианте <code>(?=(\w+))</code> осуществляет опережающую проверку и видит сразу слово
                <code>JavaScript</code>, которое <code>\1</code> целиком захватывает в совпадение, так что уже нет
                возможности найти <code>Script</code>.</p>
            </li>
        </ol>
        <p>Внутрь <code>(?=(\w+))\1</code> можно вместо <code>\w</code> вставить и более сложное регулярное выражение,
        при поиске которого квантификатор <code>+</code> не должен делать возврат.</p>
        <p>Перепишем исходный пример, используя опережающую проверку для запрета возврата:</p>
<pre class="executable"><code class="language-javascript">let regexp = /^((?=(\w+))\2\s?)*$/;

alert(regexp.test('A good string')); // true

let str = 'An input string that takes a long time or even makes this regex to hang!';

alert(regexp.test(str)) // false, работает и быстро</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                        event.target.querySelector('button').addEventListener('click', function() {
                            let regexp = /^((?=(\w+))\2\s?)*$/;
                            alert(regexp.test('A good string'));
                            let str = 'An input string that takes a long time or even makes this regex to hang!';
                            alert(regexp.test(str));
                        });
                    });
        </script>
        <p>Здесь внутри скобок стоит <code>\2</code> вместо <code>\1</code>, так как есть еще внешние скобки. Чтобы
        избежать путаницы с номерами скобок, можно дать скобкам имя, например, <code>(?&lt;word&gt;\w+)</code>.</p>
<pre class="executable"><code class="language-javascript">// Скобки названы ?&lt;word&gt;, ссылка на них \k&lt;word&gt;
let regexp = /^((?=(?&lt;word&gt;\w+))\k&lt;word&gt;\s?)*$/;

alert(regexp.test('A good string')); // true

let str = 'An input string that takes a long time or even makes this regex to hang!';

alert(regexp.test(str)) // false, работает и быстро</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                event.target.querySelector('button').addEventListener('click', function() {
                    let regexp = /^((?=(?<word>\w+))\k<word>\s?)*$/;
                    alert(regexp.test('A good string'));
                    let str = 'An input string that takes a long time or even makes this regex to hang!';
                    alert(regexp.test(str));
                });
            });
        </script>
        <p>Проблему, которой была посвящена эта глава, называют «катастрофический возврат» (catastrophic backtracking).</p>
        <p>Мы разобрали два способа ее решения:</p>
        <ul>
            <li>
                <p>Уменьшение возможных комбинаций переписыванием шаблона.</p>
            </li>
            <li>
                <p>Запрет возврата.</p>
            </li>
        </ul>
    </article>
</body>
</html>