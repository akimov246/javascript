<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Наборы и диапазоны [...]</title>
    <link href="../../style.css" rel="stylesheet">
    <script defer src="../../highlightElements.js"></script>
</head>
<body>
    <article>
        <h2>Наборы и диапазоны [...]</h2>
        <p>Несколько символов или символьный классов в квадратных скобках <code>[...]</code> означают «искать любой
        символ из заданных».</p>
    </article>

    <article>
        <h2>Наборы</h2>
        <p>Для примера, <code>[eao]</code> означает любой из трех символов: <code>'a'</code>, <code>'e'</code> или
        <code>'o'</code>.</p>
        <p>Это называется <i>набором</i>.</p>
        <p>Наборы могут использоваться в регулярных выражениях вместе с обычными символами, например:</p>
<pre class="executable"><code class="language-javascript">// Найти [т или х], после которых идет "оп"
alert('Топ хоп'.match(/[тх]оп/gi)); // Топ,хоп</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                event.target.querySelector('button').addEventListener('click', function() {
                    alert('Топ хоп'.match(/[тх]оп/gi));
                });
            });
        </script>
        <p>Обратите внимание, что в наборе несколько символов, но в результате он соответствует ровно одному символу.</p>
        <p>Так что этот пример не дает совпадений:</p>
<pre class="executable"><code class="language-javascript">alert('Вуаля'.match(/В[уа]ля/)); // null, нет совпадений</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                event.target.querySelector('button').addEventListener('click', function() {
                    alert('Вуаля'.match(/В[уа]ля/));
                });
            });
        </script>
        <p>Шаблон ищет:</p>
        <ul>
            <li>
                <p><code>В</code>.</p>
            </li>
            <li>
                <p>Затем один из символов <code>[уа]</code>.</p>
            </li>
            <li>
                <p>Потом <code>ля</code>.</p>
            </li>
        </ul>
        <p>В этом случае совпадениями могут быть <code>Вуля</code> или <code>Валя</code>.</p>
    </article>

    <article>
        <h2>Диапазоны</h2>
        <p>Еще квадратные скобки могут содержать <i>диапазоны символов</i>.</p>
        <p>К примеру, <code>[a-z]</code> соответствует символу в диапазоне от <code>a</code> до <code>z</code>, или
        <code>[0-5]</code> - цифра от <code>0</code> до <code>5</code>.</p>
        <p>В приведенном ниже примере мы ищем <code>'x'</code>, за которым следует две цифры или буквы от <code>A</code>
        до <code>F</code>:</p>
<pre class="executable"><code class="language-javascript">alert('Exception 0xAF'.match(/x[0-9A-F][0-9A-F]/g)); // xAF</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                event.target.querySelector('button').addEventListener('click', function() {
                    alert('Exception 0xAF'.match(/x[0-9A-F][0-9A-F]/));
                });
            });
        </script>
        <p>Здесь в <code>[0-9A-F]</code> сразу два диапазона: ищется символ, который либо цифра от <code>0</code>
        до <code>9</code>, либо буква от <code>A</code> до <code>F</code>.</p>
        <p>Если мы хотим найти буквы и в верхнем, и в нижнем регистре, то мы можем добавить еще диапазон <code>a-f</code>:
        <code>[0-9A-Fa-f]</code>. Или поставить у регулярного выражения флаг <code>i</code>.</p>
        <p>Также мы можем использовать символьные классы внутри <code>[...]</code>.</p>
        <p>Например, если мы хотим найти «символ слова» <code>\w</code> или дефис <code>-</code>, то набор будет:
        <code>[\w-]</code>.</p>
        <p>Можем использовать и несколько классов вместе, например, <code>[\s\d]</code> означает «пробельный символ
        или цифра».</p>

        <article class="note">
            <h3>Символьные классы - сокращения для наборов символов</h3>
            <p>Символьные классы - не более чем сокращения для наборов символов.</p>
            <p>Например:</p>
            <ul>
                <li>
                    <p><b>\d</b> - то же самое, что и <code>[0-9]</code>.</p>
                </li>
                <li>
                    <p><b>\w</b> - то же самое, что и <code>[a-zA-z0-9_]</code>.</p>
                </li>
                <li>
                    <p><b>\s</b> - то же самое, что и <code>[\t\n\v\f\r ]</code>, плюс несколько редких пробельных
                    символов Юникода.</p>
                </li>
            </ul>
        </article>

    </article>

    <article>
        <h2>Пример: многоязычный аналог \w</h2>
        <p>Так как символьный класс <code>\w</code> является всего лишь сокращением для <code>[a-zA-Z0-9_]</code>,
        он не найдет китайские иероглифы, кириллические буквы и т.п.</p>
        <p>Давайте сделаем более универсальный шаблон, который ищет символы, используемые в словах, для любого языка.
        Это очень легко с Юникод-символами: <code>[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]</code>.</p>
        <p>Расшифруем его. По аналогии с классом <code>\w</code>, мы сделаем свой набор, который включает в себя
        символы со следующими Юникодными свойствами:</p>
        <ul>
            <li>
                <p><code>Alphabetic</code> (<code>Alpha</code>) - для букв.</p>
            </li>
            <li>
                <p><code>Mark</code> (<code>M</code>) - для акцентов.</p>
            </li>
            <li>
                <p><code>Decimal_Number</code> (<code>Nd</code>) - для цифр.</p>
            </li>
            <li>
                <p><code>Connector_Punctuation</code> (<code>Pc</code>) - для символа подчеркивания <code>_</code>
                и подобных ему.</p>
            </li>
            <li>
                <p><code>Join_Control</code> (<code>Join_C</code>) - два специальных кода <code>200c</code> и
                <code>200d</code>, используемые в лигатурах, например, арабских.</p>
            </li>
        </ul>
        <p>Пример использования:</p>
<pre class="executable"><code class="language-javascript">let regexp = /[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]/gu;

let str = `Hi 你好 12`;

// Найдены все буквы и цифры
alert(str.match(regexp)); // H,i,你,好,1,2</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                event.target.querySelector('button').addEventListener('click', function() {
                    let regexp = /[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]/gu;

                    let str = `Hi 你好 12`;

                    alert(str.match(regexp));
                });
            });
        </script>
        <p>Конечно, этот шаблон можно адаптировать: добавить Юникодные свойства или убрать. Более подробно о них было
        рассказано в главе <a target="_blank" href="../3.%20Юникод.%20флаг%20«u»%20и%20класс%20p%7B...%7D/index.html">Юникод: флаг «u» и класс \p{...}</a>.</p>

        <article class="warning">
            <h3>Юникодные свойства не работают в некоторых старых браузерах</h3>
            <p>Поддержка Юникодных свойств <code>\p{...}</code> была добавлена в Edge и Firefox относительно недавно.
            Если нужно реализовать поддержку <code>\p{...}</code> для устаревших версий этих браузеров, можно использовать
            библиотеку <code>XRegExp</code>.</p>
            <p>Или же использовать диапазоны символов в интересующем нас языке, например, <code>[а-я]</code> для
            кириллицы.</p>
        </article>

    </article>

    <article>
        <h2>Экранирование внутри [...]</h2>
        <p>Обычно, когда мы хотим найти специальный символ, нам нужно экранировать его, например, <code>\.</code>. А если
        нам нужна обратная косая черта, тогда используем <code>\\</code> и т.п.</p>
        <p>В квадратных скобках большинство специальных символов можно использовать без экранирования:</p>
        <ul>
            <li>
                <p>Символы <code>. + ( )</code> не нужно экранировать никогда.</p>
            </li>
            <li>
                <p>Тире <code>-</code> не надо экранировать в начале или в конце (где оно не задает диапазон).</p>
            </li>
            <li>
                <p>Символ каретки <code>^</code> нужно экранировать только в начале (где он означает исключение).</p>
            </li>
            <li>
                <p>Закрывающую квадратную скобку <code>]</code>, если нужен именно такой символ, экранировать нужно.</p>
            </li>
        </ul>
        <p>Другими словами, разрешены без экранирования все специальные символы, кроме случаев, когда они означают
        что-то особое в наборах.</p>
        <p>Точка <code>.</code> внутри квадратных скобок - просто точка. Шаблон <code>[.,]</code> будет искать один из
        символов: точку или запятую.</p>
        <p>В приведенном ниже примере регулярное выражение <code>[-().^+]</code> ищет один из символов <code>-().^+</code>:</p>
<pre class="executable"><code class="language-javascript">// Нет необходимости в экранировании
let regexp = /[-().^+]/g;

alert('1 + 2 - 3'.match(regexp)); // +,-</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                event.target.querySelector('button').addEventListener('click', function() {
                    let regexp = /[-().^+]/g;
                    alert('1 + 2 - 3'.match(regexp));
                });
            });
        </script>
        <p>... Впрочем, если вы решите экранировать «на всякий случай», то не будет никакого вреда:</p>
<pre class="executable"><code class="language-javascript">// Экранирование всех возможных символов
let regexp = /[\-\(\)\.\^\+]/g;

alert('1 + 2 - 3'.match(regexp)); // +,-</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                event.target.querySelector('button').addEventListener('click', function() {
                    let regexp = /[\-\(\)\.\^\+]/g;
                    alert('1 + 2 - 3'.match(regexp));
                });
            });
        </script>
    </article>

    <article>
        <h2>Наборы и флаг «u»</h2>
        <p>Если в наборе есть суррогатные пары, для корректной работы обязательно нужен флаг <code>u</code>.</p>
        <p>Например, давайте попробуем найти шаблон <code>[𝒳𝒴]</code> в строке <code>𝒳</code>:</p>
<pre class="executable"><code class="language-javascript">alert('𝒳'.match([𝒳𝒴])); // Покажет странный символ, что-то типа �
// (поиск был произведен неправильно, вернулась только половина символа)</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                event.target.querySelector('button').addEventListener('click', function() {
                    alert('𝒳'.match(/[𝒳𝒴]/));
                });
            });
        </script>
        <p>Результат неверный, потому что по умолчанию регулярные выражения «не знают» о существовании суррогатных пар.</p>
        <p>Движок регулярных выражений думает, что <code>[𝒳𝒴]</code> - это не два, а четыре символа:</p>
        <ol>
            <li>
                <p>Левая половина от <code>𝒳</code>.</p>
            </li>
            <li>
                <p>Правая половина от <code>𝒳</code>.</p>
            </li>
            <li>
                <p>Левая половина от <code>𝒴</code>.</p>
            </li>
            <li>
                <p>Правая половина от <code>𝒴</code>.</p>
            </li>
        </ol>
        <p>Мы даже можем вывести их коды:</p>
<pre class="executable"><code class="language-javascript">for (let = 0; i < '𝒳𝒴'.length; i++) {
    alert('𝒳𝒴'.charCodeAt(i)); // 55349, 56499, 55349, 56500
};</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                event.target.querySelector('button').addEventListener('click', function() {
                    for (let i = 0; i < '𝒳𝒴'.length; i++) {
                        alert('𝒳𝒴'.charCodeAt(i));
                    }
                });
            });
        </script>
        <p>То есть в нашем примере выше ищется и выводится только левая половина от <code>𝒳</code>.</p>
        <p>Если добавить флаг <code>u</code>, то все будет в порядке:</p>
<pre class="executable"><code class="language-javascript">alert('𝒳'.match(/[𝒳𝒴]/u)); // 𝒳</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                event.target.querySelector('button').addEventListener('click', function() {
                    alert('𝒳'.match(/[𝒳𝒴]/u));
                });
            });
        </script>
        <p>Аналогичная ситуация произойдет при попытке искать диапазон: <code>[𝒳-𝒴]</code>.</p>
        <p>Если мы забудем флаг <code>u</code>, то можем нечаянно получить ошибку:</p>
<pre class="executable"><code class="language-javascript">'𝒳'.match(/[𝒳-𝒴]/); // Error: Invalid regular expression</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                event.target.querySelector('button').addEventListener('click', function() {
                    try {
                        '𝒳'.match(new RegExp('[𝒳-𝒴]'));
                    } catch(error) {
                        alert(error);
                    }
                });
            });
        </script>
        <p>Причина в том, что без флага <code>u</code> суррогатные пары воспринимаются как два символа, так что
        <code>[𝒳-𝒴]</code> воспринимается как <code>[&lt;55349&gt;&lt;56499&gt;-&lt;55349&gt;&lt;56500&gt;]</code>
        (каждая суррогатная пара заменена на коды). Теперь уже отлично видно, что диапазон <code>56499-55349</code>
        некорректен: его левая граница больше правой, это и есть формальная причина ошибки.</p>
        <p>При использовании флага <code>u</code> шаблон будет работать правильно:</p>
<pre class="executable"><code class="language-javascript">// Поищем символы от 𝒳 до 𝒵
alert('𝒴'.match(/[𝒳-𝒵]/u)); // 𝒴</code></pre>
        <script>
            document.currentScript.previousElementSibling.addEventListener('buttonAdded', function(event) {
                event.target.querySelector('button').addEventListener('click', function() {
                    alert('𝒴'.match(/[𝒳-𝒵]/u));
                });
            });
        </script>
    </article>
</body>
</html>