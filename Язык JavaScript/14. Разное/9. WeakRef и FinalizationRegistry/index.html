<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WeakRef и FinalizationRegistry</title>
    <link href="../../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>WeakRef и FinalizationRegistry</h2>
        <p>Вспоминая основную концепцию <i>принципа достижимости</i> из главы «Сборка мусора», мы можем отметить,
        что движок JavaScript гарантированно хранит в памяти значения, которые доступны или используются.</p>
        <p>Например:</p>
        <code>
            // В переменной user находится сильная ссылка на объект<br>
            let user = {name: 'John'};<br>
            <br>
            // Перезапишем значение переменной user<br>
            user = null;<br>
            <br>
            // Ссылка теряется и объект удален из памяти
        </code>
        <p>Или же похожий, но немного усложненный код с двумя сильными ссылками:</p>
        <code>
            // В переменной user находится сильная ссылка на объект<br>
            let user = {name: 'John'};<br>
            <br>
            // Скопировали сильную ссылку на объект в переменную admin<br>
            let admin = user;<br>
            <br>
            // Перезапишем значение переменной user<br>
            user = null;<br>
            <br>
            // Объект все еще доступен через переменную admin
        </code>
        <p>Объект <code>{name: 'John'}</code> удалился бы из памяти только в случае отсутствия сильных ссылок на него
        (если бы мы также перезаписали значение переменной <code>admin</code>).</p>
        <p>В JavaScript существует концепция под названием <code>WeakRef</code>, которая ведет себя немного иначе
        в этом случае.</p>

        <article class="note">
            <h2>Термины: «Сильная ссылка», «Слабая ссылка»</h2>
            <p><b>Сильная ссылка</b> - это ссылка на объект или значение, которая предотвращает их удаление сборщиком
            мусора. При этом, сохраняя объект или значение в памяти, на которые она указывает.</p>
            <p>Это означает, что объект или значение остаются в памяти и не удаляются сборщиком мусора до тех пор,
            пока на них есть активные сильные ссылки.</p>
            <p>В JavaScript стандартные ссылки на объекты являются <i>сильными</i> ссылками. Например:</p>
            <code>
                // Переменная user содержит сильную ссылку на этот объект<br>
                let user = {name: 'John'};
            </code>
            <p><b>Слабая ссылка</b> - это ссылка на объект или значение, которая <i>не</i> предотвращает их удаление
            сборщиком мусора. Объект или значение могут быть удалены сборщиком мусора в случае, если на них существуют
            только слабые ссылки.</p>
        </article>
    </article>

    <article>
        <h2>WeakRef</h2>

        <article class="warning">
            <h2>Предостережение</h2>
            <p>Прежде чем мы перейдем к изучению, стоит отметить, что правильное применение структур, о которых
            пойдет речь в этой статье, требует очень тщательного обдумывания, и по возможности их использования
            лучше избегать.</p>
        </article>

        <p><code>WeakRef</code> - это объект, содержащий слабую ссылку на другой объект, называемый <code>target</code>
        или <code>referent</code>.</p>
        <p>Особенность <code>WeakRef</code> заключается в том, что он не препятствует сборщику мусора удалять свой
        объект-референт. Другими словами, он просто не удерживает его «в живых».</p>
        <p>Теперь давайте возьмем переменную <code>user</code> в качестве «референта» и создадим слабую ссылку от нее
        к переменной <code>admin</code>. Чтобы создать слабую ссылку, необходимо использовать конструктор
        <code>WeakRef</code>, передав целевой объект (объект, на который вы хотите создать слабую ссылку).</p>
        <p>В нашем случае - это переменная <code>user</code>:</p>
        <code>
            // В переменной user находится сильная ссылка на объект<br>
            let user = {name: 'John'};<br>
            <br>
            // В переменной admin находится слабая ссылка на объект<br>
            let admin = new WeakRef(user);
        </code>
        <p>Затем, в какой-то момент, мы перестаем использовать переменную <code>user</code> - она перезаписывается,
        выходит из области видимости и т.д. при этом сохраняя экземпляр <code>WeakRef</code> в переменной
        <code>admin</code>:</p>
        <code>
            // Перезапишем значение переменной user<br>
            user = null;
        </code>
        <p>Слабой ссылки на объект не достаточно, чтобы сохранить его «в живых». Когда единственными оставшимися ссылками
        на объект-референт являются слабые ссылки, сборщик мусора вправе уничтожить этот объект и использовать
        его память для чего-то другого.</p>
        <p>Однако до тех пор, пока объект физически не уничтожен, слабая ссылка может вернуть его, даже если на данный
        объект больше нет сильных ссылок. То есть наш объект становится своеобразным «котом Шредингера» - мы не можем
        знать точно, «жив» он или «мертв».</p>
        <p>На этом этапе, чтобы получить объект из экземпляра <code>WeakRef</code>, мы воспользуемся его методом
        <code>deref()</code>.</p>
        <p>Метод <code>deref()</code> возвращает объект-референт, на который ссылается <code>WeakRef</code>, в случае,
        если объект все еще находится в памяти. Если объект был удален сборщиком мусора, метод <code>deref()</code>
        вернет <code>undefined</code>:</p>
        <code>
            let ref = admin.deref();<br>
            <br>
            if (ref) {<br>
            &nbsp;&nbsp;// Объект все еще доступен: можем произвести какие-либо манипуляции с ним<br>
            } else {<br>
            &nbsp;&nbsp;// Объект был удален сборщиком мусора<br>
            }
        </code>
    </article>

    <article>
        <h2>Варианты использования WeakRef</h2>
        <p><code>WeakRef</code> обычно используется для создания кешей или ассоциативных массивов, в которых хранятся
        ресурсоемкие объекты. Это позволяет избежать предотвращения удаления этих объектов сборщиком мусора только
        на основе их присутствия в кеше или ассоциативном массиве.</p>
        <p>Один из основных примеров - это ситуация, когда у нас есть большое количество объектов бинарных
        изображений (например, представленных в виде <code>ArrayBuffer</code> или <code>Blob</code>), и мы хотим
        связать имя или путь с каждым изображением. Существующие структуры данных не совсем подходят для этих целей:</p>
        <ul>
            <li>
                <p>Использование <code>Map</code> для создания ассоциаций между именами и изображениями, или наоборот,
                сохранит объекты изображений в памяти, поскольку они фигурируют в <code>Map</code> в качестве ключей
                или значений.</p>
            </li>
            <li>
                <p><code>WeakMap</code> также не подойдет в этом случае: из-за того, что объекты, представленные в
                качестве ключей <code>WeakMap</code> используют слабые ссылки, и не защищены от удаления сборщиком мусора.</p>
            </li>
        </ul>
        <p>Но в данной ситуации нам нужна структура данных, которая бы использовала слабые ссылки в своих значениях.</p>
        <p>Для этого мы можем использовать коллекцию <code>Map</code>, значениями которой являются экземпляры
        <code>WeakRef</code>, ссылающиеся на нужные нам большие объекты. Следовательно, мы не будем хранить в памяти
        эти большие и ненужные объекты дольше, чем требуется.</p>
        <p>В противном случае это способ получить объект изображения из кеша, если он все еще доступен. Если же он был
        удален сборщиком мусора, мы сгенерируем или скачаем его заново.</p>
        <p>Таким образом, в некоторых ситуациях используется меньше памяти.</p>
    </article>

    <article>
        <h2>Пример №1: применение WeakRef для кеширования</h2>
        <p>Ниже находится фрагмент кода, который демонстрирует технику использования <code>WeakRef</code>.</p>
        <p>Говоря кратко, мы используем <code>Map</code> со строковыми ключами и объектами <code>WeakRef</code>
        в качестве их значений. Если объект <code>WeakRef</code> не был удален сборщиком мусора, мы берем его из
        кеша. В противном случае, мы скачиваем его заново и помещаем в кеш для возможности повторного использования
        в будущем:</p>
        <code>
            function fetchImg() {<br>
            &nbsp;&nbsp;// Абстрактная функция для загрузки изображений<br>
            }<br>
            <br>
            function weakRefCache(fetchImg) { // (1)<br>
            &nbsp;&nbsp;const imgCache = new Map(); // (2)<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;return (imgName) => { // (3)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const cachedImg = imgCache.get(imgName); // (4)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (cachedImg?.defer()) { // (5)<<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cachedImg?.defer();<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const newImg = fetchImg(imgName); // (6)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;imgCache.set(imgName, new WeakRef(newImg)); // (7)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return newImg;<br>
            &nbsp;&nbsp;};<br>
            }<br>
            <br>
            const getCachedImg = weakRefCache(fetchImg);
        </code>
        <p>Давайте подробно разберем что тут произошло:</p>
        <ol>
            <li>
                <p><code>weakRefCache</code> - функция высшего порядка, которая принимает другую функцию <code>fetchImg</code>
                в качестве аргумента. В данном примере мы можем пренебречь подробным описание функции <code>fetchImg</code>,
                так как это может быть абсолютно любая логика скачивания изображений.</p>
            </li>
            <li>
                <p><code>imgCache</code> - кеш изображений, который хранит кешированные результаты функции
                <code>fetchImg</code>, в виде строковых ключей (имя изображения) и объектов <code>WeakRef</code>
                в качестве их значений.</p>
            </li>
            <li>
                <p>Возвращаем анонимную функцию, которая принимает имя изображения в качестве аргумента. Данный
                аргумент будет использоваться в качестве ключа для кешированного изображения.</p>
            </li>
            <li>
                <p>Пытаемся получить кешированный результат из кеша, используя предоставленный ключ (имя изображения).</p>
            </li>
            <li>
                <p>Если кеш содержит значение по указанному ключу, и объект <code>WeakRef</code> не был удален
                сборщиком мусора, возвращаем кешированный результат.</p>
            </li>
            <li>
                <p>Если в кеше нет записи с запрошенным ключом, либо метод <code>defer()</code> возвращает
                <code>undefined</code> (что означает, что объект <code>WeakRef</code> был удален сборщиком мусора),
                функция <code>fetchImg</code> скачивает изображение заново.</p>
            </li>
            <li>
                <p>Помещаем скачанное изображение в кеш в виде <code>WeakRef</code> объекта.</p>
            </li>
        </ol>
        <p>Теперь у нас есть коллекция <code>Map</code>, в которой ключи - это имена изображений в виде строк,
        а значения - это объекты <code>WeakRef</code>, содержащие сами изображения.</p>
        <p>Эта техника помогает избежать выделения большого объема памяти на ресурсоемкие объекты, которые больше никто
        не использует. Также она экономит память и время в случае повторного использования кешированных объектов.</p>
        <p>Но у данной реализации есть свои недостатки: со временем <code>Map</code> будет заполняться строками в
        качестве ключей, которые указывают на <code>WeakRef</code>, чей объект-референт уже был удален сборщиком мусора.</p>
        <p>Один из способов справиться с этой проблемой - это периодически проверять кеш и удалять «мёртвые» записи.
        Другой способ - использовать финализаторы, с которыми мы познакомимся далее.</p>
    </article>

    <article>
        <h2>Пример №2: применение WeakRef для отслеживания объектов DOM</h2>
        <p>(Код примера в папке example)</p>
        <p>Еще один вариант использования <code>WeakRef</code> - отслеживание объектов DOM.</p>
        <p>Давайте представим ситуацию, когда какой-либо сторонний код или библиотека работают с элементами на нашей
        странице до тех пор, пока они существуют в DOM. Например, это может быть сторонняя утилита для мониторинга
        и оповещений о состоянии системы (так называемый «логгер» - программа, которая присылает информационные
        сообщения, называемые «логами»).</p>
        <p>При нажатии на кнопку «Начать отправку сообщений», в так называемом «окне отображения логов»
        (элемент с классом <code>.windows__body</code>) начинают появляться надписи (логи).</p>
        <p>Но, как только этот элемент удалится из DOM, логгер должен перестать присылать сообщения. Чтобы воспроизвести
        удаление данного элемента, достаточно лишь нажать на кнопку «Закрыть» в правом верхнем углу.</p>
        <p>Для того, чтобы нам не усложнять работы, и не уведомлять сторонний код каждый раз, когда наш DOM-элемент
        доступен, а когда - нет, достаточно будет создать на него слабую ссылку с помощью <code>WeakRef</code>.</p>
        <p>После того как элемент будет удален из DOM, логгер это увидит и перестанет присылать сообщения.</p>
        <p>Теперь давайте рассмотрим исходный код детальнее (<code>index.js</code>):</p>
        <ol>
            <li>
                <p>Получаем DOM-элемент кнопки «начать отправку сообщений».</p>
            </li>
            <li>
                <p>Получаем DOM-элемент кнопки «Закрыть».</p>
            </li>
            <li>
                <p>Получаем DOM-элемент окна отображения логов с использованием конструктора <code>new WeakRef()</code>.
                Таким образом переменная <code>windowElementRef</code> хранит слабую ссылку на DOM-элемент.</p>
            </li>
            <li>
                <p>Добавляем обработчик событий на кнопку «Начать отправку сообщений», отвечающий за запуск логгера
                по нажатию.</p>
            </li>
            <li>
                <p>Добавляем обработчик событий на кнопку «Закрыть», отвечающий за закрытие окна отображения логов
                по нажатию.</p>
            </li>
            <li>
                <p>С помощью <code>SetInterval</code> запускаем отображение нового сообщения каждую секунду.</p>
            </li>
            <li>
                <p>Если DOM-элемент окна отображения логов все еще доступен и находится в памяти, создаем и отправляем
                новое сообщение.</p>
            </li>
            <li>
                <p>Если метод <code>defer()</code> возвращает <code>undefined</code>, это значит, что DOM-элемент был
                удален из памяти. В таком случае логгер прекращает показ сообщений и сбрасывает таймер.</p>
            </li>
            <li>
                <p><code>alert</code>, который будет вызван после того, как DOM-элемент окна отображения логов удалится
                из памяти (т.е. после нажатия на кнопку «Закрыть»). <b>Обратите внимание, что удаление из памяти
                может произойти не сразу, т.к. оно зависит только от внутренних механизмов сборщика мусора.</b></p>
                <p>Мы не можем контролировать этот процесс напрямую из кода. Но, несмотря на это, у нас все еще есть
                возможность выполнить принудительную сборку мусора из браузера.</p>
                <p>В Google Chrome, например, для этого нужно открыть инструменты разработчика (<kbd>Ctrl</kbd> +
                <kbd>Shift</kbd> + <kbd>J</kbd>), перейти во вкладку «Производительность (Performance)» и нажать
                на кнопку с иконкой урны - «Собрать мусор (Collect garbage)»:</p>
                <img alt="" src="https://learn.javascript.ru/article/weakref-finalizationregistry/google-chrome-developer-tools.png">
                <p>Данный функционал поддерживается в большинстве современных браузеров. После проделанных действий
                <code>alert</code> сработает незамедлительно.</p>
            </li>
        </ol>
    </article>

    <article>
        <h2>FinalizationRegistry</h2>
        <p>А теперь пришло время поговорить о финализаторах. Прежде чем мы перейдем дальше, давайте разберемся с
        терминологией:</p>
        <p><b>Колбэк очистки (финализатор)</b> - это функция, которая выполняется в случае, если объект, зарегистрированный
        в <code>FinalizationRegistry</code>, удаляется из памяти сборщиком мусора.</p>
        <p>Его цель - предоставлять возможность выполнения дополнительных операций, связанных с объектом, после его
        окончательного удаления из памяти.</p>
        <p><b>Реестр</b> (или <code>FinalizationRegistry</code>) - это специальный объект в JavaScript, который
        управляет регистрацией и отменой регистрации объектов и их колбэков очистки.</p>
        <p>Этот механизм позволяет зарегистрировать объект для отслеживания и связать с ним колбэк очистки.
        По сути, это структура, которая хранит информацию о зарегистрированных объектах и их колбэков очистки,
        а затем автоматически вызывает эти колбэки при удалении объектов из памяти.</p>
        <p>Для создания экземпляра реестра <code>FinalizationRegistry</code>, необходимо вызвать его конструктор,
        который принимает единственный аргумент - колбэк очистки (финализатор).</p>
        <p>Синтаксис:</p>
        <code>
            function cleanupCallback(heldValue) {<br>
            &nbsp;&nbsp;// Код колбэка очистки<br>
            }<br>
            <br>
            const registry = new FinalizationRegistry(cleanupCallback);
        </code>
        <p>Здесь:</p>
        <ul>
            <li>
                <p><code>cleanupCallback</code> - колбэк очистки, который будет автоматически вызван при удалении
                зарегистрированного объекта из памяти.</p>
            </li>
            <li>
                <p><code>heldValue</code> - значение, которое передается в качестве аргумента для колбэка очистки.
                Если <code>heldValue</code> является объектом, реестр сохраняет на него сильную ссылку.</p>
            </li>
            <li>
                <p><code>registry</code> - экземпляр <code>FinalizationRegistry</code>.</p>
            </li>
        </ul>
        <p>Методы <code>FinalizationRegistry</code>:</p>
        <ul>
            <li>
                <p><code>register(target, heldValue [, unregisterToken])</code> - используется для регистрации объектов
                в реестре.</p>
                <p><code>target</code> - регистрируемый для отслеживания объект. Если <code>target</code> будет удален
                сборщиком мусора, колбэк очистки будет вызван с <code>heldValue</code> в качестве аргумента.</p>
                <p>Опциональный <code>unregisterToken</code> - токен отмены регистрации. Может быть передан для отмены
                регистрации до удаления объекта сборщиком мусора. Обычно в качестве <code>unregisterToken</code>
                используется объект <code>target</code>, что является стандартной практикой.</p>
            </li>
            <li>
                <p><code>unregister(unregisterToken)</code> - метод <code>unregister</code> используется для отмены
                регистрации объекта в реестре. Он принимает один аргумент - <code>unregisterToken</code> (токен отмены
                регистрации, который был получен при регистрации объекта).</p>
            </li>
        </ul>
        <p>Теперь перейдем к простому примеру. Воспользуемся уже известным нам объектом <code>user</code> и создадим
        экземпляр <code>FinalizationRegistry</code>:</p>
        <code>
            let user = {name: 'John'};<br>
            <br>
            const registry = new FinalizationRegistry((heldValue) => {<br>
            &nbsp;&nbsp;console.log(`${heldValue} был собран сборщиком мусора`);<br>
            });
        </code>
        <p>Затем зарегистрируем объект, для которого требуется колбэк очистки, вызвав метод <code>register</code>:</p>
        <code>
            registry.register(user, user.name);
        </code>
        <p>Реестр не хранит сильную ссылку на регистрируемый объект, так как это бы противоречило его предназначению.
        Если бы реестр сохранял сильную ссылку, то объект никогда бы не был очищен сборщиком мусора.</p>
        <p>Если же объект удаляется сборщиком мусора, наш колбэк очистки может быть вызван в какой-то момент
        в будущем, с переданными ему <code>heldValue</code>:</p>
        <code>
            // Когда объект user удалится сборщиком мусора, в консоль будет выведено сообщение:<br>
            'John был удален сборщиком мусора.'
        </code>
        <p>Также существуют ситуации, когда в реализациях, где используется колбэк очистки, есть вероятность,
        что он не будет вызван:</p>
        <p>Например:</p>
        <ul>
            <li>
                <p>Когда программа полностью завершает свою работу (например, при закрытии вкладки в браузере).</p>
            </li>
            <li>
                <p>Когда сам экземпляр <code>FinalizationRegistry</code> больше не доступен для JavaScript кода.
                Если объект, создающий экземпляр <code>FinalizationRegistry</code>, выходит из области видимости
                или удаляется, то колбэки очистки, зарегистрированные в этом реестре, также могут быть не вызваны.</p>
            </li>
        </ul>
    </article>

    <article>
        <h2>Кеширование с FinalizationRegistry</h2>
        <p>Возвращаясь к нашему примеру <i>слабого</i> кеша, мы можем заменить следующее:</p>
        <ul>
            <li>
                <p>Несмотря на то, что значения, обернутые в <code>WeakRef</code>, были собраны сборщиком мусора, все еще
                актуальна проблема «утечки памяти» в виде оставшихся ключей, значения которых были собраны сборщиком мусора.</p>
            </li>
        </ul>
        <p>Вот улучшенный пример кеширования, в котором используется <code>FinalizationRegistry</code>:</p>
        <code>
            function fetchImg() {<br>
            &nbsp;&nbsp;// Абстрактная функция для загрузки изображений<br>
            }<br>
            <br>
            function weakRefCache(fetchImg) {<br>
            &nbsp;&nbsp;const imgCache = new Map();<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;const registry = new FinalizationRegistry((imgName) => { // (1)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const cachedImg = ImgCache.get(imgName);
            &nbsp;&nbsp;&nbsp;&nbsp;if (cachedImg && !cachedImg.deref()) imgCache.remove(imgName);<br>
            &nbsp;&nbsp;});<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;return (imgName) => {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const cachedImg = imgCache.get(imgName);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (cachedImg?.defer()) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cachedImg?.refer();<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const newImg = fetchImg(imgName);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;imgCache.set(imgName, new WeakRef(newImg));<br>
            &nbsp;&nbsp;&nbsp;&nbsp;registry.register(newImg, imgName); // (2)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return newImg;<br>
            &nbsp;&nbsp;});<br>
            }<br>
            <br>
            const getCachedImg = weakRefCache(fetchImg);
        </code>
        <ol>
            <li>
                <p>Для управления очисткой «мертвых» записей в кеше, когда связанные с ними объекты <code>WeakRef</code>
                собираются сборщиком мусора, создаем реестр очистки <code>FinalizationRegistry</code>.</p>
                <p>Важным моментом здесь является то, что в колбэке очистки должно проверяться, были ли запись
                удалена сборщиком мусора и не была ли добавлена заново, чтобы не удалить «живую» запись.</p>
            </li>
            <li>
                <p>После загрузки и установки нового значения (изображения) в кеш, регистрируем его в реестре
                финализатора для отслеживания объекта <code>WeakRef</code>.</p>
            </li>
        </ol>
        <p>Данная реализация содержит только актуальные или «живые» пары ключ/значение. В этом случае каждый объект
        <code>WeakRef</code> зарегистрирован в <code>FinalizationRegistry</code>. А после того, как объекты будут
        очищены сборщиком мусора, колбэк очистки удалит все значения <code>undefined</code>.</p>
        <p>Ключевым аспектом в обновленной реализации является то, что финализаторы позволяют создавать параллельные
        процессы между «основной» программой и колбэками очистки. В контексте JavaScript, «основная» программа -
        это наш JavaScript-код, который запускается и выполняется в нашем приложении или на веб-странице.</p>
        <p>Следовательно, с момента когда объект помечается для удаления сборщиком мусора, до фактического выполнения
        колбэка очистки, может возникнуть определенный промежуток времени. Важно понимать, что в этом интервале
        основная программа может внести любые изменения в объект или даже вернуть его обратно в память.</p>
        <p>Поэтому, в колбэке очистки мы должны проверить, не была ли запись добавлена обратно в кеш основной программой,
        чтобы избежать удаления «живых» записей. Аналогично, при поиске ключа в кеше существует вероятность того, что
        значение было удалено сборщиком мусора, но колбэк очистки все еще не был выполнен.</p>
        <p>Такие ситуации требуют особого внимания, если вы работаете с <code>FinalizationRegistry</code>.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <p><code>WeakRef</code> - предназначен для создания слабых ссылок на объекты, что позволяет им быть удаленными
        из памяти сборщиком мусора, если на них больше нет сильных ссылок. Это полезно для решения проблемы чрезмерного
        использования памяти и оптимизации использования системных ресурсов в приложениях.</p>
        <p><code>FinalizationRegistry</code> - это средство регистрации колбэков, которые выполняются при уничтожении
        объектов, на которые больше нет сильных ссылок. Это позволяет освобождать связанные с объектом ресурсы или
        выполнять другие необходимые операции перед удалением объекта из памяти.</p>
    </article>
</body>
</html>