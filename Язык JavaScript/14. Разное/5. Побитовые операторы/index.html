<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Побитовые операторы</title>
    <link href="../../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Побитовые операторы</h2>
        <p>Побитовые операторы интерпретируют операнды как последовательность из 32 битов (нулей и единиц). Они
        производят операции, используя двоичное представление числа, и возвращают новую последовательность
        из 32 бит (число) в качестве результата.</p>
    </article>

    <article>
        <h2>Формат 32-битного целого числа со знаком</h2>
        <p>Побитовые операторы в JavaScript работают с 32-битными целыми числами в их двоичном представлении.</p>
        <p>Это представление называется «32-битное целое со знаком, старшим битом слева и дополнением до двойки».</p>
        <p>Разберем как устроены числа внутри подробнее, это необходимо знать для битовых операций с ними.</p>
        <ul>
            <li>
                <p>При разборе побитовых операций мы будем обсуждать именно двоичное представление чисел, из 32 бит.</p>
            </li>
            <li>
                <p><i>Старший бит слева</i> - это научное название для самого обычного порядка записи цифр (от большего
                разряда к меньшему). При этом, если больший разряд отсутствует, то соответствующий бит равен нулю.</p>
                <p>Примеры представления чисел в двоичной системе:</p>
                <code>
                    a = 0; // 00000000000000000000000000000000<br>
                    a = 1; // 00000000000000000000000000000001<br>
                    a = 2; // 00000000000000000000000000000010<br>
                    a = 3; // 00000000000000000000000000000011<br>
                    a = 255; // 00000000000000000000000011111111<br>
                </code>
                <p>Обратите внимание, каждое число состоит ровно из 32 битов.</p>
            </li>
            <li>
                <p><i>Дополнение до двойки</i> - это название способа поддержки отрицательных чисел.</p>
                <p><b>Двоичный вид числа, обратного данному (например, <code>5</code> и <code>-5</code>) получается
                путем обращения всех битов с прибавлением 1.</b></p>
                <p>То есть, нули заменяются на единицы, единицы - на нули и к числу прибавляется <code>1</code>.
                Получается внутреннее представление того же числа, но со знаком минус.</p>
                <p>Например, вот число <code>314</code>:</p>
                <code>00000000000000000000000100111010</code>
                <p>Чтобы получить <code>-314</code>, первый шаг - обратить биты числа: заменить <code>0</code>
                на <code>1</code>, а <code>1</code> на <code>0</code>:</p>
                <code>11111111111111111111111011000101</code>
                <p>Второй шаг - к полученному двоичному числу прибавить единицу, обычным двоичным сложением:
                <code>11111111111111111111111011000101 + 1 = 11111111111111111111111011000110</code>.</p>
                <p>Итак, мы получили:</p>
                <code>-314 = 11111111111111111111111011000110</code>
                <p>Принцип дополнения до двойки делит все двоичные представления на два множества: если крайний левый
                бит равен <code>0</code> - число положительное, если <code>1</code> - число отрицательное. Поэтому
                этот бит называется <i>знаковым битом</i>.</p>
            </li>
        </ul>
    </article>

    <article>
        <h2>Список операторов</h2>
        <p>В следующей таблице перечислены все побитовые операторы.</p>
        <table>
            <thead>
            <tr>
                <th>Оператор</th>
                <th>Использование</th>
                <th>Описание</th>
            </tr>
            </thead>
            <tr>
                <td>Побитовое И (AND)</td>
                <td><code>a & b</code></td>
                <td>Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.</td>
            </tr>
            <tr>
                <td>Побитовое ИЛИ (OR)</td>
                <td><code>a | b</code></td>
                <td>Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.</td>
            </tr>
            <tr>
                <td>Побитовое исключающее ИЛИ (XOR)</td>
                <td><code>a ^ b</code></td>
                <td>Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1
                (но не оба).</td>
            </tr>
            <tr>
                <td>Побитовое НЕ (NOT)</td>
                <td><code>~a</code></td>
                <td>Заменяет каждый бит операнда на противоположный.</td>
            </tr>
            <tr>
                <td>Левый сдвиг</td>
                <td><code>a << b</code></td>
                <td>Сдвигает двоичное представление <code>a</code> на <code>b</code> битов влево, добавляя справа нули.</td>
            </tr>
            <tr>
                <td>Побитовый сдвиг, переносящий знак</td>
                <td><code>a >> b</code></td>
                <td>Сдвигает двоичное представление <code>a</code> на <code>b</code> битов вправо, отбрасывая сдвигаемые биты.</td>
            </tr>
            <tr>
                <td>Правый сдвиг с заполнением нулями</td>
                <td><code>a >>> b</code></td>
                <td>Сдвигает двоичное представление <code>a</code> на <code>b</code> битов вправо, отбрасывая сдвигаемые
                биты и добавляя нули справа.</td>
            </tr>
        </table>
        <p>Побитовые операторы работают следующим образом:</p>
        <ol>
            <li>
                <p>Операнды преобразуются в 32-битные целые числа, представленные последовательностью битов. Дробная часть,
                если она есть, отбрасывается.</p>
            </li>
            <li>
                <p>Для бинарных операторов - каждый бит в первом операнде рассматривается вместе с соответствующим
                битом второго операнда: первый бит с первым, второй со вторым и т.п. Оператор применяется к каждой паре
                бит, давая соответствующий бит результата.</p>
            </li>
            <li>
                <p>Получившаяся в результате последовательность бит интерпретируется как обычное число.</p>
            </li>
        </ol>
        <p>Посмотрим, как работают операторы, на примерах.</p>

        <article class="note">
            <h2>Вспомогательные функции parseInt, toString</h2>
            <p>Для удобной работы с примерами в этой статье, если вы захотите протестировать что-то в консоли,
            пригодятся для функции.</p>
            <ul>
                <li>
                    <p><code>parseInt('11000', 2)</code> - переводит строку с двоичной записью числа в число.</p>
                </li>
                <li>
                    <p>n.toString(2) - получает для числа <code>n</code> запись в 2-ной системе в виде строки.</p>
                    <p>Например:</p>
                    <code>
                        let access = parseInt('11000', 2); // Получаем число из строки<br>
                        <br>
                        alert(access); // 24, число с таким 2-ным представлением<br>
                        <br>
                        let access2 = access.toString(2); // Обратно двоичную строку из числа<br>
                        <br>
                        alert(access2); // 11000
                    </code>
                    <p>Без них переводы в двоичную систему и обратно был бы куда менее удобен.</p>
                </li>
            </ul>
        </article>
    </article>

    <article>
        <h2>& (Побитовое И)</h2>
        <p>Выполняет операцию И над каждой парой бит.</p>
        <p>Результат <code>a & b</code> равен единице только когда оба бита <code>a</code> и <code>b</code> равны единице.</p>
        <p>Таблица истинности для <code>&</code>:</p>
        <table>
            <thead>
            <tr>
                <th><code>a</code></th>
                <th><code>b</code></th>
                <th><code>a & b</code></th>
            </tr>
            </thead>
            <tr>
                <td><code>0</code></td>
                <td><code>0</code></td>
                <td><code>0</code></td>
            </tr>
            <tr>
                <td><code>0</code></td>
                <td><code>1</code></td>
                <td><code>0</code></td>
            </tr>
            <tr>
                <td><code>1</code></td>
                <td><code>0</code></td>
                <td><code>0</code></td>
            </tr>
            <tr>
                <td><code>1</code></td>
                <td><code>1</code></td>
                <td><code>1</code></td>
            </tr>
        </table>
        <p>Пример:</p>
        <code>
            9 = 00000000000000000000000000001001<br>
            14 = 00000000000000000000000000001110<br>
            14 & 9 = 00000000000000000000000000001000 = 8
        </code>
    </article>

    <article>
        <h2>| (Побитовое ИЛИ)</h2>
        <p>Выполняет операцию ИЛИ над каждой парой бит. Результат <code>a | b</code> равен 1, если хотя бы один бит из
        <code>a, b</code> равен 1.</p>
        <p>Таблица истинности для <code>|</code>:</p>
        <table>
            <thead>
            <tr>
                <th><code>a</code></th>
                <th><code>b</code></th>
                <th><code>a | b</code></th>
            </tr>
            </thead>
            <tr>
                <td><code>0</code></td>
                <td><code>0</code></td>
                <td><code>0</code></td>
            </tr>
            <tr>
                <td><code>0</code></td>
                <td><code>1</code></td>
                <td><code>1</code></td>
            </tr>
            <tr>
                <td><code>1</code></td>
                <td><code>0</code></td>
                <td><code>1</code></td>
            </tr>
            <tr>
                <td><code>1</code></td>
                <td><code>1</code></td>
                <td><code>1</code></td>
            </tr>
        </table>
        <p>Пример:</p>
        <code>
            9 = 00000000000000000000000000001001<br>
            14 = 00000000000000000000000000001110<br>
            14 | 9 = 00000000000000000000000000001111 = 15
        </code>
    </article>

    <article>
        <h2>^ (Исключающее ИЛИ)</h2>
        <p>Выполняет операцию «Исключающее ИЛИ» над каждой парой бит.</p>
        <p><code>a</code> Исключающее ИЛИ <code>b</code> равно 1, если только <code>a = 1</code> или только <code>b = 1</code>,
        но не оба одновременно <code>a = b = 1</code>.</p>'
        <p>Таблица истинности для исключающего ИЛИ:</p>
        <table>
            <thead>
            <tr>
                <th><code>a</code></th>
                <th><code>b</code></th>
                <th><code>a ^ b</code></th>
            </tr>
            </thead>
            <tr>
                <td><code>0</code></td>
                <td><code>0</code></td>
                <td><code>0</code></td>
            </tr>
            <tr>
                <td><code>0</code></td>
                <td><code>1</code></td>
                <td><code>1</code></td>
            </tr>
            <tr>
                <td><code>1</code></td>
                <td><code>0</code></td>
                <td><code>1</code></td>
            </tr>
            <tr>
                <td><code>1</code></td>
                <td><code>1</code></td>
                <td><code>0</code></td>
            </tr>
        </table>
        <p>Как видно, оно дает 1, если ЛИБО слева <code>1</code>, ЛИБО справа <code>1</code>, но не одновременно.
        Поэтому его и называют «исключающее ИЛИ».</p>
        <p>Пример:</p>
        <code>
            9 = 00000000000000000000000000001001<br>
            14 = 00000000000000000000000000001110<br>
            14 ^ 9 = 00000000000000000000000000000111 = 7
        </code>

        <article class="note">
            <h2>Исключающее ИЛИ в шифровании</h2>
            <p>Исключающее ИЛИ можно использовать для шифрования, так как эта операция полностью обратима. Двойное
            применение исключающего ИЛИ с тем же аргументом дает исходное число.</p>
            <p>Иначе говоря, верна формула: <code>a ^ b ^ b = a</code>.</p>
            <p>Пусть Вася хочет передать Пете секретную информацию <code>data</code>. Эта информация заранее превращается
            в число, например, строка интерпретируется как последовательность кодов символов.</p>
            <p>Вася и Петя заранее договариваются о числовом ключе шифрования <code>key</code>.</p>
            <p>Алгоритм:</p>
            <ul>
                <li>
                    <p>Вася берет двоичное представление <code>data</code> и делает операцию <code>data ^ key</code>.
                    При необходимости <code>data</code> бьется на части, равные по длине <code>key</code>, чтобы
                    можно было провести побитовое ИЛИ <code>^</code> для каждой части. В JavaScript оператор <code>^</code>
                    работает с 32-битными целыми числами, так что <code>data</code> нужно разбить на последовательность
                    таких чисел.</p>
                </li>
                <li>
                    <p>Результат <code>data ^ key</code> отправляется Пете, это шифровка.</p>
                </li>
            </ul>
            <p>Например, пусть в <code>data</code> очередное число равно <code>9</code>, а ключ <code>key</code>
            равен <code>1220461917</code>.</p>
            <code>
                data: 9 = 00000000000000000000000000001001<br>
                key: 1220461917 = 01001000101111101100010101011101<br>
                шифровка: 9 ^ 1220461917 = 1220461908
            </code>
            <ul>
                <li>
                    <p>Петя, получив очередное число шифровки <code>1220461908</code>, применяет к нему такую же операцию
                    <code>^ key</code>.</p>
                </li>
                <li>
                    <p>Результатом будет исходное число <code>data</code>.</p>
                </li>
            </ul>
            <p>В нашем случае:</p>
            <code>
                шифровка: 9 ^ key = 1220461908 = 01001000101111101100010101010100<br>
                key: 1220461917 = 01001000101111101100010101011101<br>
                исходное сообщение: 1220461908 ^ key = 00000000000000000000000000001001 = 9
            </code>
            <p>Конечно, такое шифрование поддается частотному анализу и другим методам дешифровки, поэтому современные
            алгоритмы используют операцию XOR <code>^</code> как одну из важных частей более сложной многоступенчатой
            схемы.</p>
        </article>
    </article>

    <article>
        <h2>~ (Побитовое НЕ)</h2>
        <p>Производит операцию НЕ над каждым битом, заменяя его на обратный ему.</p>
        <p>Таблица истинности для НЕ:</p>
        <table>
            <thead>
            <tr>
                <th><code>a</code></th>
                <th><code>~b</code></th>
            </tr>
            </thead>
            <tr>
                <td><code>0</code></td>
                <td><code>1</code></td>
            </tr>
            <tr>
                <td><code>1</code></td>
                <td><code>0</code></td>
            </tr>
        </table>
        <p>Пример:</p>
        <code>
            9 = 00000000000000000000000000001001<br>
            ~9 = 11111111111111111111111111110110 = -10
        </code>
        <p>Из-за внутреннего представления отрицательных чисел получается так, что <code>~n == -(n + 1)</code>.</p>
        <p>Например:</p>
        <code>
            alert(~3); // -4<br>
            alert(~-1); // 0
        </code>
    </article>

    <article>
        <h2><< (Битовый сдвиг влево)</h2>
        <p>Операторы битового сдвига принимают два операнда. Первый - это число для сдвига, а второй - количество битов,
        которое нужно сдвинуть в первом операнде.</p>
        <p>Оператор <code><<</code> сдвигает первый операнд на указанное число битов влево. Лишние биты отбрасываются,
        справа добавляются нулевые биты.</p>
        <p>Например, <code>9 << 2</code> даст <code>36</code>:</p>
        <code>
            9 = 00000000000000000000000000001001<br>
            9 << 2 = 00000000000000000000000000100100 = 36
        </code>
        <p>Операция <code><< 2</code> сдвинула и отбросила два левых нулевых бита и добавила справа два новых нулевых.</p>

        <article class="note">
            <h2>Левый сдвиг почти равен умножению на 2</h2>
            <p>Битовый сдвиг <code><< N</code> обычно имеет тот же эффект, что и умножение на два <code>N</code> раз,
            например:</p>
            <code>
                alert(3 << 1); // 6, умножение на 2<br>
                alert(3 << 2); // 12, умножение на 2 два раза<br>
                alert(3 << 3); // 24, умножение на 2 три раза
            </code>
            <p>Конечно, следует иметь в виду, что побитовые операторы работают только с 32-битными числами, поэтому
            верхний порог такого «умножения» ограничен:</p>
            <code>
                alert(10000000000 << 1); // -1474836480, отброшен крайний левый бит<br>
                alert(10000000000 * 2); // 20000000000, обычное умножение
            </code>
        </article>
    </article>

    <article>
        <h2>>> (Правый битовый сдвиг, переносящий знак)</h2>
        <p>Этот оператор сдвигает биты вправо, отбрасывая лишние. При этом справа добавляется копия крайнего левого бита.</p>
        <p>Знак числа (представленный крайним левым битом) при этом не меняется, так как новый крайний левый бит имеет
        такое же значение, что и в исходном числе.</p>
        <p>Поэтому он назван «переносящим знак».</p>
        <p>Например, <code>9 >> 2</code> даст <code>2</code>:</p>
        <code>
            9 = 00000000000000000000000000001001<br>
            9 >> 2 = 00000000000000000000000000000010 = 2
        </code>
        <p>Операция <code>>> 2</code> сдвинула вправо и отбросила два правых бита <code>01</code> и добавила слева
        две копии первого бита <code>00</code>.</p>
        <p>Аналогично, <code>-9 >> 2</code> даст <code>-3</code>:</p>
        <code>
            -9 = 11111111111111111111111111110111<br>
            -9 >> 2 = 11111111111111111111111111111101 = -3
        </code>
        <p>Здесь операция <code>>> 2</code> сдвинула вправо и отбросила два правых бита <code>11</code> и добавила слева
        две копии первого бита <code>11</code>. Знак числа сохранен, так как крайний левый (знаковый) бит сохранил
        значение <code>1</code>.</p>

        <article class="note">
            <h2>Правый сдвиг почти равен целочисленному делению на 2</h2>
            <p>Битовый сдвиг <code>>> N</code> обычно имеет тот же результат, что и целочисленное деление на два
            <code>N</code> раз:</p>
            <code>
                alert(100 >> 1); // 50, деление на 2<br>
                alert(100 >> 2); // 25, деление на 2 два раза<br>
                alert(100 >> 3); // 12, деление на 2 три раза, целая часть от результата
            </code>
        </article>
    </article>

    <article>
        <h2>>>> (Правый сдвиг с заполнением нулями)</h2>
        <p>Этот оператор сдвигает биты первого операнда вправо. Лишние биты справа отбрасываются. Слева добавляются
        нулевые биты.</p>
        <p>Знаковый бит становится равным 0, поэтому результат всегда положителен.</p>
        <p><b>Для неотрицательных чисел правый сдвиг с заполнением нулями <code>>>></code> и правый сдвиг с переносом
        знака <code>>></code> дадут одинаковый результат, т.к. в обоих случаях слева добавляются нули.</b></p>
        <p>Для отрицательных чисел - результат работы разный. Например, <code>-9 >>> 2</code> даст
        <code>1073741821</code>, в отличие от <code>-9 >> 2</code> (дает <code>-3</code>):</p>
        <code>
            -9 = 11111111111111111111111111110111<br>
            -9 >> 2 = 00111111111111111111111111111101 = 1073741821
        </code>
    </article>

    <article>
        <h2>Применение побитовых операторов</h2>
        <p>Побитовые операторы используются редко, но все же используются.</p>
        <p>Случаи применения побитовых операторов, которые мы здесь разберем, составляют большинство всех использований
        в JavaScript.</p>

        <article class="warning">
            <h2>Осторожно, приоритеты!</h2>
            <p>В JavaScript побитовые операторы <code>^</code>, <code>&</code>, <code>|</code> выполняются после
            сравнений <code>==</code>.</p>
            <p>Например, в сравнении <code>a == b ^ 0</code> будет сначала выполнено сравнение <code>a == b</code>, а
            потом уже операция <code>^ 0</code>, как будто стоят скобки <code>(a == b) ^ 0</code>.</p>
            <p>Обычно это не то, чего мы хотим. Чтобы гарантировать желаемый порядок, нужно ставить скобки:
            <code>a == (b ^ 0)</code>.</p>
        </article>

        <h3>Маска</h3>
        <p>Для этого примера представим, что наш скрипт работает с пользователями.</p>
        <p>У них могут быть различные роли в проекте:</p>
        <ul>
            <li>
                <p><code>Гость</code></p>
            </li>
            <li>
                <p><code>Редактор</code></p>
            </li>
            <li>
                <p><code>Админ</code></p>
            </li>
        </ul>
        <p>Каждой роли соответствует ряд доступов к статьям и функциональности сайта.</p>
        <p>Например, <code>Гость</code> может лишь просматривать статьи сайта, а <code>Редактор</code> - еще и
        редактировать их, и тому подобное.</p>
        <p>Что-то в духе:</p>
        <table>
            <thead>
            <tr>
                <th>Пользователь</th>
                <th>Просмотр статей</th>
                <th>Изменение статей</th>
                <th>Просмотр товаров</th>
                <th>Изменение товаров</th>
                <th>Управление правами</th>
            </tr>
            </thead>
            <tr>
                <td>Гость</td>
                <td>Да</td>
                <td>Нет</td>
                <td>Да</td>
                <td>Нет</td>
                <td>Нет</td>
            </tr>
            <tr>
                <td>Редактор</td>
                <td>Да</td>
                <td>Да</td>
                <td>Да</td>
                <td>Да</td>
                <td>Нет</td>
            </tr>
            <tr>
                <td>Админ</td>
                <td>Да</td>
                <td>Да</td>
                <td>Да</td>
                <td>Да</td>
                <td>Да</td>
            </tr>
        </table>
        <p>Если вместо «Да» поставить <code>1</code>, а вместо «Нет» - <code>0</code>, то каждый набор доступов описывается
        числом:</p>
        <table>
            <thead>
            <tr>
                <th>Пользователей</th>
                <th>Просмотр статей</th>
                <th>Изменение статей</th>
                <th>Просмотр товаров</th>
                <th>Изменение товаров</th>
                <th>Управление правами</th>
                <th>В 10-ной системе</th>
            </tr>
            </thead>
            <tr>
                <td>Гость</td>
                <td>1</td>
                <td>0</td>
                <td>1</td>
                <td>0</td>
                <td>0</td>
                <td>= 20</td>
            </tr>
            <tr>
                <td>Редактор</td>
                <td>1</td>
                <td>1</td>
                <td>1</td>
                <td>1</td>
                <td>0</td>
                <td>= 30</td>
            </tr>
            <tr>
                <td>Админ</td>
                <td>1</td>
                <td>1</td>
                <td>1</td>
                <td>1</td>
                <td>1</td>
                <td>= 31</td>
            </tr>
        </table>
        <p>В последней колонке находится десятичное число, которое получится, если прочитать строку доступов в двоичном
        виде.</p>
        <p>Например, доступ гостя <code>10100 = 20</code>.</p>
        <p>Такая интерпретация доступов позволяет «упаковать» много информации в одно число. Это экономит память,
        а кроме того - это удобно, поскольку в дополнение к экономии - по такому значению очень легко проверить,
        имеет ли посетитель заданную <i>комбинацию доступов</i>!</p>
        <p>Для этого посмотрим, как в 2-ной системе представляется каждый доступ в отдельности.</p>
        <ul>
            <li>
                <p>Доступ, соответствующий только управлению правами: <code>00001 (=1)</code> (все нули кроме
                <code>1</code> на позиции, соответствующей этому доступу).</p>
            </li>
            <li>
                <p>Доступ, соответствующий только изменению товаров: <code>00010 (=2)</code>.</p>
            </li>
            <li>
                <p>Доступ, соответствующий только просмотру товаров: <code>00100 (=4)</code>.</p>
            </li>
            <li>
                <p>Доступ, соответствующий только изменению статей: <code>01000 (=8)</code>.</p>
            </li>
            <li>
                <p>Доступ, соответствующий только просмотру статей: <code>10000 (=16)</code>.</p>
            </li>
        </ul>
        <p>Доступ одновременно на просмотр и изменение статей - это двоичное число с <code>1</code> на соответствующих
        позициях, то есть <code>access = 11000</code>.</p>
        <p>Как правило, доступы задаются в виде констант:</p>
        <code>
            const ACCESS_ADMIN = 1; // 00001<br>
            const ACCESS_GOODS_EDIT = 2; // 00010<br>
            const ACCESS_GOODS_VIEW = 4; // 00100<br>
            const ACCESS_ARTICLE_EDIT = 8; // 01000<br>
            const ACCESS_ARTICLE_VIEW = 16; // 10000
        </code>
        <p>Из этих констант получить нужную комбинацию доступов можно при помощи операции <code>|</code>.</p>
        <code>
            const guest = ACCESS_ARTICLE_VIEW | ACCESS_GOODS_VIEW; // 10100<br>
            const editor = guest | ACCESS_ARTICLE_EDIT | ACCESS_GOODS_EDIT; // 11110<br>
            const admin = editor | ACCESS_ADMIN; // 11111
        </code>
        <p>Теперь, чтобы понять, есть ли в доступе <code>editor</code> нужный доступ, например управление правами -
        достаточно применить к нему побитовый оператор И (<code>&</code>) с соответствующей константой.</p>
        <p>Нулевой результат будет означать, что доступ есть:</p>
        <code>
            alert(editor & ACCESS_ADMIN); // 0, доступа нет<br>
            alert(editor & ACCESS_ARTICLE_EDIT); // 8, доступ есть
        </code>
        <p>Такая проверка работает, потому что оператор И ставит <code>1</code> на те позиции результата, на которых
        в обоих операндах стоит <code>1</code>.</p>
        <p><b>Можно проверить один из нескольких доступов.</b></p>
        <p>Например, проверим, есть ли права на просмотр ИЛИ изменение товаров. Соответствующий права задаются битом
        <code>1</code> на втором и третьем месте с конца, что дает число <code>00110</code> (=<code>6</code> в 10-ной системе).</p>
        <code>
            const check = ACCESS_GOODS_VIEW | ACCESS_GOODS_EDIT; // 6, 00110<br>
            <br>
            alert(admin & check); // не 0, значит есть доступ к просмотру ИЛИ изменению
        </code>
        <p><i>Битовой маской</i> называют как раз комбинацию двоичных значений (<code>check</code> в примере выше),
        которая используется для проверки и выборки единиц на нужных позициях.</p>
        <p>Маски могут быть весьма удобны.</p>
        <p>В частности, их используют в функциях, чтобы одним параметром передать несколько «флагов», т.е.
        однобитных значений.</p>
        <p>Пример вызова функции с маской:</p>
        <code>
            // Найти пользователей с правами на изменение товаров или администраторов<br>
            findUsers(ACCESS_GOODS_EDIT | ACCESS_ADMIN);
        </code>
        <p>Это довольно-таки коротко и элегантно, но, вместе с тем, применение масок налагает определенные ограничения.
        В частности, побитовые операторы в JavaScript работают только с 32-битными числами, а значит, к примеру,
        33 доступа уже в число не упакуешь. Да и работа с двоичной системой счисления - как ни крути, менее удобна,
        чем с десятичной иди с обычными логическими значениями <code>true/false</code>.</p>
        <p>Поэтому основная сфера применения масок - это быстрые вычисления, экономия памяти, низкоуровневые операции,
        связанные с рисованием из JavaScript (3d-графика), интеграция с некоторыми функциями ОС (для серверного
        JavaScript), и другие ситуации, когда уже существуют функции, требующий битовую маску.</p>

        <h3>Округление</h3>
        <p>Так как битовые операции отбрасывают десятичную часть, то их можно использовать для округления.</p>
        <p>Достаточно взять любую операцию, которая не меняет значение числа.</p>
        <p>Например, двойное НЕ (<code>~</code>):</p>
        <code>alert(~~12.345); // 12</code>
        <p>Подойдет и исключающее ИЛИ (<code>^</code>) с нулем:</p>
        <code>alert(12.345 ^ 0); // 12</code>
        <p>Последнее даже более удобно, поскольку отлично читается:</p>
        <code>alert(12.3 * 14.5 ^ 0); // (=178) "12.3 умножить на 14.5 и округлить"</code>
        <p>У побитовых операторов достаточно низкий приоритет, он меньше чем у остальной арифметики:</p>
        <code>alert(1.1 + 1.2 ^ 0); // 2, сложение выполнится раньше округления</code>

        <h3>Проверка на -1</h3>
        <p>Внутренний формат 32-битных чисел устроен так, что для смены знака нужно все биты заменить на противоположные
        («обратить») и прибавить <code>1</code>.</p>
        <p>Обращение битов - это побитовое НЕ (<code>~</code>). То есть, при таком формате представления числа
        <code>-n = ~n + 1</code>. Или, если перенести единицу: <code>~n = -(n + 1)</code>.</p>
        <p>Как видно из последнего равенства, <code>~n == 0</code>, только если <code>n == -1</code>. Поэтому легко
        проверить равенство <code>n == -1</code>:</p>
        <code>
            let n = 5;<br>
            <br>
            if (~n) { // Сработает, т.к. ~n = -(5 + 1) = -6<br>
            &nbsp;&nbsp;alert('n не -1'); // Выведет!<br>
            }
        </code>
        <br>
        <code>
            let n = -1;<br>
            <br>
            if (~n) { // Не сработает, т.к. ~n = -(-1 + 1) = 0<br>
            &nbsp;&nbsp;alert('...ничего не выведет...');<br>
            }
        </code>
        <p>Проверка на <code>-1</code> пригождается, например, при поиске символа в строке. Вызов
        <code>str.indexOf('подстрока')</code> возвращает позицию подстроки в <code>str</code>, или <code>-1</code>
        если не нашел.</p>
        <code>
            let str = 'Проверка';<br>
            <br>
            if (~str.indexOf('верка')) { // Сочетание "if (~...indexOf)" читается как "если найдено"<br>
            &nbsp;&nbsp;alert('Найдено!');<br>
            }
        </code>

        <h3>Умножение и деление на степени 2</h3>
        <p>Оператор <code>a << b</code>, сдвигая биты, по сути умножает <code>a</code> на <code>2</code> в степени
        <code>b</code>.</p>
        <p>Например:</p>
        <code>
            alert(1 << 2); // 1 * (2 * 2) = 4<br>
            alert(1 << 3); // 1 * (2 * 2 * 2) = 8<br>
            alert(3 << 3); // 3 * (2 * 2 * 2) = 24<br>
        </code>
        <p>При этом следует иметь в виду, что максимальный верхний порог такого умножения меньше, чем обычно,
        так как побитовые операции манипулируют 32-битными целыми, в то время как обычные операторы работают
        с числами длиной 64 бита.</p>
        <p>Оператор сдвига в другую сторону <code>a >> b</code>, производит обратную операцию - целочисленное деление
        <code>a</code> на <code>2<sup>b</sup></code>.</p>
        <code>
            alert(8 >> 2); // 2 = 8 / 4, убрали 2 нуля в двоичном представлении<br>
            alert(11 >> 2); // 2, целочисленное деление (менее значимые биты просто отброшены)
        </code>
    </article>

    <article>
        <h2>Итого</h2>
        <ul>
            <li>
                <p>Бинарные побитовые операторы: <code>& | ^ << >> >>></code>.</p>
            </li>
            <li>
                <p>Унарный побитовый оператор один: <code>~</code>.</p>
            </li>
        </ul>
        <p>Как правило, битовое представление числа используется для:</p>
        <ul>
            <li>
                <p>Округления числа: <code>(12.34 ^ 0) = 12</code>.</p>
            </li>
            <li>
                <p>Проверка на равенство <code>-1</code>: <code>if (~n) {n не -1}</code>.</p>
            </li>
            <li>
                <p>Упаковка нескольких битовых значений («флагов») в одно значение. Это экономит память и позволяет
                проверить наличие комбинации флагов одним оператором <code>&</code>.</p>
            </li>
            <li>
                <p>Других ситуаций, когда нужны битовые маски.</p>
            </li>
        </ul>
    </article>
</body>
</html>

<script src="script.js"></script>