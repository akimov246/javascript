<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Деструктурирующее присваивание</title>
    <link href="../../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Деструктурирующее присваивание</h2>
        <p>В JavaScript есть две чаще всего используемые структуры данных - это <code>Object</code> и <code>Array</code>.</p>
        <ul>
            <li>Объекты позволяют нам создавать одну сущность, которая хранит элементы данных по ключам.</li>
            <li>Массивы позволяют нам собирать элементы данных в упорядоченный список.</li>
        </ul>
        <p>Но когда мы передаем их в функцию, то ей может понадобиться не объект/массив целиком, а элементы по отдельности.</p>
        <p><i>Деструктурирующее присваивание</i> - это специальный синтаксис, который позволяет нам «распаковать» массивы
        или объекты в несколько переменных, так как иногда они более удобны.</p>
        <p>Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по
        умолчанию и так далее.</p>
    </article>

    <article>
        <h2>Деструктуризация массива</h2>
        <p>Вот пример деструктуризации массива на переменные:</p>
        <code>
            let arr = ['Leo', 'Akimov'];<br>
            <br>
            let [firstName, surname] = arr;
        </code>

        <article class="note">
            <h2>«Деструктуризация» не означает «разрушение»</h2>
            <p>«Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания,
            его задача - только скопировать нужные значения в переменные.</p>
            <p>Это просто короткий вариант записи:</p>
            <code>
                // let [firstName, surname] = arr;<br>
                let firstName = arr[0];<br>
                let surname = arr[1];
            </code>
        </article>

        <article class="note">
            <h2>Пропускайте элементы, используя запятые</h2>
            <p>Нежелательные элементы массива также могут быть отброшены с помощью дополнительной запятой:</p>
            <code>
                let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
                alert(title); // Consul
            </code>
            <p>В примере выше второй элемент массива пропускается, а третий присваивается переменной <code>title</code>,
            оставшиеся элементы массива также пропускаются (так как для них нет переменных).</p>
        </article>

        <article class="note">
            <h2>Работает с любым перебираемым объектом с правой стороны</h2>
            <p>На самом деле мы можем использовать любой перебираемый объект, не только массивы.</p>
        </article>

        <article class="note">
            <h2>Присваивайте чему угодно с левой стороны</h2>
            <p>Мы можем использовать что угодно «присваивающее» с левой стороны.</p>
            <p>Например, можно присвоить свойству объекта:</p>
            <code>
                let user = {};<br>
                [user.name, user.surname] = 'Leo Akimov'.split(' ');
            </code>
        </article>

        <article class="note">
            <h2>Цикл с .entries()</h2>
            <p>Мы можем использовать метод <code>Object.entries(obj)</code> с деструктуризацией для цикличного перебора
            ключей и значений объекта:</p>
            <code>
                let user = {<br>
                &nbsp;&nbsp;name: 'John',<br>
                &nbsp;&nbsp;age: 30<br>
                };<br>
                <br>
                for (let [key, value] of Object.entries(user)) {<br>
                &nbsp;&nbsp;alert(`${key}:${value}`);<br>
                }
            </code>
            <p>То же самое для map:</p>
            <code>
                let user = new Map();<br>
                user.set('name', 'John');<br>
                user.set('age', 30);<br>
                <br>
                for (let [key, value] of user.entries()) {<br>
                &nbsp;&nbsp;alert(`${key}:${value}`);<br>
                }
            </code>
        </article>

        <article>
            <h2>Трюк обмена переменных</h2>
            <p>Существует хорошо известный трюк для обмена значений двух переменных с использованием деструктурирующего
            присваивания:</p>
            <code>
                let guest = 'Jane';<br>
                let admin = 'Pete';<br>
                <br>
                // Давайте поменяем местами значения<br>
                [guest, admin] = [admin, guest];
            </code>
            <p>Здесь мы создаем временный массив из двух переменных и немедленно деструктурируем его в порядке замены.</p>
            <p>Таким образом, мы можем поменять местами даже более двух переменных.</p>
        </article>
    </article>

    <article>
        <h2>Остаточные параметры «...»</h2>
        <p>Обычно, если массив длиннее, чем список слева, «лишние» элементы опускаются.</p>
        <p>Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить еще один
        параметр, который получает остальные значения, используя оператор «остаточные параметры» - троеточие <code>...</code>.</p>
        <code>
            let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];<br>
            // rest = ["Consul", "of the Roman Republic"]
        </code>
    </article>

    <article>
        <h2>Значения по умолчанию</h2>
        <p>Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределенными:</p>
        <code>
            let [name, surname] = [];<br>
            alert(name); // undefined<br>
            alert(surname); //undefined
        </code>
        <p>Если мы хотим, чтобы значение «по умолчанию» заменило отсутствующее, мы можем указать его с помощью <code>=</code>:</p>
        <code>
            // значения по умолчанию<br>
            let [name = 'Guest', surname = 'Anonymous'] = ['Julius'];<br>
            <br>
            alert(name); // 'Julius'
            alert(surname); // 'Anonymous'
        </code>
        <p>Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если
        значения отсутствуют.</p>
    </article>

    <article>
        <h2>Деструктуризация объекта</h2>
        <p>Деструктурирующее присваивание также работает с объектами.</p>
        <p>Синтаксис:</p>
        <code>let {var1, var2} = {var1:…, var2:…}</code>
        <p>У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит
        «шаблон» для соответствующих свойств. В простом случае это список названий переменных в <code>{...}</code>.</p>
        <p>Например:</p>
        <code>
            let options = {<br>
            &nbsp;&nbsp;title: 'Menu',<br>
            &nbsp;&nbsp;width: 100,<br>
            &nbsp;&nbsp;height: 200<br>
            };<br>
            <br>
            let {title, width, height} = options;<br>
            <br>
            alert(title); // 'Menu'<br>
            alert(width); // 100<br>
            alert(height); // 200
        </code>
        <p>Свойство <code>options.title</code>, <code>options.width</code> и <code>options.height</code> присваиваются
        соответствующим переменным.</p>
        <p>Порядок не имеет значения. Вот так тоже сработает:</p>
        <code>let {height, width, title} =  {title: 'Menu', height: 200, width: 100};</code>
        <p>Шаблон с левой стороны может быть более сложным и определять соответствие между свойствами и переменными.</p>
        <p>Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство <code>options.width</code>
        присвоить переменной <code>w</code>, то мы можем использовать двоеточие:</p>
        <code>
            let options = {<br>
            &nbsp;&nbsp;title: 'Menu',<br>
            &nbsp;&nbsp;width: 100,<br>
            &nbsp;&nbsp;height: 200<br>
            };<br>
            <br>
            // {sourceProperty: targetVariable}<br>
            let {width: w, height: h, title} = options;<br>
            <br>
            alert(title); // 'Menu'<br>
            alert(w); // 100<br>
            alert(h); // 200
        </code>
        <p>Двоеточие показывает «что: куда идет». В примере выше свойство <code>width</code> сохраняется в переменную
        <code>w</code>, свойство <code>height</code> сохраняется в <code>h</code>, а <code>title</code> присваивается
        одноименной переменной.</p>
        <p>Для потенциально отсутствующих свойств мы можем установить значение по умолчанию, используя <code>=</code>,
        как здесь:</p>
        <code>
            let options = {<br>
            &nbsp;&nbsp;title: 'Menu'<br>
            };<br>
            <br>
            let {width = 100, height = 200, title} = options;<br>
        </code>
        <p>Как и в случае с массивами, значениями по умолчанию могут быть любые выражения или даже функции.
        Они выполнятся, если значения отсутствуют.</p>
        <p>Мы также можем совмещать <code>:</code> и <code>=</code>:</p>
        <code>
            let options = {<br>
            &nbsp;&nbsp;title: 'Menu'<br>
            };<br>
            <br>
            let {width: w = 100, height: h = 200, title} = options;<br>
        </code>
        <p>Если у нас есть большой объект с множеством свойств, можно взять только то, что нужно:</p>
        <code>
            let options = {<br>
            &nbsp;&nbsp;title: 'Menu',<br>
            &nbsp;&nbsp;width: 100,<br>
            &nbsp;&nbsp;height: 200<br>
            };<br>
            <br>
            let {title} = options;<br>
            <br>
            alert(title); // 'Menu'
        </code>
    </article>

    <article>
        <h2>Остаток объекта «...»</h2>
        <p>Что если в объекте больше свойств, чем у нас переменных? Можем ли мы взять необходимые нам, а остальные присвоить
        куда-нибудь?</p>
        <p>Можно использовать троеточие, как и для массивов.</p>
        <p>Выглядит это так:</p>
        <code>
            let options = {<br>
            &nbsp;&nbsp;title: 'Menu',<br>
            &nbsp;&nbsp;width: 100,<br>
            &nbsp;&nbsp;height: 200<br>
            };<br>
            <br>
            let {title, ...rest} = options;<br>
            <br>
            alert(rest.width); // 100<br>
            alert(rest.height); // 200
        </code>

        <article class="note">
            <h2>Обратите внимание на <code>let</code></h2>
            <p>В примерах выше переменные были объявлены в присваивании <code>let {…} = {…}</code>. Конечно, мы могли бы
            использовать существующие переменные и не указывать <code>let</code>, но тут есть подвох.</p>
            <p>Вот так не будет работать:</p>
            <code>
                let title, width, height;<br>
                <br>
                // В этой строке будет ошибка<br>
                {title, width, height} = {title: 'Menu', width: 100, height: 200};
            </code>
            <p>Проблема в том, что JavaScript обрабатывает <code>{...}</code> в основном потоке кода как блок кода.
            Такие блоки кода могут быть использованы для группировки операторов.</p>
            <p>Так что здесь JavaScript считает, что видит блок кода, отсюда и ошибка. На самом деле у нас деструктуризация.</p>
            <p>Чтобы показать JavaScript, что это не блок кода, мы можем заключить выражение в скобки <code>(...)</code>:</p>
            <code>
                let title, width, height;<br>
                <br>
                // Сейчас все работает<br>
                ({title, width, height} = {title: 'Menu', width: 100, height: 200});
            </code>
        </article>
    </article>

    <article>
        <h2>Вложенная деструктуризация</h2>
        <p>Если объект или массив содержит другие вложенные объекты или массивы, то мы можем использовать более сложные
        шаблоны с левой стороны, чтобы извлечь более глубокие свойства.</p>
        <p>В приведенном ниже коде <code>options</code> хранит другой объект в свойстве <code>size</code> и массив
        в свойстве <code>items</code>. Шаблон в левой части присваивания имеет такую же структуру, чтобы извлечь данные
        из них:</p>
        <code>
            let options = {<br>
            &nbsp;&nbsp;size: {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;width: 100,<br>
            &nbsp;&nbsp;&nbsp;&nbsp;height: 200
            &nbsp;&nbsp;},<br>
            &nbsp;&nbsp;items: ['Cake', 'Donut'],<br>
            &nbsp;&nbsp;extra: true<br>
            };<br>
            <br>
            let {size: {width, height}, items: [item1, item2], title = 'Menu'} = options;
        </code>
        <p>Весь объект <code>options</code>, кроме свойства <code>extra</code>, которое в левой части отсутствует,
        присваивается в соответствующие переменные.</p>
        <p>В итоге у нас есть <code>width</code>, <code>height</code>, <code>item1</code>, <code>item2</code> и <code>title</code>
        со значением по умолчанию.</p>
        <p>Заметим, что переменные <code>size</code> и <code>items</code> отсутствуют, так как мы взяли сразу их содержимое.</p>
    </article>

    <article>
        <h2>Умные параметры функций</h2>
        <p>Есть ситуации, когда функция имеет много параметров, большинство из которых не обязательны. Это особенно верно
        для пользовательских интерфейсов. Представьте себе функцию, которая создает меню. Она может иметь ширину, высоту,
        заголовок, список элементов и так далее.</p>
        <p>Вот так - плохой способ писать подобные функции:</p>
        <code>function showMenu(title = 'Untitled' width = 200, height = 100, items = []) {...}</code>
        <p>В реальной жизни проблема заключается в том, как запомнить порядок всех аргументов. Обычно IDE пытаются помочь
        нам, особенно если код хорошо документирован, но все же... Другая проблема заключается в том, как вызвать функцию,
        когда большинство параметров передавать не надо, и значения по умолчанию вполне подходят.</p>
        <p>Разве что вот так?</p>
        <code>showMenu('My menu', undefined, undefined, ['item1', 'item2']);</code>
        <p>Это выглядит ужасно. И становится нечитаемым, когда мы имеем дело с большим количеством параметров.</p>
        <p>На помощь приходит деструктуризация!</p>
        <p>Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные:</p>
        <code>
            let options = {<br>
            &nbsp;&nbsp;title: 'My menu',<br>
            &nbsp;&nbsp;items: ['item1', 'item2']<br>
            };<br>
            <br>
            function showMenu({title = 'Untitled', width = 200, height = 100, items = []}) {...}<br>
            showMenu(options);
        </code>
        <p>Полный синтаксис такой же, как для деструктурирующего присваивания:</p>
        <code>
            function({<br>
            &nbsp;&nbsp;incomingProperty: varName = defaultValue<br>
            ...<br>
            })
        </code>
        <p>Тогда для объекта с параметрами будет создана переменная <code>varName</code> для свойства с именем
        <code>incomingProperty</code> по умолчанию равная <code>defaultValue</code>.</p>
        <p>Такое деструктурирование подразумевает, что в <code>showMenu()</code> будет обязательно передан аргумент.
        Если нам нужны все значения по умолчанию, то нам следует передать пустой объект:</p>
        <code>
            showMenu({}); // ОК, все значения - по умолчанию<br>
            showMenu(); // так была бы ошибка
        </code>
        <p>Мы можем исправить это, сделав <code>{}</code> значением по умолчанию для всего объекта параметров:</p>
        <code>
            function showMenu({title = 'Untitled', width = 100, height = 200} = {}) {...}<br>
            showMenu();
        </code>
        <p>В приведенном выше коде весь объект аргументов по умолчанию равен <code>{}</code>, поэтому всегда есть что-то,
        что можно деструктурировать.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <ul>
            <li>Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.</li>
            <li>
                <p>Полный синтаксис для объекта:</p>
                <code>
                    let {prop: varName = defaultValue, ...rest} = object
                </code>
                <p>Свойство <code>prop</code> объекта <code>object</code> здесь должно быть присвоено переменной
                <code>varName</code>. Если в объекте отсутствует такое свойство, переменной <code>varName</code>
                присваивается значение по умолчанию.</p>
                <p>Свойства, которые не были упомянуты, копируются в объект <code>rest</code>.</p>
            </li>
            <li>
                <p>Полный синтаксис для массива:</p>
                <code>let [item1 = defaultValue, item2, ...rest] = array</code>
                <p>Первый элемент отправляется в <code>item1</code>, второй отправляется в <code>item2</code>, все остальные
                элементы попадают в <code>rest</code>.</p>
            </li>
            <li>Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру,
            что и правая.</li>
        </ul>
    </article>
</body>
</html>

<script src="script.js"></script>