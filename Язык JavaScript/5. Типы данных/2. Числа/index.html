<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Числа</title>
    <link href="../../../style.css" type="text/css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Числа</h2>
        <p>В современном JavaScript существует два типа чисел:</p>
        <ol>
            <li>Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют «числа с плавающей
            точкой двойной точности». Это числа, которые мы будем использовать чаще всего.</li>
            <li><code>BigInt</code> числа дают возможность работать с целыми числами произвольной длины. Они нужны достаточно
            редко и используются, когда необходимо работать со значениями более чем <code>(2<sup>53</sup>-1)</code> или
            более чем <code>-(2<sup>53</sup>-1)</code>.</li>
        </ol>
    </article>

    <article>
        <h2>Способы записи числа</h2>
        <p>Представьте, что нам надо записать число 1 миллиард. Самый очевидный путь:</p>
        <code>let billion = 1000000000;</code>
        <p>Мы также можем использовать символ нижнего подчёркивания <code>_</code> в качестве разделителя:</p>
        <code>let billion = 1_000_000_000;</code>
        <p>Символ нижнего подчеркивания <code>_</code> - это «синтаксический сахар», он делает число более читабельным.
        Движок JavaScript попросту игнорирует <code>_</code> между цифрами, поэтому в примере выше получается точно такой же
        миллиард, как и в первом случае.</p>
        <p>В JavaScript, чтобы укоротить запись числа, мы можем добавить к нему букву <code>e</code> и указать необходимое
        количество нулей:</p>
        <code>let billion = 1e9;</code>
        <p>Другими словами, <code>e</code> умножает число на <code>1</code> с указанным количеством нулей.</p>
        <p>А сейчас давайте запишем что-нибудь очень маленькое. К примеру, 1 микросекунду (одна миллионная секунды):</p>
        <code>let mcs = 0.000001;</code>
        <p>В этом случае нам также поможет <code>e</code>. Если мы хотим избежать длинной последовательности из нулей, мы
        можем сделать так:</p>
        <code>let mcs = 1e-6;</code>
        <p>Другими словами, отрицательное число после <code>e</code> подразумевает деление на <code>1</code> с указанным
        количеством нулей.</p>
    </article>

    <article>
        <h2>Шестнадцатеричные, двоичные и восьмеричные числа</h2>
        <p>Шестнадцатеричные числа широко используются в JavaScript для представления цветов, кодировки символов и многого
        другого. Естественно, есть короткий стиль записи: <code>0x</code>, после которого указывается число.</p>
        <p>Например:</p>
        <code>alert(0xff) // 255</code><br>
        <code>alert(0xFF) // 255 (регистр не имеет значения)</code>
        <p>Двоичные и восьмеричные числа используются не так часто, но они также поддерживаются: <code>0b</code>
        для двоичных и <code>0o</code> для восьмеричных:</p>
        <code>let a = 0b11111111; // 255</code><br>
        <code>let b = 0o377; // 255</code><br>
        <code>alert(a == b); // true</code>
        <p>Есть только 3 системы счисления с такой поддержкой. Для других систем счисления используется функция <code>parseInt</code>.</p>
    </article>

    <article>
        <h2>toString(base)</h2>
        <p>Метод <code>num.toString(base)</code> возвращает строковое представление числа <code>num</code> в системе счисления
        <code>base</code>.</p>
        <p><code>base</code> может варьироваться от <code>2</code> до <code>36</code> (по умолчанию <code>10</code>).</p>
        <p>Часто используемые:</p>
        <ul>
            <li><b>base=16</b> - для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть
            <code>0...9</code> или <code>A...F</code>.</li>
            <li><b>base=2</b> - обычно используется для отладки побитовых операций, цифры <code>0</code> или <code>1</code>.</li>
            <li><b>base=36</b> - максимальное основание, цифры могут быть <code>0...9</code> или <code>A...Z</code>.
            То есть, используется весь латинский алфавит для представления числа. Забавно, но можно использовать
            <code>36</code>-разрядную систему счисления для получения короткого представления большого числового идентификатора.
            К примеру, для создания короткой ссылки. Для этого просто преобразуем его в 36-разрядную систему счисления:
            <code>alert(123456..toString(36); // 2n9c</code></li>
        </ul>

        <article class="warning">
            <h2>Две точки для вызова метода</h2>
            <p>Внимание! Две точки в <code>123456..toString(36)</code> это не опечатка. Если нам надо вызвать метод непосредственно
            на числе, как <code>toString</code> в примере выше, то нам надо поставить две точки <code>..</code> после числа.</p>
            <p>Если мы поставим одну точку: <code>123456.toString(36)</code>, тогда это будет ошибкой, поскольку синтаксис
            JavaScript предполагает, что после первой точки начинается десятичная часть. А если поставить две точки, то
            JavaScript понимает, что десятичная часть отсутствует, и начинается метод.</p>
            <p>Также можно записать как <code>(123456).toString(36)</code>.</p>
        </article>
    </article>

    <article>
        <h2>Округление</h2>
        <p>Одна из часто используемых операций при работе с числами - это округление.</p>
        <p>В JavaScript есть несколько встроенных функций для работы с округлением:</p>
        <ul>
            <li><code>Math.floor</code><br>
            Округление в меньшую сторону: <code>3.1</code> становится <code>3</code>, а <code>-1.1</code> - <code>-2</code>.</li>
            <li><code>Math.ceil</code><br>
            Округление в большую сторону: <code>3.1</code> становится <code>4</code>, а <code>-1.1</code> - <code>-1</code>.</li>
            <li><code>Math.round</code><br>
            Округление до ближайшего целого: <code>3.1</code> становится <code>3</code>, <code>3.6</code> - <code>4</code>, а
            <code>-1.1</code> - <code>-1</code>.</li>
            <li><code>Math.trunc</code><br>
            Производит удаление дробной части без округления: <code>3.1</code> становится <code>3</code>, а
            <code>-1.1</code> - <code>-1</code>.</li>
        </ul>
        <p>Эти функции охватывают все возможные способы обработки десятичной части. Что если нам надо округлить число до
        <code>n-ого</code> количества цифр в дробной части?</p>
        <p>Например, у нас есть <code>1.2345</code> и мы хотим округлить число до 2-х знаков после запятой, оставив только
        <code>1.23</code>.</p>
        <p>Есть два пути решения:</p>
        <ol>
            <li>
                <p>Умножить и разделить.</p>
                <p>Например, чтобы округлить число до второго знака после запятой, мы можем умножить число на <code>100</code>,
                вызвать функцию округления и разделить обратно.</p>
                <code>
                    let num = 1.23456;<br>
                    alert(Math.round(num * 100) / 100)); // 1.23456 -> 123.456 -> 123 -> 1.23
                </code>
            </li>
            <li>
                <p>Метод <code>toFixed(n)</code> округляет число до <code>n</code> знаков после запятой и возвращает
                строковое представление результата.</p>
                <code>let num = 12.34;</code><br>
                <code>alert(num.toFixed(1)); // '12.3'</code>
                <p>Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу
                <code>Math.round</code>:</p>
                <code>let num = 12.36;</code><br>
                <code>alert(num.toFixed(1)); // '12.4'</code>
                <p>Обратите внимание, что результатом <code>toFixed</code> является строка. Если десятичная часть короче,
                чем необходимо, будут добавлены нули в конец строки:</p>
                <code>let num = 12.34;</code><br>
                <code>alert(num.toFixed(5)); // '12.34000'</code>
                <p>Мы можем преобразовать полученное значение в число, используя унарный оператор <code>+</code> или
                <code>Number()</code>.</p>
            </li>
        </ol>
    </article>

    <article>
        <h2>Неточные вычисления</h2>
        <p>Для хранения числа используется 64 бита: 52 из них используется для хранения цифр, 11 для хранения положения
        десятичной точки и один бит отведен на хранение знака.</p>
        <p>Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернет бесконечность.</p>
        <p>Наиболее часто встречающаяся ошибка при работе с числами в JavaScript - это потеря точности.</p>
        <p>Посмотрите на это сравнение:</p>
        <code>alert(0.1 + 0.2 == 0.3); // false</code>
        <p>Да-да, сумма <code>0.1</code> и <code>0.2</code> не равна <code>0.3</code>.</p>
        <p>Странно! Что тогда, если не <code>0.3</code>?</p>
        <code>alert(0.1 + 0.2); // 0.30000000000000004</code>
        <p>Но почему это происходит?</p>
        <p>Число хранится в памяти в бинарной форме, как последовательность бит - единиц и нулей. Но дроби, такие как
        <code>0.1</code>, <code>0.2</code>, которые выглядят довольно просто в десятичной системе счисления, на самом деле
        являются бесконечной дробью в двоичной форме.</p>
        <p>Другими словами, что такое <code>0.1</code>? Это единица деленная на десять - <code>1/10</code>, одна десятая.
        В десятичной системе счисления такие числа легко представимы, по сравнению с одной третьей: <code>1/3</code>,
        которая становится бесконечной дробью <code>0.33333(3)</code>.</p>
        <p>Деление на <code>10</code> гарантированно хорошо работает в десятичной системе, но деление на <code>3</code> - нет.
        По той же причине и в двоичной системе счисления, деление на <code>2</code> обязательно сработает, а <code>1/10</code>
        становится бесконечной дробью.</p>
        <p>В JavaScript нет возможности для хранения точных значений 0.1 или 0.2, используя двоичную систему, точно также,
        как нет возможности хранить одну третью в десятичной системе счисления.</p>
        <p>Числовой формат IEEE-754 решает эту проблему путем округления до ближайшего возможного числа. Правила округления
        обычно не позволяют нам увидеть эту «крошечную потерю точности», но она существует.</p>
        <p>Пример:</p>
        <code>alert(0.1toFixed(20)); // 0.10000000000000000555</code>
        <p>И когда мы суммируем 2 числа, их «неточности» тоже суммируются.</p>
        <p>Вот почему <code>0.1 + 0.2</code> - это не совсем <code>0.3</code>.</p>
        <p>Можно ли обойти проблему? Конечно, наиболее надежный способ - это округлить результат, используя метод
        <code>toFixed(n)</code>:</p>
        <code>
            let sum = 0.1 + 0.2;<br>
            alert(sum.toFixed(2)); // '0.30'
        </code>
        <p>Помните, что метод <code>toFixed</code> всегда возвращает строку. Это гарантирует, что результат будет с заданным
        количеством цифр в десятичной части. Также это удобно для формирования цен в интернет-магазине <code>$0.30</code>.
        В других случаях можно использовать унарный оператор <code>+</code>, чтобы преобразовать строку в число.</p>
        <p>Также можно временно умножить число на 100 (или на большее), чтобы привести его к целому, выполнить математические
        действия, а после разделить обратно. Суммируя целые числа, мы уменьшаем погрешность, но она все равно появится
        при финальном делении.</p>
        <p>Таким образом, метод умножения/деления уменьшает погрешность, но полностью ее не решает.</p>
    </article>

    <article>
        <h2>Проверка: ifFinite и isNaN</h2>
        <p>Помните эти специальные числовые значения?</p>
        <ul>
            <li><code>Infinity</code> (и <code>-Infinity</code>) - особенное численное значение, которое ведет себя в точности
            как математическая бесконечность ∞.</li>
            <li><code>NaN</code> представляет ошибку.</li>
        </ul>
        <p>Эти числовые значения принадлежат типу <code>number</code>, но они не являются «обычными» числами, поэтому есть функции
        для их проверки:</p>
        <ul>
            <li>
                <code>isNaN(value)</code> преобразует значение в число и проверяет является ли оно <code>NaN</code>:
                <code>alert(isNaN(NaN)); // true</code><br>
                <code>alert(isNaN('str')); // true</code>
                <p>Нужна ли нам эта функция? Разве не можем ли мы просто сравнить <code>=== NaN</code>? К сожалению, нет.</p>
                <p>Значение <code>NaN</code> уникально тем, что оно не является равным ничему другому, даже самому себе:</p>
                <code>alert(NaN === NaN); // false</code>
            </li>
            <li>
                <code>isFinite(value)</code> преобразует аргумент в число и возвращает <code>true</code>, если оно является
                обычным числом, т.е. не <code>NaN/Infinity/-Infinity</code>:
                <code>alert(isFinity('15)); // true</code><br>
                <code>alert(isFinity('str')); // false</code><br>
                <code>alert(isFinity(Infinity)); // false</code>
            </li>
        </ul>
        <p>Иногда <code>isFinite</code> используется для проверки, содержится ли в строке число.</p>
        <p>Помните, что пустая строка интерпретируется как <code>0</code> во всех числовых функциях, включая <code>isFinite</code>.</p>

        <article class="note">
            <h2><code>Number.isNaN</code> и <code>Number.isFinite</code></h2>
            <p>Методы <code>Number.isNaN</code> и <code>Number.isFinite</code> - это более «строгие» версии функций
            <code>isNaN</code> и <code>isFinite</code>. Они не преобразуют аргумент в число, а наоборот проверяют, является ли
            аргумент числом (принадлежит ли он типу <code>number</code>).</p>
            <ul>
                <li><code>Number.isNaN(value)</code> возвращает <code>true</code> только в том случае, если аргумент принадлежит
                к типу <code>number</code> и является <code>NaN</code>. Во всех остальных случаях возвращается <code>false</code>.</li>
                <li><code>Number.isFinite(value)</code> возвращает <code>true</code> только в том случае, если аргумент
                принадлежит к типу <code>number</code> и не является <code>NaN/Infinity/-Infinity</code>. Во всех остальных
                случаях возвращает <code>false</code>.</li>
            </ul>
            <p>Не стоит считать <code>Number.isNaN</code> и <code>Number.isFinite</code> более «корректными» версиями функций
            <code>isNaN</code> и <code>isFinite</code>. Это дополняющие друг друга инструменты для разных задач.</p>
        </article>

        <article class="note">
            <h2>Сравнение <code>Object.is</code></h2>
            <p>Существует специальный метод <code>Object.is</code>, который сравнивает значения примерно как <code>===</code>, но
            более надежен в двух особых ситуациях:</p>
            <ol>
                <li>Работает с <code>NaN</code>: <code>Object.is(NaN, NaN) === true</code>, здесь он хорош.</li>
                <li>Значения <code>0</code> и <code>-0</code> разные: <code>Object.is(0, -0) === false</code>, это редко
                используется, но технически эти значения разные.</li>
            </ol>
            <p>Во всех других случаях <code>Object.is(a, b)</code> идентичен <code>a === b</code>.</p>
        </article>
    </article>

    <article>
        <h2>parseInt и parseFloat</h2>
        <p>Для явного преобразования к числу можно использовать <code>+</code> или <code>Number()</code>. Если строка
        не является в точности числом, то результат будет <code>NaN</code>.</p>
        <p>Единственное исключение - это пробелы в начале и в конце, они игнорируются.</p>
        <p>В реальной жизни мы часто сталкиваемся со значениями у которых есть единица измерения, например <code>'100px'</code>
        или <code>'12pt'</code> в CSS. Также во множестве стран символ валюты записывается после номинала <code>'19€'</code>.
        Так как нам получить числовое значение из таких строк?</p>
        <p>Для этого есть <code>parseInt</code> и <code>parseFloat</code>.</p>
        <p>Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число.
        Функция <code>parseInt</code> возвращает целое число, а <code>parseFloat</code> возвращает число с плавающей точкой.</p>
        <code>
            alert(parseInt('100px')); // 100<br>
            alert(parseFloat('12.5em')); // 12.5<br>
            <br>
            alert(parseInt('12.3')); // 12<br>
            alert(parseFloat('12.3.4')); // 12.3
        </code>
        <p>Функции <code>parseInt/parseFloat</code> вернут <code>NaN</code>, если не смогли прочитать ни одну цифру:</p>
        <code>alert(parseInt('a123')); // NaN, на первом символе происходит остановка чтения</code>

        <article class="note">
            <h2>Второй аргумент <code>parseInt(str, radix)</code></h2>
            <p>Функция <code>parseInt()</code> имеет необязательный второй параметр. Он определяет систему счисления,
            таким образом <code>parseInt</code> может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:</p>
            <code>
                alert(parseInt('0xff', 16)); // 255<br>
                alert(parseInt('ff', 16)); // 255, без 0x тоже работает<br>
                alert(parseInt('2n9c', 36)); // 123456
            </code>
        </article>
    </article>

    <article>
        <h2>Другие математические функции</h2>
        <p>В JavaScript встроен объект <code>Math</code>, который содержит различные математические функции и константы.</p>
        <p>Несколько примеров:</p>
        <ul>
            <li>
                <p><code>Math.random()</code></p>
                <p>Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)</p>
            </li>
            <li>
                <p><code>Math.max(a, b, c, ...)</code>, <code>Math.min(a, b, c, ...)</code></p>
                <p>Возвращает наибольшее/наименьшее число из перечисленных аргументов.</p>
            </li>
            <li>
                <p><code>Math.pow(n, power)</code></p>
                <p>Возвращает число <code>n</code>, возведенное в степень <code>power</code>.</p>
            </li>
        </ul>
        <p>В объекте <code>Math</code> есть множество функций и констант, включая тригонометрические функции.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Чтобы писать числа с большим количеством нулей:</p>
        <ul>
            <li>Используйте краткую форму записи чисел - <code>e</code>, с указанным количеством нулей. Например:
            <code>123e6</code> это <code>123</code> с 6-ю нулями <code>123000000</code>.</li>
            <li>Отрицательное число после <code>e</code> приводит к делению числа на 1 с указанным количеством нулей.
            Например: <code>123e-6</code> это <code>0.000123</code>.</li>
        </ul>
        <p>Для других систем счисления:</p>
        <ul>
            <li>Можно записывать числа сразу в шестнадцатеричной (<code>0x</code>), восьмеричной (<code>0o</code>) и
            бинарной (<code>0b</code>) системах счисления.</li>
            <li><code>parseInt(str, base)</code> преобразует строку в целое число в соответствии с указанной системой счисления:
            <code>2 ≤ base ≤ 36</code>.</li>
            <li><code>num.toString(value, base)</code> представляет число в строковом виде в указанной системе счисления
            <code>base</code>.</li>
        </ul>
        <p>Для проверки на <code>NaN</code> и <code>Infinity</code>:</p>
        <ul>
            <li><code>isNaN(value)</code> преобразует аргумент в число и проверяет, является ли оно <code>NaN</code>.</li>
            <li><code>Number.isNaN(value)</code> проверяет, является ли аргумент числом, и если да, то проверяет, является
            ли оно <code>NaN</code>.</li>
            <li><code>isFinite(value)</code> преобразует аргумент в число и проверяет, что оно не является
            <code>NaN/Infinity/-Infinity</code>.</li>
            <li><code>Number.isFinite(value)</code> проверяет, является ли аргумент числом, и если да, то проверяет, что оно
            не является <code>NaN/Infinity/-Infinity</code>.</li>
        </ul>
        <p>Для преобразования значений типа <code>12pt</code> и <code>100px</code> в число:</p>
        <ul>
            <li>используйте <code>parseInt/parseFloat</code> для «мягкого» преобразования строки в число, данные функции
            по порядку считывают число из строки до тех пор, пока не возникнет ошибка.</li>
        </ul>
        <p>Для дробей:</p>
        <ul>
            <li>Используйте округления <code>Math.floor</code>, <code>Math.ceil</code>, <code>Math.trunc</code>,
            <code>Math.round</code> или <code>num.toFixed(n)</code>.</li>
            <li>Помните, что при работе с дробями происходит потеря точности.</li>
        </ul>
    </article>
</body>
</html>

<script src="script.js"></script>