<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Массивы</title>
    <link href="../../../style.css" type="text/css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Массивы</h2>
        <p>Довольно часто мы понимаем, что нам необходимо <i>упорядоченная коллекция</i> данных, в которой присутствуют
        1-й, 2-й, 3-й элементы и т.д.</p>
        <p>В этом случае использовать объект неудобно, так как он не предоставляет методов управления порядком элементов.
        Мы не можем вставить новое свойство «между» уже существующими. Объекты просто не предназначены для этих целей.</p>
        <p>Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, <code>Array</code>.</p>
    </article>

    <article>
        <h2>Объявление</h2>
        <p>Существует два варианта синтаксиса для создания пустого массива:</p>
        <code>let arr = new Array();</code><br>
        <code>let arr = [];</code>
        <p>Практически всегда используется второй вариант синтаксиса. В скобках мы можем указать начальные значения элементов:</p>
        <code>let fruits = ['Яблоко', 'Апельсин', 'Слива'];</code>
        <p>Элементы массива нумеруются, начиная с нуля.</p>
        <p>Мы можем получить элемент, указав его номер в квадратных скобках:</p>
        <code>alert(fruits['Яблоко']); // Яблоко</code>
        <p>Мы можем заменить элемент.</p>
        <code>fruits[2] = 'Груша'; // ['Яблоко', 'Апельсин', 'Груша']</code>
        <p>...Или добавить новый к существующему массиву:</p>
        <code>fruits[3] = 'Лимон'; // ['Яблоко', 'Апельсин', 'Груша', 'Лимон']</code>
        <p>Общее число элементов массива содержится в его свойстве <code>length</code>.</p>
        <p>В массиве могут храниться элементы любого типа.</p>
    </article>

    <article>
        <h2>Получение последних элементов при помощи «at»</h2>
        <p>Допустим нам нужен последний элемент массива.</p>
        <p>Некоторые языки программирования позволяют использовать отрицательные индексы для той же цели, как-то так:
        <code>fruits[-1]</code>.</p>
        <p>Однако, в JavaScript такая запись не сработает. Ее результатом будет <code>undefined</code>, поскольку индекс
        в квадратных скобках понимается буквально.</p>
        <p>Мы можем явно вычислить индекс последнего элемента, а затем получить у нему доступ вот так:</p>
        <code>fruits[fruits.length - 1]</code>
        <p>Есть более короткий синтаксис: <code>fruits.at(-1)</code>.</p>
        <p>Другими словами, <code>arr.at(i)</code>:</p>
        <ul>
            <li>Это ровно то же самое, что и <code>arr[i]</code>, если <code>i >= 0</code>.</li>
            <li>Для отрицательных значений <code>i</code>, он отступает от конца массива.</li>
        </ul>
    </article>

    <article>
        <h2>Методы pop/push, shift/unshift</h2>
        <p>Очередь - один из самых распространенных вариантов применения массива. В области компьютерных наук так называется
        упорядоченная коллекция элементов, поддерживающая два вида операций:</p>
        <ul>
            <li><code>push</code> добавляет элемент в конец.</li>
            <li><code>shift</code> удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.</li>
        </ul>
        <p>Массивы поддерживают обе операции.</p>
        <p>Существует и другой вариант применения массивов - структура данных, называемая стек.</p>
        <p>Она поддерживает два вида операций:</p>
        <ul>
            <li><code>push</code> добавляет элемент в конец.</li>
            <li><code>pop</code> удаляет последний элемент.</li>
        </ul>
        <p>Таким образом, новые элементы всегда добавляются или удаляются из «конца».</p>
        <p>Массивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало,
        так и в конец массива.</p>
        <p>В компьютерных науках структура данных, делающая это возможным, называется двусторонняя очередь.</p>
        <p><b>Методы работающие с концом массива:</b></p>
        <ul>
            <li>
                <p><code>pop</code></p>
                <p>Удаляет последний элемент из массива и возвращает его</p>
            </li>
            <li>
                <p><code>push</code></p>
                <p>Добавляет элемент в конец массива.</p>
            </li>
        </ul>
        <p><b>Методы, работающие с началом массива:</b></p>
        <ul>
            <li>
                <p><code>shift</code></p>
                <p>Удаляет из массива первый элемент и возвращает его</p>
            </li>
            <li>
                <p><code>unshift</code></p>
                <p>Добавляет элемент в начало массива.</p>
            </li>
        </ul>
        <p>Методы <code>push</code> и <code>unshift</code> могут добавлять сразу несколько элементов.</p>
    </article>

    <article>
        <h2>Внутреннее устройство массива</h2>
        <p>Массив - это особый подвид объектов. Квадратные скобки, используемые для того, чтобы получить доступ к свойству
        <code>arr[0]</code> - это по сути обычный синтаксис доступа по ключу, как <code>obj[key]</code>, где в роли
        <code>obj</code> у нас <code>arr</code>, а в качестве ключа - числовой индекс.</p>
        <p>Массивы расширяют объекты, так как предусматривают специальные методы для работы с упорядоченными коллекциями данных,
        а также свойство <code>length</code>. Но в основе все равно лежит объект.</p>
        <p>Следует помнить, что в JavaScript существует 8 типов данных. Массив является объектом, и, следовательно,
        ведет себя как объект. Например, копируется по ссылке.</p>
        <p>Но то, что действительно делает массивы особенными - это их внутреннее представление. Движок JavaScript старается
        хранить элементы массива в непрерывной области памяти, один за другим. Существуют и другие способы оптимизации,
        благодаря которым массивы работают очень быстро.</p>
        <p>Но все они утратят эффективность, если мы перестанем работать с массивом как с «упорядоченной коллекцией данных»
        и начнем использовать его как обычный объект.</p>
        <p>Например, технически мы можем сделать следующее:</p>
        <code>
            let arr = []; // Создаем массив<br>
            <br>
            arr[999] = 5; // Создаем свойство с индексом, намного превышающим длину массива<br>
            <br>
            arr.age = 25; // Создаем свойство с произвольным именем
        </code>
        <p>Это возможно, потому что в основе массива лежит объект. Мы можем присвоить ему любые свойства.</p>
        <p>Но движок поймет, что мы работаем с массивом, как с обычным объектом. Способы оптимизации, используемые для массивов,
        в этом случае не подходят, поэтому они будут отключены и никакой выгоду не принесут.</p>
        <p>Массив следует считать особой структурой, позволяющей работать с упорядоченными данными. Для этого массивы
        предоставляют специальные методы. Массивы тщательно настроены в движках JavaScript для работы с однотипными упорядоченными
        данными, поэтому использовать их нужно именно в таких случаях.</p>
    </article>

    <article>
        <h2>Эффективность</h2>
        <p>Методы <code>push/pop</code> выполняются быстро, а <code>shift/unshift</code> - медленно.</p>
        <p>Почему работать с концом массива быстрее, чем с его началом?</p>
        <p>Просто взять и удалить элемент с номером <code>0</code> недостаточно. Нужно также заново пронумеровать
        остальные элементы.</p>
        <p>Операция <code>shift</code> должна выполнить 3 действия:</p>
        <ol>
            <li>Удалить элемент с индексом <code>0</code>.</li>
            <li>Сдвинуть все элементы влево, заново пронумеровать их, заменив <code>1</code> на <code>0</code>,
            <code>2</code> на <code>1</code> и т.д.</li>
            <li>Обновить свойство <code>length</code>.</li>
        </ol>
        <p><b>Чем больше элементов содержит массив, тем больше времени потребуется для того, чтобы их переместить,
        больше операций с памятью.</b></p>
        <p>То же самое происходит с <code>unshift</code>: чтобы добавить элемент в начало массива, нам нужно сначала сдвинуть
        существующие элементы вправо, увеличивая их индексы.</p>
        <p>А что же с <code>push/pop</code>? Им не нужно ничего перемещать. Чтобы удалить элемент в конце массива, метод
        <code>pop</code> очищает индекс и уменьшает значение <code>length</code>.</p>
        <p><b>Метод <code>pop</code> не требует перемещения, потому что остальные элементы остаются с теми же индексами.
        Именно поэтому он выполняет очень быстро.</b></p>
        <p>Аналогично работает метод <code>push</code>.</p>
    </article>

    <article>
        <h2>Перебор элементов</h2>
        <p>Одним из самых старых способов перебора элементов массива является цикл <code>for (;;)</code> по цифровым индексам:</p>
        <code>
            let arr = ['Яблоко', 'Апельсин', 'Груша'];<br>
            <br>
            for (let i = 0, i < arr.length, i++) {<br>
            &nbsp;&nbsp;alert(arr[i]);<br>
            }
        </code>
        <p>Но для массивов возможен и другой вариант цикла <code>for...of</code>:</p>
        <code>
            let arr = ['Яблоко', 'Апельсин', 'Груша'];<br>
            <br>
            for (let fruit of arr) {<br>
            &nbsp;&nbsp;alert(fruit);<br>
            }
        </code>
        <p>Цикл <code>for...of</code> не предоставляет доступа к номеру текущего элемента, только к его значению, но в
        большинстве случаев этого достаточно. А также это короче.</p>
        <p>Технически, так как массив является объектом, можно использовать и вариант <code>for...in</code>.</p>
        <p>Но на самом деле это - плохая идея. Существуют скрытые недостатки этого способа:</p>
        <ol>
            <li>
                <p>Цикл <code>for...in</code> выполняет перебор всех свойств объекта, а не только цифровых.</p>
                <p>В браузере и других программных средах также существуют так называемые «псевдомассивы» - объекты,
                которые выглядят как массив. То есть, у них есть свойство <code>length</code> и индексы, но они также
                могут иметь дополнительные нечисловые свойства и методы, которые нам обычно не нужны. Тем не менее,
                цикл <code>for...in</code> выведет их. Поэтому, если нам приходится иметь дело с объектами, похожими на массив,
                такие «лишние» свойства могут стать проблемой.</p>
            </li>
            <li>
                <p>Цикл <code>for...in</code> оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз
                медленнее Увеличение скорости выполнение может иметь значение только при возникновении узких мест. Но мы
                всё же должны представлять разницу.</p>
            </li>
        </ol>
        <p>В общем, не следует использовать цикл <code>for...in</code> для массивов.</p>
    </article>

    <article>
        <h2>Немного о «length»</h2>
        <p>Свойство <code>length</code> автоматически обновляется при изменении массива. Есть быть точным, это не количество
        элементов массива, а наибольший цифровой индекс плюс один.</p>
        <p>Например, единственный элемент, имеющий больший индекс, дает большую длину:</p>
        <code>
            let arr = [];<br>
            arr[123] = 1488;<br>
            <br>
            alert(arr.length); // 124
        </code>
        <p>Обратите внимание, что обычно мы не используем массивы таким образом.</p>
        <p>Еще один интересный факт о свойстве <code>length</code> - его можно перезаписать.</p>
        <p>Если мы вручную увеличим его, ничего интересного не произойдет. Зато, если мы уменьшим его, массив станет короче.
        Этот процесс необратим!</p>
        <code>
            let arr = [1, 2, 3, 4, 5];<br>
            <br>
            arr.length = 2;<br>
            alert(arr); // [1, 2]<br>
            <br>
            arr.length = 5;<br>
            alert(arr[3]); // undefined: значения не восстановились
        </code>
        <p>Таким образом, самый простой способ очистить массив - это <code>arr.length = 0;</code>.</p>
    </article>

    <article>
        <h2>new Array()</h2>
        <p>Существует еще один вариант синтаксиса для создания массива:</p>
        <code>let arr = new Array(1, 2, 3);</code>
        <p>Он редко применяется, так как квадратные скобки <code>[]</code> короче. Кроме того, у него есть хитрая особенность.</p>
        <p>Если <code>new Array</code> вызывается с одним аргументом, который представляет из себя число, он создает массив
        без элементов, но с заданной длиной.</p>
    </article>

    <article>
        <h2>Многомерные массивы</h2>
        <p>Массивы могут содержать элементы, которые тоже являются массивами. Это можно использовать для создания многомерных
        массивов.</p>
        <code>
            let matrix = [<br>
            &nbsp;&nbsp;[1, 2, 3],<br>
            &nbsp;&nbsp;[4, 5, 6],<br>
            &nbsp;&nbsp;[7, 8, 9]<br>
            ];<br>
            <br>
            alert(matrix[1][1]); // 5
        </code>
    </article>

    <article>
        <h2>toString</h2>
        <p>Массивы по-своему реализуют метод <code>toString</code>, который возвращает список элементов, разделенных запятыми.</p>
        <p>Например:</p>
        <code>
            let arr = [1, 2, 3];<br>
            <br>
            alert(arr); // 1,2,3
        </code>
        <p>Давайте теперь попробуем следующее:</p>
        <code>
            alert([] + '1'); // '1'<br>
            alert([1] + '1'); // '11'<br>
            alert([1, 2] + '1'); // 1,21
        </code>
        <p>Массивы не имеют ни <code>Symbol.toPrimitive</code>, ни функционирующего <code>valueOf</code>, они реализуют только
        преобразование <code>toString</code>, таким образом, здесь <code>[]</code> становится пустой строкой,
        <code>[1]</code> становится <code>'1'</code>, а <code>[1, 2]</code> становится <code>'1,2'</code>.</p>
        <p>Когда бинарный оператор плюс <code>+</code> добавляет что-либо к строке, он тоже преобразуется в строку.</p>
    </article>

    <article>
        <h2>Не сравнивайте массивы при помощи ==</h2>
        <p>В JavaScript, в отличие от некоторых других языков программирования, массивы не следует сравнивать при помощи
        оператора <code>==</code>.</p>
        <p>У этого оператора нет специального подхода к массивам, он работает с ним, как и с любыми другими объектами.</p>
        <p>Давайте еще раз вспомним правила:</p>
        <ul>
            <li>Два объекта равны друг другу <code>==</code> только в том случае, если они ссылаются на один и тот же объект.</li>
            <li>Если один из аргументов <code>==</code> является объектом, а другой - примитивом, то объект преобразуется в
            примитив.</li>
            <li>... За исключением <code>null</code> и <code>undefined</code>, которые равны <code>==</code> друг другу и
            ничему больше.</li>
        </ul>
        <p>Оператор строго равенства <code>===</code> еще проще, так как он не преобразует типы.</p>
        <p>Итак, если мы все же сравниваем массивы с помощью <code>==</code>, то они никогда не будут одинаковыми,
        если только мы не сравним две переменные, которые ссылаются на один и тот же массив.</p>
        <p>Например:</p>
        <code>
            alert([] == []); // false<br>
            alert([0] == [0]); // false
        </code>
        <p>Технически эти массивы являются разными объектами. Так что они не равны. Оператор <code>==</code> не выполняет
        поэлементное сравнение.</p>
        <p>Сравнение с примитивами также может дать, казалось бы, странные результаты:</p>
        <code>
            alert(0 == []); //true<br>
            alert('0' == []); // false
        </code>
        <p>Здесь в обоих случаях, мы сравниваем примитив с объектом массива. Таким образом, массив <code>[]</code>
        преобразуется в примитив с целью сравнения и становятся пустой строкой <code>''</code>.</p>
        <p>Затем продолжается процесс сравнения с примитивами:</p>
        <code>
            alert(0 == ''); // true<br>
            alert('0' == ''); // false
        </code>
        <p>Так как же сравнить массивы?</p>
        <p>Это просто: не используйте оператор <code>==</code>. Вместо этого сравните их по элементам в цикле или используя
        методы итерации.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Массив - это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.</p>
        <p>Объявление:</p>
        <code>let arr = [1, 2, 3];</code><br>
        <code>let arr = new Array(1, 2, 3);</code>
        <p>Вызов <code>new Array(number)</code> создает массив с заданной длиной, но без элементов.</p>
        <ul>
            <li>Свойство <code>length</code> отражает длину массива, или, если точнее, его последний цифровой индекс
            плюс один. Длина корректируется автоматически методами массива.</li>
            <li>Если мы уменьшаем <code>length</code> вручную, массив укорачивается.</li>
        </ul>
        <p>Получение элементов:</p>
        <ul>
            <li>Мы можем получить элемент по его индексу, например <code>arr[0]</code>.</li>
            <li>Также мы можем использовать метод <code>at(i)</code> для получения элементов с отрицательным индексом,
            для отрицательных значений <code>i</code>, он отступает от конца массива. В остальном он работает так же,
            как <code>arr[i]</code>, если <code>i >= 0</code>.</li>
        </ul>
        <p>Мы можем использовать массив как двустороннюю очередь, используя следующие операции:</p>
        <ul>
            <li><code>push(...items)</code> добавляет <code>items</code> в конец массива.</li>
            <li><code>pop()</code> удаляет элемент в конце массива и возвращает его.</li>
            <li><code>shift()</code> удаляет элемент в начале массива и возвращает его.</li>
            <li><code>unshift(...items)</code> добавляет <code>items</code> в начало массива.</li>
        </ul>
        <p>Чтобы пройтись по элементам массива:</p>
        <ul>
            <li><code>for (let i = 0, i < arr.length, i++)</code> - работает быстрее всего, совместим со старыми браузерами.</li>
            <li><code>for (let item of arr)</code> - современный синтаксис только для значений элементов (к индексам нет
            доступа).</li>
            <li><code>for (let i in arr)</code> - никогда не используйте для массивов!</li>
        </ul>
    </article>
</body>
</html>

<script src="script.js"></script>