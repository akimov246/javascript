<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Преобразование объектов в примитивы</title>
    <link href="../../../style.css" type="text/css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Преобразование объектов в примитивы</h2>
        <p>Что произойдет, если сложить два объекта <code>obj1 + obj2</code>, вычесть один из другого <code>obj1 - obj2</code>
        или вывести на экран, воспользовавшись <code>alert(alert(obj))</code>?</p>
        <p>JavaScript совершенно не позволяет настраивать, как операторы работают с объектами.</p>
        <p>В случае таких операций, объекты автоматически преобразуются в примитивы, затем выполняется сама операция над
        этими примитивами, и на выходе мы получим примитивное значение.</p>
        <p>Это важное ограничение: результатом <code>obj1 + obj2</code> (или другой математической операции) не может быть
        другой объект!</p>
        <p>К примеру, мы не можем создавать объекты, представляющие векторы или матрицы, складывать их и ожидать в качестве
        результата «суммированный» объект.</p>
    </article>

    <article>
        <h2>Правила преобразования</h2>
        <ol>
            <li>Не существует преобразования к логическому значению. В логическом контексте все объекты являются <code>true</code>,
            все просто. Существует лишь их числовое и строковое преобразования.</li>
            <li>Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции.
            Например, объекты <code>Date</code> могут быть вычтены, и результатом <code>date1 - date2</code> будет разница
            во времени между двумя датами.</li>
            <li>Что касается преобразования к строке - оно обычно происходит, когда мы выводим на экран объект при помощи
            <code>alert(obj)</code> и в подобных контекстах.</li>
        </ol>
        <p>Мы можем реализовать свои преобразования к строкам и числам, используя специальные объектные методы.</p>
    </article>

    <article>
        <h2>Хинты</h2>
        <p>Как JavaScript решает, какое преобразование применить?</p>
        <p>Существует три варианта преобразования типов, которые происходят в различных ситуациях. Они называются «хинтами»,
        как описано в спецификации:</p>
        <ul>
            <li>
                <p><code>'string'</code></p>
                <p>Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку,
                например <code>alert</code>:</p>
                <code>
                    // Вывод<br>
                    alert(obj);<br>
                    <br>
                    // Используем объект в качестве ключа<br>
                    anotherObj[obj] = 123;
                </code>
            </li>
            <li>
                <p><code>'number'</code></p>
                <p>Для преобразования объекта к числу, в случае математических операций:</p>
                <code>
                    // Явное преобразование<br>
                    let num = Number(obj);<br>
                    <br>
                    // Математические (не считая бинарного плюса)<br>
                    let n = +obj; // Унарный плюс<br>
                    let delta = date1 - date2;<br>
                    <br>
                    // Сравнения больше/меньше<br>
                    let greater = user1 > user2;
                </code>
                <p>Большинство встроенных математических функций также включают в себя такое преобразование.</p>
            </li>
            <li>
                <p><code>'default'</code></p>
                <p>Происходит редко, когда оператор «не уверен», какой тип ожидать.</p>
                <p>Например, бинарный плюс <code>+</code> может работать как со строками (объединяя их в одну), так и с числами
                (складывая их). Поэтому, если бинарный плюс получает объект в качестве аргумента, он использует хинт
                <code>'default'</code> для его преобразования.</p>
                <p>Также, если объект сравнивается с помощью <code>==</code> со строкой, числом или символом, тоже неясно,
                какое преобразование следует выполнить, поэтому используется хинт <code>'default'</code>.</p>
                <p>Операторы сравнения больше/меньше, такие как <code><</code> <code>></code>, также могут работать как со
                строками, так и с числами. Тем не менее по историческим причинам, они используют хинт <code>'number'</code>,
                а не <code>'default'</code>.</p>
                <p>Впрочем, на практике все намного проще.</p>
                <p>Все встроенные объекты, за исключением одного (объект <code>Date</code>), реализуют <code>'default'</code>
                преобразование таким же способом, что и <code>'number'</code>. И нам следует поступать так же.</p>
            </li>
        </ul>
        <b>Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:</b>
        <ol>
            <li>Вызвать <code>obj[Symbol.toPrimitive](hint)</code> - метод с символьным ключом <code>Symbol.toPrimitive</code>
            (системный символ), если такой метод существует.</li>
            <li>Иначе, если хинт равен <code>'string'</code>, попробовать вызвать <code>obj.toString()</code> или
            <code>obj.valueOf()</code>, смотря какой из них существует.</li>
            <li>Иначе, если хинт равен <code>'number'</code> или <code>'default'</code>, попробовать вызвать
            <code>obj.valueOf()</code> или <code>obj.toString()</code>, смотря какой из них существует.</li>
        </ol>
    </article>

    <article>
        <h2>Symbol.toPrimitive</h2>
        <p>Есть встроенный символ с именем <code>Symbol.toPrimitive</code>, который следует использовать для обозначения метода
        преобразования, вот так:</p>
        <code>
            obj[Symbol.toPrimitive] = function(hint) {<br>
            &nbsp;&nbsp;// Вот код для преобразования этого объекта в примитив<br>
            &nbsp;&nbsp;// он должен вернуть примитивное значение<br>
            &nbsp;&nbsp;// hint = чему-то из 'string', 'number', 'default'<br>
            };
        </code>
        <p>Если метод <code>Symbol.toPrimitive</code> существует, он используется для всех хинтов, и больше никаких методов
        не требуется.</p>
        <p>Например, здесь объект <code>user</code> реализует его:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;name: 'John',<br>
            &nbsp;&nbsp;money: 1000<br>
            <br>
            &nbsp;&nbsp;[Symbol.toPrimitive](hint) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;alert(`hint: ${hint}`);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return hint == 'string' ? `{name: '${this.name}'}` : this.money;<br>
            &nbsp;&nbsp;}<br>
            };<br>
            <br>
            // Демонстрация результатов преобразования<br>
            alert(user); // hint: string -> {name: 'John'}<br>
            alert(+user); // hint: number -> 1000<br>
            alert(user + 500) // hint: default -> 1500
        </code>
        <p>Как мы можем видеть из кода, <code>user</code> становится либо строкой со своим описанием, либо суммой денег
        в зависимости от преобразования. Единый метод <code>user[Symbol.toPrimitive]</code> обрабатывает все случаи преобразования.</p>
    </article>

    <article>
        <h2>toString/valueOf</h2>
        <p>Если нет <code>Symbol.toPrimitive</code>, тогда JavaScript пытается найти методы <code>toString</code> и
        <code>valueOf</code>:</p>
        <ul>
            <li>Для хинта <code>'string'</code>: вызвать метод <code>toString</code>, а если он не существует или
            возвращает объект вместо примитивного значения, то <code>valueOf</code> (таким образом, <code>toString</code>
            имеет приоритет при строковом преобразовании).</li>
            <li>Для других хинтов: вызвать метод <code>valueOf</code>, а если он не существует или возвращает объект вместо
            примитивного значения, то <code>toString</code> (таким образом, <code>valueOf</code> имеет приоритет для
            математических операций).</li>
        </ul>
        <p>Методы <code>toString</code> и <code>valueOf</code> берут свое начало с древних времен. Это не символы (символов
        тогда еще не было), а скорее просто «обычные» методы со строковыми именами. Они представляют альтернативный
        «старомодный» способ реализации преобразования.</p>
        <p>Эти методы должны возвращать примитивное значение. Если <code>toString</code> или <code>valueOf</code> возвращает
        объект, то он игнорируется (так же, как если бы метода не было).</p>
        <p>По умолчанию обычный объект имеет следующие методы <code>toString</code> и <code>valueOf</code>:</p>
        <ul>
            <li>Метод <code>toString</code> возвращает строку <code>'[object Object]'</code>.</li>
            <li>Метод <code>valueOf</code> возвращает сам объект.</li>
        </ul>
        <p>Таким образом, если мы попытаемся использовать объект в качестве строки, как например в <code>alert</code> или
        вроде того, то по умолчанию мы увидим <code>[object Object]</code>.</p>
        <p>Значение по умолчанию <code>valueOf</code> упоминается здесь только для полноты картины, чтобы избежать какой-либо
        путаницы. Как вы можете видеть, он возвращает сам объект и поэтому игнорируется. Так что мы можем предположить,
        что его не существует.</p>
        <p>Давайте применим эти методы для настройки преобразования.</p>
        <p>Для примера, используем их в реализации все того же объекта <code>user</code>. Но уже используя комбинацию
        <code>toString</code> и <code>valueOf</code> вместо <code>Symbol.toPrimitive</code>:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;name: 'John',<br>
            &nbsp;&nbsp;money: 1000,<br>
            <br>
            &nbsp;&nbsp;// Для хинта равного 'string'<br>
            &nbsp;&nbsp;toString() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return `{name: '${this.name}'}`;<br>
            &nbsp;&nbsp;},<br>
            <br>
            &nbsp;&nbsp;// Для хинта равного 'number' или 'default'<br>
            &nbsp;&nbsp;valueOf() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return this.money;<br>
            &nbsp;&nbsp;}<br>
            };<br>
            <br>
            alert(user); // toString() -> {name: 'John'}<br>
            alert(+user); // valueOf() -> 1000<br>
            alert(user + 500); // valueOf -> 1500
        </code>
        <p>Как мы видим, получилось то же поведение, что и в предыдущем примере с <code>Symbol.toPrimitive</code>.</p>
    </article>

    <article>
        <h2>Преобразование может вернуть любой примитивный тип</h2>
        <p>Важная вещь, которую следует знать обо всех методах преобразования примитивов, заключается в том,
        что они не обязательно возвращают подсказанный хинтом примитив.</p>
        <p>Нет никакого контроля над тем, вернет ли <code>toString</code> именно строку, или чтобы метод
        <code>Symbol.toPrimitive</code> возвращал именно число для хинта <code>'number'</code>.</p>
        <p>Единственное обязательное условие: эти методы должны возвращать примитив, а не объект.</p>
    </article>

    <article>
        <h2>Дальнейшие преобразования</h2>
        <p>Как мы уже знаем, многие операторы и функции выполняют преобразование типов, например, умножение <code>*</code>
        преобразует операнды в числа.</p>
        <p>Если мы передаем объект в качестве аргумента, то в вычислении будет две стадии:</p>
        <ol>
            <li>Объект преобразуется в примитив (с использованием правил, описанных выше).</li>
            <li>Если необходимо для дальнейших вычислений, этот примитив преобразуется дальше.</li>
        </ol>
        <p>Например:</p>
        <code>
            let obj = {<br>
            &nbsp;&nbsp;// toString обрабатывает все преобразования в случае отсутствия других методов<br>
            &nbsp;&nbsp;toString() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return '2';
            &nbsp;&nbsp;}<br>
            };<br>
            <br>
            alert(obj * 2); // 4, объект был преобразован к примитиву '2', затем умножение сделало его числом
        </code>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Преобразование объекта в примитив вызывается автоматически многими встроенными функциями и операторами, которые
        ожидают примитив в качестве значения.</p>
        <p>Существует всего 3 типа (хинта) для этого:</p>
        <ul>
            <li><code>'string'</code> (для <code>alert</code> и других операций, которым нужна строка)</li>
            <li><code>'number'</code> (для математических операций)</li>
            <li><code>'default'</code> (для некоторых других операторов, обычно объекты реализуют его как <code>'number'</code></li>
        </ul>
        <p>Спецификация явно описывает для каждого оператора, какой ему следует использовать хинт.</p>
        <p>Алгоритм преобразования таков:</p>
        <ol>
            <li>Сначала вызывается метод <code>obj[Symbol.toPrimitive](hint)</code>, если он существует.</li>
            <li>В случае, если хинт равен <code>'string'</code>, происходит попытка вызвать <code>obj.toString()</code> и
            <code>obj.valueOf()</code>, смотря что есть.</li>
            <li>В случае, если хинт равен <code>'number'</code> или <code>'default'</code>, происходит попытка
            вызвать <code>obj.valueOf()</code> и <code>obj.toString()</code>, смотря что есть.</li>
        </ol>
        <p>Все эти методы должны возвращать примитив (если определены).</p>
        <p>На практике часто достаточно реализовать только <code>obj.toString()</code> в качестве универсального метода для
        преобразования к строке, который должен возвращать удобочитаемое представление объекта для целей логирования или отладки.</p>
    </article>
</body>
</html>