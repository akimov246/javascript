<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Копирование объектов и ссылки</title>
    <link href="../../../style.css" type="text/css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Копирование объектов и ссылки</h2>
        <p>Одно из фундаментальных отличий объектов от примитивов заключается в том, что объекты хранятся и копируются
        «по ссылке», тогда как примитивные значения: строки, числа, логические значения и т.д. - всегда копируются
        «как целое значение».</p>
        <p><b>Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» - другими словами,
        «ссылку» на него.</b></p>
        <p>Когда мы выполняем действия с объектом, к примеру, берем свойство, движок JavaScript просматривает то,
        что находится по этому адресу, и выполняет операцию над самим объектом.</p>
        <p><b>При копировании переменной объекта копируется ссылка, но сам объект не дублируется.</b></p>
        <p>Мы можем использовать любую переменную для доступа к объекту и изменения его содержимого.</p>
    </article>

    <article>
        <h2>Сравнение по ссылке</h2>
        <p>Два объекта равны только в том случае, если это один и тот же объект.</p>
        <p>Для сравнения типа <code>obj1 > obj2</code> или для сравнения с примитивом <code>obj == 5</code> объекты
        преобразуются в примитивы.</p>
    </article>

    <article>
        <h2>Клонирование и объединение, Object.assign</h2>
        <p>Что если нам нужно дублировать объект? Создать независимую копию, клон?</p>
        <p>Это тоже выполнимо, но немного сложнее, потому что в JavaScript для этого нет встроенного метода.
        Но на самом деле в этом редко возникает необходимость, копирования по ссылке в большинстве случаев вполне хватает.</p>
        <p>Но если мы действительно этого хотим, то нам нужно создать новый объект и воспроизвести структуру существующего,
        перебрав его свойства и скопировав их на примитивном уровне.</p>
        <p>Например, так:</p>
        <code>
            let user {<br>
            &nbsp;&nbsp;name: 'John',<br>
            &nbsp;&nbsp;age: 30<br>
            };<br>
            <br>
            let clone = {};<br>
            for (let key in user) {<br>
            &nbsp;&nbsp;clone[key] = user[key];<br>
            }
        </code>
        <p>Также мы можем использовать для этого метод Object.assign.</p>
        <p>Синтаксис:</p>
        <code>Object.assign(dest, [src1, src2, src3...])</code>
        <ul>
            <li>Первый аргумент <code>dest</code> - целевой объект;</li>
            <li>Остальные аргументы <code>src1, ..., srcN</code> (Может быть столько, сколько необходимо) являются
            исходными объектами;</li>
            <li>Метод копирует свойства всех исходных объектов <code>src1, ..., srcN</code> в целевой объект <code>dest</code>.
            Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.</li>
            <li>Возвращает объект <code>dest</code>.</li>
        </ul>
        <p>Например, мы можем использовать его для объединения нескольких объектов в один:</p>
        <code>
            let user = { name: 'John' };<br>
            <br>
            let permission1 = { canView: true };<br>
            let permission2 = { canEdit: true };<br>
            <br>
            Object.assign(user, permission1, permission2);
        </code>
        <p>Если скопированное имя свойства уже существует, оно будет перезаписано.</p>
        <p>Мы также можем использовать <code>Object.assign</code> для замены цикла <code>for...in</code> для простого клонирования:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;name: 'John',<br>
            &nbsp;&nbsp;age: 30<br>
            }<br>
            <br>
            let clone = Object.assign({}, user);
        </code>
        <p>Он копирует все свойства <code>user</code> в пустой объект и возвращает его.</p>
    </article>

    <article>
        <h2>Вложенное клонирование</h2>
        <p>До сих пор мы предполагали, что все свойства примитивные. Но свойства могут быть и ссылками на другие объекты.
        Что делать с ними?</p>
        <p>Например, у нас есть объект:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;name: 'John',
            &nbsp;&nbsp;sizes: {<br>
            &nbsp;&nbsp;&nbsp;height: 182,<br>
            &nbsp;&nbsp;&nbsp;width: 50<br>
            &nbsp;&nbsp;}
            };
        </code>
        <p>Теперь недостаточно просто скопировать <code>clone.sizes = user.sizes</code>, потому что <code>user.sizes</code> -
        это объект, он будет скопирован по ссылке. Таким образом, <code>clone</code> и <code>user</code> будут иметь
        общий объект <code>sizes</code>:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;name: 'John',
            &nbsp;&nbsp;sizes: {<br>
            &nbsp;&nbsp;&nbsp;height: 182,<br>
            &nbsp;&nbsp;&nbsp;width: 50<br>
            &nbsp;&nbsp;}
            };<br>
            <br>
            let clone = Object.assign({}, user);<br>
            <br>
            alert(user.sizes == clone.sizes); // true, тот же объект<br>
            <br>
            user.sizes.width++; // изменяем свойства в первом объекте<br>
            alert(clone.sizes.width); // 51, видим результат в другом
        </code>
        <p>Чтобы исправить это, мы должны использовать цикл клонирования, который проверяет каждое значение <code>user[key]</code>
        и, если это объект, тогда также копирует его структуру. Это называется «глубоким клонированием».</p>
        <p>Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед заново,
        возьмите готовую реализацию, например _.cloneDeep(obj) из библиотеки JavaScript lodash.</p>
        <p>Также мы можем использовать глобальный метод structuredClone(), который позволяет сделать полную копию объекта.</p>

        <article class="note">
            <h2>Объекты, объявленные как константа, могут быть изменены</h2>
            <p>Важным побочным эффектом хранения объектов в качестве ссылок является то, что объект, объявленный как
            <code>const</code>, <i>может</i> быть изменен.</p>
            <p>Значение переменной объекта это константа, оно всегда должно ссылаться на один и тот же объект, но свойства
            этого объекта могут свободно изменяться.</p>
        </article>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта», а
        «ссылку» (адрес в памяти) на это значение. Таким образом, копирование такой переменной или передача ее в качестве
        аргумента функции, копирует эту ссылку, а не сам объект.</p>
        <p>Все операции с использованием скопированных ссылок (например, добавление/удаление свойств) выполняются с одним и
        тем же объектом.</p>
        <p>Чтобы создать «реальную копию» (клон), мы можем использовать <code>Object.assign</code> для так называемой
        «поверхностной копии» (вложенные объекты копируются по ссылке) или функцию «глубокого копирования»,
        такую как <code>structuredClone()</code>.</p>
    </article>
</body>
</html>