<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Методы объекта, «this»</title>
    <link href="../../../style.css" type="text/css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Методы объекта, «this»</h2>
        <p>Объекты обычно создаются, чтобы представить сущности реального мира, будь то пользователи, заказы и так далее.</p>
        <p>И так же, как в реальном мире, пользователь может <i>совершать действия</i>: выбирать что-то из корзины покупок,
        авторизовываться, выходить из системы, оплачивать и т.п.</p>
        <p>Такие действия в JavaScript представлены функциями в свойствах.</p>
    </article>

    <article>
        <h2>Примеры методов</h2>
        <p>Для начала давайте научим нашего пользователя <code>user</code> здороваться:</p>
        <code>
            let user = {<br>
            &nbsp;&nbsp;name: 'John',<br>
            &nbsp;&nbsp;age: 30<br>
            };<br>
            <br>
            user.sayHi = function() {<br>
            &nbsp;&nbsp;alert('Привет!');<br>
            };<br>
            <br>
            user.sayHi(); // 'Привет!'
        </code>
        <p>Здесь мы просто использовали Function Expression (функциональное выражение), чтобы создать функцию приветствия,
        и присвоили ее свойству <code>sayHi</code> нашего объекта.</p>
        <p>Затем мы можем вызвать ее как <code>user.sayHi()</code>.</p>
        <p>Функцию, которая является свойство объекта, называют <i>методом</i> этого объекта.</p>
    </article>

    <article>
        <h2>Сокращенная запись метода</h2>
        <p>Существует более короткий синтаксис для методов в литерале объекта:</p>
        <code>
            // Эти объекты делают одно и тоже<br>
            let user = {<br>
            &nbsp;&nbsp;sayHi: function() {<br>
            &nbsp;&nbsp;&nbsp;alert('Привет!');<br>
            &nbsp;&nbsp;}<br>
            };<br>
            <br>
            let user = {<br>
            &nbsp;&nbsp;sayHi() {<br>
            &nbsp;&nbsp;&nbsp;alert('Привет!');<br>
            &nbsp;&nbsp;}<br>
            };
        </code>
    </article>

    <article>
        <h2>Ключевое слово «this» в методах</h2>
        <p>Как правило, методу объекта требуется доступ к информации, хранящейся в объекте, для выполнения своей работы.</p>
        <p><b>Для доступа к информации внутри объекта метод может использовать ключевое слово <code>this</code>.</b></p>
        <p>Значение <code>this</code> - это объект «перед точкой», который используется для вызова метода.</p>
    </article>

    <article>
        <h2>«this» не является фиксированным</h2>
        <p>В JavaScript ключевое слово «this» ведет себя иначе, чем в большинстве других языков программирования. Его можно
        использовать в любой функции, даже если это не метод объекта.</p>
        <p>Значение <code>this</code> вычисляется во время выполнения кода, в зависимости от контекста.</p>
        <p>Правило простое: если вызывается <code>obj.f()</code>, то во время вызова <code>f</code>, <code>this</code> -
        это <code>obj</code>.</p>

        <article class="note">
            <h2>Вызов без объекта: <code>this == undefined</code></h2>
            <p>Мы даже можем вызвать функцию вообще без объекта.</p>
            <p>В строгом режиме (<code>'use strict'</code>) в таком коде значением <code>this</code> будет являться
            <code>undefined</code>.</p>
            <p>В нестрогом режиме значением <code>this</code> в таком случае будет <i>глобальный объект</i>
            (<code>window</code> в браузере). Это - исторически сложившееся поведение <code>this</code>, которое
            исправляется использованием строгого режима.</p>
            <p>Обычно подобный вызов является ошибкой программирования. Если внутри функции используется <code>this</code>,
            тогда она ожидает, что будет вызвана в контексте какого-либо объекта.</p>
        </article>

        <article class="note">
            <h2>Последствия свободного <code>this</code></h2>
            <p>В JavaScript <code>this</code> является «свободным», его значение вычисляется в момент вызова метода и не
            зависит от того, где этот метод был объявлен, а скорее от того, какой объект вызывает этот метод (какой объект
            стоит «перед точкой»).</p>
            <p>Эта концепция вычисления <code>this</code> в момент исполнения имеет как свои плюсы, так и минусы.
            С одной стороны, функция может быть повторно использована в качестве метода у различных объектов (что повышает
            гибкость). С другой стороны, большая гибкость увеличивает вероятность ошибок.</p>
        </article>
    </article>

    <article>
        <h2>У стрелочных функций нет «this»</h2>
        <p>Стрелочные функции особенные: у них нет своего «собственного» <code>this</code>. Если мы ссылаемся на <code>this</code>
        внутри такой функции, то оно берется из внешней «нормальной» функции.</p>
        <p>Это особенность стрелочных функций. Она полезна, когда мы на самом деле не хотим иметь отдельное <code>this</code>,
        а скорее хотим взять его из внешнего контекста.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <ul>
            <li>Функции, которые находятся в свойствах объекта, называются «методами».</li>
            <li>Методы позволяют объектам «действовать»: <code>object.doSomething()</code>.</li>
            <li>Методы могут ссылаться на объект через <code>this</code>.</li>
        </ul>
        <p>Значение <code>this</code> определяется во время исполнения кода.</p>
        <ul>
            <li>При объявлении любой функции в ней можно использовать <code>this</code>, но этот <code>this</code> не имеет
            значения до тех пор, пока функция не будет вызвана.</li>
            <li>Функция может быть скопирована между объектами (из одного объекта в другой).</li>
            <li>Когда функция вызывается синтаксисом «метода» - <code>object.method()</code>, значением <code>this</code>
            во время вызова является <code>object</code>.</li>
        </ul>
        <p>Также еще раз заметим, что стрелочные функции являются особенными - у них нет <code>this</code>. Когда внутри
        стрелочной функции обращаются к <code>this</code>, то его значение берется извне.</p>
    </article>

    <script src="script.js"></script>
</body>
</html>