<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Микрозадачи</title>
    <link href="../../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Микрозадачи</h2>
        <p>Обработчики промисов <code>.then</code>/<code>.catch</code>/<code>.finally</code> всегда асинхронны.</p>
        <p>Даже когда промис сразу же выполнен, код в строках ниже <code>.then</code>/<code>.catch</code>/<code>.finally</code>
        будет запущен до этих обработчиков.</p>
        <p>Вот демо:</p>
        <code>
            let promise = new Promise.resolve();<br>
            <br>
            promise.then(() => alert('Промис выполнен'));<br>
            <br>
            alert('Код выполнен'); // Этот alert показывается первым
        </code>
        <p>Если вы запустите его, сначала вы увидите <code>код выполнен</code>, а потом <code>промис выполнен</code>.</p>
        <p>Это странно, потому что промис определенно был выполнен с самого начала.</p>
        <p>Почему <code>.then</code> срабатывает позже? Что происходит?</p>
    </article>

    <article>
        <h2>Очередь микрозадач</h2>
        <p>Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь
        <code>PromiseJobs</code>, более известную как «очередь микрозадач (microtask queue)» (термин V8).</p>
        <p>Как сказано в спецификации:</p>
        <ul>
            <li>
                <p>Очередь выполняется как первым-пришел-первым-ушел (FIFO): задачи, попавшие в очередь первыми,
                выполняются тоже первыми.</p>
            </li>
            <li>
                <p>Выполнение задачи происходит только в том случае, если ничего больше не запущено.</p>
            </li>
        </ul>
        <p>Или, проще говоря, когда промис выполнен, его обработчики <code>.then</code>/<code>.catch</code>/<code>.finally</code>
        попадают в очередь. Они пока не выполняются. Движок JavaScript берет задачу из очереди и выполняет ее, когда он
        освободится от выполнения текущего кода.</p>
        <p>Вот почему сообщение «код выполнен» в примере выше будет показано первым.</p>
        <p>Обработчики промисов всегда проходят через эту внутреннюю очередь.</p>
        <p>Если есть цепочка с несколькими <code>.then</code>/<code>.catch</code>/<code>.finally</code>, то каждый из
        них выполняет асинхронно. То есть сначала ставится в очередь, а потом выполняется, когда выполнение текущего кода
        завершено и добавленные ранее в очередь обработчики выполнены.</p>
        <p><b>Но что если порядок имеет значение для нас? Как мы можем вывести <code>код выполнен</code> после
        <code>промис выполнен</code>?</b></p>
        <p>Легко, используя <code>.then</code>:</p>
        <code>
            Promise.resolve()<br>
            &nbsp;&nbsp;.then(() => alert('Промис выполнен'))<br>
            &nbsp;&nbsp;.then(() => alert('Код выполнен'));
        </code>
        <p>Теперь порядок стал таким, как было задумано.</p>
    </article>

    <article>
        <h2>Необработанные ошибки</h2>
        <p><b>«Необработанная ошибка» возникает в случае, если ошибка промиса не обрабатывается в конце очереди микрозадач.</b></p>
        <p>Обычно, если мы ожидаем ошибку, мы добавляем <code>.catch</code> в конец цепочки промисов, чтобы обработать ее:</p>
        <code>
            let promise = new Promise.reject(new Error('Ошибка в промисе!'));<br>
            promise.catch(err => alert('Поймана!'));<br>
            <br>
            //Не запустится, ошибка обработана<br>
            window.addEventListener('unhandledrejection', event => {<br>
            &nbsp;&nbsp;alert(event.reason);<br>
            });
        </code>
        <p>... Но если мы забудем добавить <code>.catch</code>, то, когда очередь микрозадач опустеет, движок сгенерирует
        событие:</p>
        <code>
            let promise = new Promise.reject(new Error('Ошибка в промисе!'));<br>
            <br>
            // Ошибка в промисе!<br>
            window.addEventListener('unhandledrejection', event => alert(event.reason));
        </code>
        <p>А что, если мы поймаем ошибку, но позже? Вот так:</p>
        <code>
            let promise = new Promise.reject(new Error('Ошибка в промисе!'));<br>
            <br>
            setTimeout(() => promise.catch(err => alert('Поймана!')), 1000);<br>
            <br>
            // Ошибка в промисе!<br>
            window.addEventListener('unhandledrejection', event => alert(event.reason));
        </code>
        <p>Теперь при запуске мы сначала увидим «Ошибка в промисе!», а затем «Поймана!».</p>
        <p>Если бы мы не знали про очередь микрозадач, то могли бы удивиться: «Почему сработал обработчик
        <code>unhandledrejection</code>? Мы же поймали ошибку!»</p>
        <p>Но теперь мы понимаем, что событие <code>unhandledrejection</code> возникает, когда очередь микрозадач
        завершена: движок проверяет все промисы и, если какой-либо из них в состоянии «rejected», то генерируется это
        событие.</p>
        <p>В примере выше <code>.catch</code>, добавленный в <code>setTimeout</code>, также срабатывает, но позже,
        уже после возникновения <code>unhandledrejection</code>, так что это ни на что не влияет.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Обработка промисов всегда асинхронная, т.к. все действия промисов проходят через внутреннюю очередь
        «promise jobs», так называемую «очередь микрозадач (microtask queue)» (термин V8).</p>
        <p>Таким образом, обработчики <code>.then</code>/<code>.catch</code>/<code>.finally</code> вызываются после
        выполнения текущего кода.</p>
        <p>Если нам нужно гарантировать выполнение какого-то кода после <code>.then</code>/<code>.catch</code>/
        <code>.finally</code>, то лучше всего добавить его вызов в цепочку <code>.then</code>.</p>
        <p>В большинстве движков <code>JavaScript</code>, включая браузеры и Node.js, микрозадачи тесно связаны с
        так называемым «событийным циклом» и «микрозадачами».</p>
    </article>
</body>
</html>