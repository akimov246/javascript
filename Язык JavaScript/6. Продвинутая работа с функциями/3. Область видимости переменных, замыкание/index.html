<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Область видимости переменных, замыкание</title>
    <link href="../../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Область видимости переменных, замыкание</h2>
        <p>JavaScript - язык с сильным функционально-ориентированным уклоном. Он дает нам много свободы. Функция может быть
        динамически создана, скопирована в другую переменную или передана как аргумент другой функции и позже вызвана
        из совершенно другого места.</p>
        <p>Мы знаем, что функция может получить доступ к переменным из внешнего окружения, эта возможность используется
        очень часто.</p>
        <p>Но что произойдет, когда внешние переменные изменятся? Функция получит последнее значение или то, которое существовало
        на момент создания функции?</p>
        <p>И что произойдет, когда функция переместится в другое место в коде и будет вызвана от туда - получит ли она
        доступ к внешним переменным своего нового местоположения?</p>
    </article>

    <article>
        <h2>Блоки кода</h2>
        <p>Если переменная объявлена внутри блока кода <code>{ ... }</code>, то она видна только внутри этого блока.</p>
        <p>С помощью блоков <code>{ ... }</code> мы можем изолировать часть кода, выполняющую свою собственную задачу,
        с переменными, принадлежащими только ей.</p>
        <p>Для <code>if</code>, <code>for</code>, <code>while</code> и т.д. переменные, объявленные в блоке кода <code>{ ... }</code>,
        также видны только внутри. И это замечательно, поскольку это позволяет нам создавать блочно-локальные переменные,
        относящиеся только к ветви <code>if</code>. То же самое можно сказать и про циклы <code>for</code> и <code>while</code>.</p>
    </article>

    <article>
        <h2>Вложенные функции</h2>
        <p>Функция называется «вложенной», когда она создается внутри другой функции.</p>
        <p>Вложенная функция может быть возвращена: либо в качестве свойства нового объекта (если внешняя функция создает
        объект с методами), либо сама по себе. И затем может быть использована в любом месте. Не важно где, она все так же
        будет иметь доступ к тем же внешним переменным.</p>
        <p>Ниже, <code>makeCounter</code> создает функцию «счетчик», которая при каждом вызове возвращает следующее число:</p>
        <code>
            function makeCounter() {<br>
            &nbsp;&nbsp;let count = 0;
            <br>
            <br>
            &nbsp;&nbsp;return function() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return count++;<br>
            &nbsp;&nbsp;};<br>
            }<br>
            <br>
            let counter = makeCounter();<br>
            <br>
            alert(counter()); // 0
            alert(counter()); // 1
            alert(counter()); // 2
        </code>
        <p>Как это работает? Для большей наглядности объяснение разбито на несколько шагов.</p>
        <h3>Шаг 1. Переменные</h3>
        <p>В JavaScript у каждой выполняемой функции, блока кода <code>{ ... }</code> и скрипта есть связанный с ними
        внутренний (скрытый) объект, называемый <i>лексическим окружениям</i> <code>LexicalEnvironment</code>.</p>
        <p>Объект лексического окружения состоит из двух частей:</p>
        <ol>
            <li><i>Environment Record</i> - объект, в котором как свойства хранятся все локальные переменные (а также
            некоторая другая информация, такая как значение <code>this</code>).</li>
            <li>Ссылка на <i>внешнее лексическое окружение</i> - то есть то, которое соответствует коду снаружи
            (снаружи от текущих фигурных скобок).</li>
        </ol>
        <p><b>«Переменная» - это просто свойство специального внутреннего объекта: <code>Environment Record</code>.</b></p>
        <p><b>«Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».</b></p>
        <ol>
            <li>
                <p>При запуске скрипта лексическое окружение предварительно заполняется всеми объявленными переменными.</p>
                <p>Изначально они находятся в состоянии «Uninitialized». Это особое внутренне состояние, которое означает,
                что движок знает о переменной, но на нее нельзя ссылаться, пока она не будет объявлена с помощью
                <code>let</code>. Это почти то же самое, как если бы переменная не существовала.</p>
            </li>
            <li>Появляется определение переменной <code>let phrase</code>. У нее еще нет присвоенного значения, поэтому
            присваивается <code>undefined</code>. С этого момента мы можем использовать переменную.</li>
            <li>Переменной <code>phrase</code> присваивается значение.</li>
            <li>Переменная <code>phrase</code> меняет значение.</li>
        </ol>

        <article class="note">
            <h2>Лексическое окружение - объект спецификации</h2>
            <p>«Лексическое окружение» - это объект спецификации: он существует только «теоретически» в спецификации языка
            для описания того, как все работает. Мы не можем получить этот объект в нашем коде и манипулировать им напрямую.</p>
            <p>JavaScript-движки также могут оптимизировать его, отбрасывать неиспользуемые переменные для экономии памяти
            и выполнять другие внутренние действия, но при этом видимое поведение остается таким, как описано.</p>
        </article>

        <h3>Шаг 2. Function Declaration</h3>
        <p>Функция - это тоже значение, как и переменная.</p>
        <p><b>Разница заключается в том, что Function Declaration мгновенно инициализируется полностью.</b></p>
        <p>Когда создается лексическое окружение, Function Declaration сразу же становится функцией, готовой к использованию
        (в отличие от <code>let</code>, который до момента объявления не может быть использован).</p>
        <p>Именно поэтому мы можем вызвать функцию, объявленную как Function Declaration, до самого ее объявления.</p>
        <p>Конечно, такое поведение касается только Function Declaration, а не Function Expression, в которых мы
        присваиваем функцию переменной.</p>

        <h3>Шаг 3. Внутреннее и внешнее лексическое окружение</h3>
        <p>Когда запускается функция, в начале ее вызова автоматически создается новое лексическое окружение
        для хранения локальных переменных и параметров вызова.</p>
        <p>В процессе вызова функции у нас есть два лексических окружения: внутреннее (для вызываемой функции)
        и внешнее (глобальное):</p>
        <code>
            let phrase = 'Hello';<br>
            <br>
            function say(name) {<br>
            &nbsp;&nbsp;alert(`${phase}, ${name}`);<br>
            }<br>
            <br>
            say('John'); // Hello, John
        </code>
        <ul>
            <li>
                <p>Внутреннее лексическое окружение соответствует текущему выполнению <code>say</code>.</p>
                <p>В нем находится одна переменная <code>name</code>, параметр функции. Мы вызываем <code>say('John')</code>,
                так что значение переменной <code>name</code> равно <code>'John'</code>.</p>
            </li>
            <li>
                <p>Внешнее лексическое окружение - это глобальное лексическое окружение.</p>
                <p>В нем находятся переменная <code>phrase</code> и сама функция.</p>
            </li>
        </ul>
        <p>У внутреннего лексического окружения есть ссылка на внешнее <code>outer</code>.</p>
        <p><b>Когда код хочет получить доступ к переменной - сначала происходит поиск во внутреннем лексическом окружении,
        затем во внешнем, затем в следующем и так далее, до глобального.</b></p>
        <p>Если переменная не была найдена, это будет ошибкой в строгом режиме (<code>'use strict'</code>). Без строго
        режима, для обратной совместимости, присваивание несуществующей переменной создает новую глобальную переменную
        с таким же именем.</p>
        <p>Давайте посмотрим, как происходит поиск в нашем примере:</p>
        <ul>
            <li>Для переменной <code>name</code>, <code>alert</code> внутри <code>say</code> сразу же находит ее во внутреннем
            лексическом окружении.</li>
            <li>Когда <code>alert</code> хочет получить доступ к <code>phrase</code>, он не находит ее локально,
            поэтому вынужден обратиться к внешнему лексическому окружению и находит <code>phrase</code> там.</li>
        </ul>

        <h3>Шаг 4. Возврат функции</h3>
        <p>Давайте вернемся к примеру с <code>makeCounter</code>:</p>
        <code>
            function makeCounter() {<br>
            &nbsp;&nbsp;let count = 0;
            <br>
            <br>
            &nbsp;&nbsp;return function() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return count++;<br>
            &nbsp;&nbsp;};<br>
            }<br>
            <br>
            let counter = makeCounter();
        </code>
        <p>В начале каждого вызова <code>makeCounter()</code> создается новый объект лексического окружения, в котором
        хранятся переменные для конкретного запуска <code>makeCounter</code>.</p>
        <p>Таким образом, мы имеем два вложенных лексических окружения.</p>
        <p>Во время выполнения <code>makeCounter()</code> создается крошечная вложенная функция, состоящая всего из одной
        строки: <code>return count++</code>. Мы ее еще не запускаем, а только создаем.</p>
        <p>Все функции помнят лексическое окружение, в котором они были созданы. Технически здесь нет никакой магии:
        все функции имеют скрытое свойство <code>[[Environment]]</code>, которое хранит ссылку на лексическое окружение,
        в котором была создана функция.</p>
        <p>Таким образом <code>counter.[[Environment]]</code> имеет ссылку на <code>{count: 0}</code> лексического окружения.
        Так функция запоминает, где она была создана, независимо от того, где она вызывается. Ссылка на
        <code>[[Environment]]</code> устанавливается один раз и навсегда при создании функции.</p>
        <p>В последствии, при вызове <code>counter()</code>, для этого вызова создается новое лексическое окружение,
        а его внешняя ссылка на лексическое окружение берется из <code>counter.[[Environment]]</code>.</p>
        <p>Теперь, когда код внутри <code>counter()</code> ищет переменную <code>count</code>, он сначала ищет ее в
        собственном лексическом окружении (пустом, так как там нет локальных переменных), а затем в лексическом
        окружении внешнего вызова <code>makeCounter()</code>, где находит <code>count</code> и изменяет ее.</p>
        <p><b>Переменная обновляется в том лексическом окружении, в котором она существует.</b></p>

        <article class="note">
            <h2>Замыкания</h2>
            <p>В программировании есть общий термин: «замыкание» - который должен знать каждый разработчик.</p>
            <p>Замыкание - это функция, которая запоминает свои внешние переменные и может получить к ним доступ.</p>
        </article>
    </article>

    <article>
        <h2>Сборка мусорка</h2>
        <p>Обычно лексическое окружение удаляется из памяти вместе со всеми переменными после завершения вызова функции.
        Это связано с тем, что на него нет ссылок. Как и любой объект JavaScript, оно хранится в памяти только до тех пор,
        пока к нему можно обратиться.</p>
    </article>
</body>
</html>

<script src="script.js"></script>