<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Планирование: setTimeout и setInterval</title>
    <link href="../../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Планирование: setTimeout и setInterval</h2>
        <p>Мы можем вызвать функцию не в данный момент времени, а позже, через заданный интервал времени. Это называется
        «планирование вызова».</p>
        <p>Для этого существуют два метода:</p>
        <ul>
            <li><code>setTimeout</code> позволяет вызвать функцию <b>один раз</b> через определенный интервал времени.</li>
            <li><code>setInterval</code> позволяет вызывать функцию <b>регулярно</b>, повторяя вызов через определенный
            интервал времени.</li>
        </ul>
        <p>Эти методы не являются частью спецификации JavaScript. Но большинство сред выполнения JS-кода имеют внутренний
        планировщик и предоставляют доступ к этим методам. В частности, они поддерживаются во всех браузерах и Node.js.</p>
    </article>

    <article>
        <h2>setTimeout</h2>
        <p>Синтаксис:</p>
        <code>let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);</code>
        <p>Параметры:</p>
        <p><code>func|code</code></p>
        <p>Функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода,
        но это не рекомендуется.</p>
        <p><code>delay</code></p>
        <p>Задержка перед запуском в миллисекундах (1000мс = 1с). Значение по умолчанию - 0.</p>
        <p><code>arg1</code>, <code>arg2</code>...</p>
        <p>Аргументы, передаваемые в функцию.</p>
        <p>Например, данный код вызовет <code>sayHi()</code> спустя одну секунду:</p>
        <code>
            function sayHi() {<br>
            &nbsp;&nbsp;alert('Привет!');<br>
            }<br>
            <br>
            setTimeout(sayHi, 1000);
        </code>
        <p>С аргументами:</p>
        <code>
            function sayHi(phrase, who) {<br>
            &nbsp;&nbsp;alert(phrase + ', ' + who);<br>
            }<br>
            <br>
            setTimeout(sayHi, 1000, 'Привет', 'Джон'); // Привет, Джон
        </code>
        <p>Если первый аргумент является строкой, то JavaScript создаст из нее функцию.</p>
        <p>Это также будет работать:</p>
        <code>setTimeout('alert("Привет!")', 1000);</code>
        <p>Но использование строк не рекомендуется. Вместо этого используйте функции. Например, так:</p>
        <code>setTimeout(() => alert('Привет!'), 1000);</code>

        <article class="note">
            <h2>Передавайте функцию, но не запускайте ее</h2>
            <p>Начинающие разработчики иногда ошибаются, добавляя скобки <code>()</code> после функции:</p>
            <code>setTimeout(sayHi(), 1000);</code>
            <p>Это не работает, потому что <code>setTimeout</code> ожидает ссылку на функцию. Здесь <code>SayHi()</code>
            запускает выполнение функции, а результаты выполнения отправляются в <code>setTimeout</code>. В нашем случае
            результатом выполнения <code>sayHi()</code> является <code>undefined</code> (так как функция ничего не
            возвращает), поэтому ничего не планируется.</p>
        </article>
    </article>

    <article>
        <h2>Отмена через clearTimeout</h2>
        <p>Вызов <code>setTimeout</code> возвращает «идентификатор таймера» <code>timerId</code>, который можно использовать
        для отмены дальнейшего выполнения.</p>
        <p>Синтаксис для отмены:</p>
        <code>
            let timerId = setTimeout(...);<br>
            clearTimeout(timerId);
        </code>
        <p>В браузере идентификатором таймера является число. В других средах это может быть что-то еще. Например,
        Node.js возвращает объект таймера с дополнительными методами.</p>
        <p>Единой спецификации на эти методы нет, поэтому такое поведение является нормальным.</p>
    </article>

    <article>
        <h2>setInterval</h2>
        <p>Метод <code>setInterval</code> имеет такой же синтаксис как <code>setTimeout</code>:</p>
        <code>let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);</code>
        <p>Все аргументы имеют такое же значение. Но отличие этого метода от <code>setTimeout</code> в том, что функция
        запускается не один раз, а периодически через указанный интервал времени.</p>
        <p>Чтобы остановить дальнейшее выполнение функции, необходимо вызвать <code>clearInterval(timerId)</code>.</p>

        <article class="note">
            <h2>Во время показа <code>alert</code> время тоже идет</h2>
            <p>В большинстве браузеров внутренний счетчик продолжает тикать во время показа <code>alert/confirm/prompt</code>.</p>
        </article>
    </article>

    <article>
        <h2>Вложенный setTimeout</h2>
        <p>Есть два способа запускать что-то регулярно.</p>
        <p>Один из них <code>setInterval</code>. Другим является вложенный <code>setTimeout</code>. Например:</p>
        <code>
            let timerId = setTimeout(function tick() {<br>
            &nbsp;&nbsp;alert('tick');<br>
            &nbsp;&nbsp;timerId = setTimeout(tick, 2000); // (*)<br>
            }, 2000);
        </code>
        <p>Метод <code>setTimeout</code> выше планирует следующий вызов прямо после окончания текущего <code>(*)</code>.</p>
        <p>Вложенный <code>setTimeout</code> - более гибкий метод, чем <code>setInterval</code>. С его помощью
        последующий вызов может быть задан по-разному в зависимости от результатов предыдущего.</p>
        <p>А если функции, которые мы планируем, ресурсоемкие и требуют времени, то мы можем измерить время, затраченное
        на выполнение, и спланировать следующий вызов раньше или позже.</p>
        <p><b>Вложенный <code>setTimeout</code> позволяет задать задержку между выполнениями более точно, чем
        <code>setInterval</code></b>.</p>
        <p><b>Реальная задержка между вызовами функции с помощью <code>setInterval</code> меньше, чем указано.</b></p>
        <p>Это нормально, потому что время, затраченное на выполнение функции, использует часть заданного интервала времени.</p>
        <p>Вполне возможно, что выполнение функции будет дольше, чем мы ожидали, и займет времени больше указанного
        <code>delay</code>.</p>
        <p>В данном случае движок ждет окончания выполнения функции и затем проверяет планировщик, и если время истекло,
        немедленно запускает его снова.</p>
        <p>В крайнем случае, если функция всегда выполняется дольше, чем задержка <code>delay</code>, то вызовы будут
        выполняться без задержек вообще.</p>
        <p><b>Вложенный <code>setTimeout</code> гарантирует фиксированную задержку</b>.</p>
        <p>Это потому что новый вызов планируется в конце предыдущего.</p>

        <article class="note">
            <h2>Сборка мусора и колбэк setTimeout/setInterval</h2>
            <p>Когда функция передается в <code>setTimeout/setInterval</code>, на нее создается внутренняя ссылка и
            сохраняется в планировщике. Это предотвращает попадание функции в сборщик мусора, даже если на нее нет других
            ссылок.</p>
            <p>Для <code>setInterval</code> функция остается в памяти до тех пор, пока не будет вызван
            <code>clearInterval</code>.</p>
            <p>Есть и побочный эффект. Функция ссылается на внешнее лексическое окружение, поэтому пока она существует,
            внешние переменные существуют тоже. Они могут занимать больше памяти, чем сама функция. Поэтому, если
            регулярный вызов функции больше не нужен, то лучше отменить его, даже если функция очень маленькая.</p>
        </article>
    </article>

    <article>
        <h2>setTimeout с нулевой задержкой</h2>
        <p>Особый вариант использования: <code>setTimeout(func, 0)</code> или просто <code>setTimeout(func)</code>.</p>
        <p>Это планирует вызов <code>func</code> настолько быстро, насколько это возможно. Но планировщик будет
        вызывать функцию только после завершения выполнения текущего кода.</p>
        <p>Так вызов функции будет запланирован сразу после выполнения текущего кода.</p>
        <p>Например, этот код выводит «Привет» и затем сразу «Мир»:</p>
        <code>
            setTimeout(() => alert('Мир'));<br>
            <br>
            alert('Привет');
        </code>
        <p>Первая строка помещает вызов в «календарь» через 0 мс. Но планировщик проверит «календарь» только после
        того, как текущий код завершится. Поэтому <code>'Привет'</code> выводится первым, а <code>'Мир'</code> - после него.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <ul>
            <li>
                <p>Методы <code>setInterval(func, delay, ...args)</code> и <code>setTimeout(func, delay, ...args)</code>
                позволяют выполнять <code>func</code> регулярно или только один раз после задержки <code>delay</code>,
                заданной в мс.</p>
            </li>
            <li>
                <p>Для отмены выполнения необходимо вызвать <code>clearInterval/clearTimeout</code> со значением,
                которое возвращают методы <code>setInterval/setTimeout</code>.</p>
            </li>
            <li>
                <p>Вложенный вызов <code>setTimeout</code> является более гибкой альтернативой <code>setInterval</code>.
                Также он позволяет более точно задать интервал между выполнениями.</p>
            </li>
            <li>
                <p>Планирование с нулевой задержкой <code>setTimeout(func, 0)</code> используется для вызовов,
                которые должны быть исполнены как можно скорее, после завершения исполнения текущего кода.</p>
            </li>
            <li>
                <p>Браузер ограничивает 4-мя мс минимальную задержку между пятью и более вложенными вызовами
                <code>setTimeout</code>, а также для <code>setInterval</code>, начиная с 5-го вызова.</p>
            </li>
        </ul>
        <p>Обратите внимание, что все методы планирования не гарантируют точную задержку.</p>
        <p>Например, таймер в браузере может замедляться по многим причинам:</p>
        <ul>
            <li><p>Перегружен процессор.</p></li>
            <li><p>Вкладка браузера в фоновом режиме.</p></li>
            <li><p>Работа ноутбука от аккумулятора.</p></li>
        </ul>
        <p>Все это может увеличивать минимальный интервал срабатываний таймера (и минимальную задержку) до 300
        или даже 1000 мс в зависимости от браузера и настроек производительности ОС.</p>
    </article>
</body>
</html>

<script ></script>