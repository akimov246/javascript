<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Модули, введение</title>
    <link href="../../../style.css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Модули, введение</h2>
        <p>По мере роста нашего приложения, мы обычно хотим разделить его на много файлов, так называемых «модулей».
        Модуль обычно содержит класс или библиотеку с функциями.</p>
        <p>Долгое время в JavaScript отсутствовал синтаксис модулей на уровне языка. Это не было проблемой, потому что
        первые скрипты были маленькими и простыми. В модулях не было необходимости.</p>
        <p>Но со временем скрипты становились все более сложными, поэтому сообщество придумало несколько вариантов
        организации кода в модули. Появились библиотеки для динамической подгрузки модулей.</p>
        <p>Например:</p>
        <ul>
            <li>
                <p>AMD - одна из самых старых модульных систем, изначально реализована библиотекой require.js.</p>
            </li>
            <li>
                <p>CommonJS - модульная система, созданная для сервера Node.js.</p>
            </li>
            <li>
                <p>UMD - еще одна модульная система, предлагается как универсальная, совместима с AMD и CommonJS.</p>
            </li>
        </ul>
        <p>Теперь все они постепенно становятся частью истории, хоти их и можно найти в старых скриптах.</p>
        <p>Система модулей на уровне языка появилась в стандарте JavaScript в 2015 году и постепенно эволюционировала.
        На данный момент она поддерживается большинством браузеров и Node.js. Далее мы будем изучать именно ее.</p>
    </article>

    <article>
        <h2>Что такое модуль?</h2>
        <p>Модуль - это просто файл. Один скрипт - это один модуль.</p>
        <p>Модули могут загружать друг друга и использовать директивы <code>export</code> и <code>import</code>, чтобы
        обмениваться функциональностью, вызывать функции одного модуля из другого:</p>
        <ul>
            <li>
                <p><code>export</code> отмечает переменные и функции, которые должны быть доступны вне текущего модуля.</p>
            </li>
            <li>
                <p><code>import</code> позволяет импортировать функциональность из других модулей.</p>
            </li>
        </ul>
        <p>Например, если у нас есть файл <code>sayHi.js</code>, который экспортирует функцию:</p>
        <code>
            // sayHi.js<br>
            export function sayHi(user) {<br>
            &nbsp;&nbsp;alert(`Hello, ${user}`);<br>
            }
        </code>
        <p>... Тогда другой файл может импортировать ее и использовать:</p>
        <code>
            // main.js<br>
            import {sayHi} from './sayHi.js';<br>
            <br>
            alert(sayHi); // function...<br>
            sayHi('John'); // Hello, John!
        </code>
        <p>Директива <code>import</code> загружает модуль по пути <code>./sayHi.js</code> относительно текущего файла
        и записывает экспортированную функцию <code>sayHi</code> в соответствующую переменную.</p>
        <p>Давайте запустим пример в браузере.</p>
        <p>Так как модули поддерживают ряд специальных ключевых слов, и у них есть ряд особенностей, то необходимо явно
        сказать браузеру, что срипт является модулем, при помощи атрибута <code>&ltscript type="module"&gt</code>.</p>
        <p>Вот так:</p>
        <code>
            &lt!doctype html&gt<br>
            &ltscript type="module"&gt<br>
            &nbsp;&nbsp;impost {sayHi} from './sayHi.js';<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;document.body.innerHTML = sayHi('John');<br>
            &lt/script&gt
        </code>
        <p>Браузер автоматически загрузит и запустит импортированный модуль (и те, которые он импортирует, если надо),
        а затем запустит скрипт.</p>

        <article class="warning">
            <h2>Модули не работают локально. Только через HTTP(S)</h2>
            <p>Если вы попытаетесь открыть веб-страницу локально, через протокол <code>file://</code>, вы обнаружите,
            что директивы <code>import/export</code> не работают. Для тестирования модулей используйте локальный
            веб-сервер, например, «static-server» или используйте возможности «живого сервера» вашего редактора,
            например, расширение «Live Server» для VS Code.</p>
        </article>
    </article>

    <article>
        <h2>Основные возможности модулей</h2>
        <p>Чем отличаются модули от «обычных» скриптов?</p>
        <p>Есть основные возможности и особенности, работающие как в браузере, так и в серверном JavaScript.</p>

        <h3>Всегда «use strict»</h3>
        <p>В модулях всегда используется режим <code>use strict</code>. Например, присваивание к необъявленной переменной
        вызовет ошибку.</p>
        <code>
            &ltscript type="module"&gt<br>
            &nbsp;&nbsp;a = 5; // Ошибка<br>
            &lt/script&gt
        </code>
        <h3>Своя область видимости переменных</h3>
        <p>Каждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные
        в модуле, не видны в других скриптах.</p>
        <p>Модули должны экспортировать функциональность, предназначенную для использования извне. А другие модули
        могут ее импортировать.</p>
        <p>В браузере также существует независимая область видимости для каждого скрипта
        <code>&ltscript type="module"&gt</code>:</p>
        <code>
            &ltscript type="module"&gt<br>
            &nbsp;&nbsp;// Переменная доступна только в этом модуле<br>
            &nbsp;&nbsp;let user = 'John';<br>
            &lt/script&gt<br>
            <br>
            &ltscript type="module"&gt<br>
            &nbsp;&nbsp;alert(user); // Error: user is not defined<br>
            &lt/script&gt
        </code>
        <p>Если нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить ее объекту
        <code>window</code>, тогда получить значение переменной можно обратившись к <code>window.user</code>. Но это
        должно быть исключением, требующим веской причины.</p>

        <h3>Код в модуле выполняется только один раз при импорте</h3>
        <p>Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз,
        после чего экспортируемая функциональность передается всем импортерам.</p>
        <p>Это очень важно для понимания работы модулей. Давайте посмотрим примеры.</p>
        <p>Во-первых, если при запуске модуля возникают побочные эффекты, например выдается сообщение, то импорт модуля
        в нескольких местах покажет его только один раз - при первом импорте:</p>
        <code>
            // alert.js<br>
            alert('Модуль выполнен'!);
        </code>
        <code>
            // Импорт одного и того же модуля в разных файлах<br>
            <br>
            // 1.js<br>
            import './alert.js'; // Модуль выполнен!<br>
            <br>
            // 2.js<br>
            import 'alert.js'; // Ничего не покажет
        </code>
        <p>На практике, задача кода модуля - это обычно инициализация, создание внутренних структур данных, а если мы хотим,
        чтобы что-то можно было использовать много раз, то экспортируем это.</p>
        <p>Теперь более продвинутый пример.</p>
        <p>Давайте представим, что модуль экспортирует объект:</p>
        <code>
            // admin.js<br>
            export let admin = {<br>
            &nbsp;&nbsp;name: 'John'<br>
            };
        </code>
        <p>Если модуль импортируется в нескольких файлах, то код модуля будет выполнен только один раз, объект
        <code>admin</code> будет создан и в дальнейшем будет передан всем импортерам.</p>
        <p>Все импортеры получат один-единственный объект <code>admin</code>:</p>
        <code>
            // 1.js<br>
            import {admin} from './admin.js';<br>
            admin.name = 'Pete';<br>
            <br>
            // 2.js<br>
            import {admin} from './admin.js';<br>
            alert(admin.name); // Pete<br>
            <br>
            // Оба файла, 1.js и 2.js, импортируют один и тот же объект<br>
            // Изменения, сделанные в 1.js, будут видны в 2.js
        </code>
        <p>Еще раз заметим - модуль выполняется только один раз. Генерируется экспорт и после передается всем импортерам,
        поэтому, если что-то изменится в объекте <code>admin</code>, то другие модули тоже увидят эти изменения.</p>
        <p>Такое поведение позволяет <i>конфигурировать</i> модули при первом импорте. Мы можем установить его свойства
        один раз, и в дальнейших импортах он будет уже настроенным.</p>
        <p>Например, модуль <code>admin.js</code> предоставляет определенную функциональность, но ожидает передачи
        данных в объект <code>admin</code> извне:</p>
        <code>
            // admin.js<br>
            export let admin = {};<br>
            <br>
            export function sayHi() {<br>
            &nbsp;&nbsp;alert(`Ready to serve, ${admin.name}!`);<br>
            }
        </code>
        <p>В <code>init.js</code>, первом скрипте нашего приложения, мы установим <code>admin.name</code>. Тогда все
        это увидят, включая вызовы, сделанные из самого <code>admin.js</code>:</p>
        <code>
            // init.js<br>
            import {admin} from './admin.js';<br>
            admin.name = 'Pete';
        </code>
        <p>Другой модуль тоже увидит <code>admin.name</code>:</p>
        <code>
            // other.js<br>
            import {admin, sayHi} from './admin.js';<br>
            <br>
            alert(admin.name); // Pete<br>
            <br>
            sayHi(); // Ready to serve, Pete!
        </code>

        <h3>import.meta</h3>
        <p>Объект <code>import.meta</code> содержит информацию о текущем модуле.</p>
        <p>Содержимое зависит от окружения. В браузере он содержит ссылку на скрипт или ссылку на текущую веб-страницу,
        если модуль встроен в HTML:</p>
        <code>
            &ltscript type="module"&gt<br>
            &nbsp;&nbsp;alert(import.meta.url); // Ссылка на html страницу для встроенного скрипта<br>
            &lt/script&gt
        </code>

        <h3>В модуле «this» не определен</h3>
        <p>Это незначительная особенность, но для полноты картины нам нужно упомянуть об этом.</p>
        <p>В модуле на верхнем уровне <code>this</code> не определен (<code>undefined</code>).</p>
        <p>Сравним с не-модульными скриптами, там <code>this</code> - глобальный объект:</p>
        <code>
            &ltscript&gt<br>
            &nbsp;&nbsp;alert(this); // window<br>
            &lt/script&gt<br>
            <br>
            &ltscript type="module"&gt<br>
            &nbsp;&nbsp;alert(this); // undefined<br>
            &lt/script&gt
        </code>
    </article>

    <article>
        <h2>Особенности в браузерах</h2>
        <p>Есть и несколько других, именно браузерных особенностей скриптов с <code>type="module"</code> по сравнению
        с обычными скриптами.</p>

        <h3>Модули являются отложенными (deferred)</h3>
        <p>Модули <i>всегда</i> выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом
        <code>defer</code>. Это верно и для внешних и для встроенных скриптов-модулей.</p>
        <p>Другими словами:</p>
        <ul>
            <li>
                <p>Загрузка внешних модулей, таких как <code>&ltscript type="module" src="..."&gt</code>, не блокирует
                обработку HTML.</p>
            </li>
            <li>
                <p>Модули, даже если загрузились быстро, ожидают полной загрузки HTML документа, и только затем
                выполняются.</p>
            </li>
            <li>
                <p>Сохраняется относительный порядок скриптов: скрипты, которые идут раньше в документе, выполняются
                раньше.</p>
            </li>
        </ul>
        <p>Как побочный эффект, модули всегда видят полностью загруженную HTML-страницу, включая элементы под ними.</p>
        <p>Например:</p>
        <code>
            &ltscript type="module"<br>
            &nbsp;&nbsp;alert(typeof button); // object: скрипт может видеть кнопку под ним<br>
            &nbsp;&nbsp;// так как модули являются отложенными, то скрипт начнет выполняться только после полной загрузки страницы<br>
            &lt/script&gt<br>
            <br>
            // Сравните с обычным скриптом ниже:<br>
            <br>
            &ltscript&gt<br>
            &nbsp;&nbsp;alert(typeof button); // Ошибка: кнопка не определена, скрипт не видит элементы под ним<br>
            &nbsp;&nbsp;// обычные скрипты запускаются сразу, не дожидаясь полной загрузки страницы<br>
            &lt/script&gt<br>
            <br>
            &ltbutton id="button"&gtКнопка&lt/button&gt
        </code>
        <p>Пожалуйста, обратите внимание: второй скрипт выполнится раньше, чем первый! Поэтому мы увидим сначала
        <code>undefined</code>, а потом <code>object</code>.</p>
        <p>Это потому, что модули начинают выполняться после полной загрузки страницы. Обычные скрипты запускаются сразу же,
        поэтому сообщение из обычного скрипта мы видим первым.</p>
        <p>При использовании модулей нам стоит иметь в виду, что HTML-страница будет показана браузером до того,
        как выполнятся модули и JavaScript-приложение будет готово к работе. Некоторые функции могут еще не работать.
        Нам следует разместить «индикатор загрузки» или что-то еще, чтобы не смутить этим посетителя.</p>

        <h3>Атрибут async работает во встроенных скриптах</h3>
        <p>Для не-модульных скриптов атрибут <code>async</code> работает только на внешних скриптах. Скрипты с ним
        запускаются сразу по готовности, они не ждут другие скрипты или HTML-документ.</p>
        <p>Для модулей атрибут <code>async</code> работает на любых скриптах.</p>
        <p>Например, в скрипте ниже есть <code>async</code>, поэтому он выполнится сразу после загрузки, не ожидая других
        скриптов.</p>
        <p>Скрипт выполнит импорт (загрузит <code>./analytics.js</code>) и сразу запустится, когда будет готов, даже
        если HTML документ еще не будет загружен, или если другие скрипты еще загружаются.</p>
        <p>Это очень полезно, когда модуль ни с чем не связан, например для счетчиков, рекламы, обработчиков событий.</p>
        <code>
            &lt!-- загружаются зависимости (analytics.js) и скрипт запускается --&gt<br>
            &lt!-- модуль не ожидает загрузки документа или других тэгов &ltscript&gt --&gt<br>
            &ltscript async type="module"&gt<br>
            &nbsp;&nbsp;import {counter} from './analytics.js';<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;counter.count();<br>
            &lt/script&gt
        </code>

        <h3>Внешние скрипты</h3>
        <p>Внешние скрипты с атрибутом <code>type="module"</code> имеют два отличия:</p>
        <ol>
            <li>
                <p>Внешние скрипты с одинаковым атрибутом <code>src</code> запускаются только один раз.</p>
            </li>
            <li>
                <p>Внешний скрипт, который загружается с другого домена, требует указания заголовков <code>CORS</code>.
                Другими словами, если модульный скрипт загружается с другого домена, то удаленный сервер должен
                установить заголовок <code>Access-Control-Allow-Origin</code> означающий, что загрузка скрипта разрешена.</p>
                <code>&lt!-- another-site.com должен указать заголовок Access-Control-Allow-Origin --&gt<br>
                    &lt!-- иначе, скрипт не выполнится --&gt<br>
                    &ltscript type="module" src="http://www.another-site.com/their.js"&gt&lt/script&gt
                </code>
                <p>Это обеспечивает лучшую безопасность по умолчанию.</p>
            </li>
        </ol>

        <h3>Не допускаются «голые» модули</h3>
        <p>В браузере <code>import</code> должен содержать относительный или абсолютный путь к модулю. Модули без
        пути называются «голыми» (bare). Они не разрешены в <code>import</code>.</p>
        <p>Например, этот <code>import</code> неправильный:</p>
        <code>
            import {sayHi} from 'sayHi.js'; // Ошибка, «голый» модуль<br>
            // Путь должен быть, например, './sayHi.js' или абсолютный
        </code>
        <p>Другие окружения, например Node.js допускают использование «голых» модулей, без путей, так как в них
        есть свои правила, как работать с такими модулями и где их искать. Но браузеры пока не поддерживают «голые»
        модули.</p>

        <h3>Совместимость, «nomodule»</h3>
        <p>Старые браузеры не понимают атрибут <code>type="module"</code>. Скрипты с неизвестным атрибутом <code>type</code>
        просто игнорируются. Мы можем сделать для них «резервный» скрипт при помощи атрибута <code>nomodule</code>:</p>
        <code>
            &ltscript type="module"&gt<br>
            &nbsp;&nbsp;alert('Работает в современных браузерах');<br>
            &lt/script&gt<br>
            <br>
            &ltscript nomodule&gt<br>
            &nbsp;&nbsp;alert('Современные браузеры понимают оба атрибута - и type="module", и nomodule, поэтому пропускают этот тег script');<br>
            &nbsp;&nbsp;alert('Старые браузеры игнорируют скрипты с неизвестным атрибутом type="module", но выполняют этот.');<br>
            &lt/script&gt
        </code>
    </article>

    <article>
        <h2>Инструменты сборки</h2>
        <p>В реальной жизни модули в браузерах редко используются в «сыром» виде. Обычно, мы объединяем модули вместе,
        используя специальный инструмент, например <code>WebPack</code> и после выкладываем код на рабочий сервер.</p>
        <p>Одно из преимуществ использования сборщика - он предоставляет больший контроль над тем, как модули ищутся,
        позволяет использовать «голые» модули и много другое «свое», например CSS/HTML-модули.</p>
        <p>Сборщик делает следующее:</p>
        <ol>
            <li>
                <p>Берет «основной» модуль, который мы собираемся поместить в <code>&ltscript type="module"&gt</code>
                в HTML.</p>
            </li>
            <li>
                <p>Анализирует зависимости (импорты, импорты импортов и так далее).</p>
            </li>
            <li>
                <p>Собирает один файл со всеми модулями (или несколько файлов, это можно настроить), перезаписывает
                встроенный <code>import</code> функцией импорта от сборщика, чтобы все работало. «Специальные» типы
                модулей, такие как HTML/CSS тоже поддерживаются.</p>
            </li>
            <li>
                <p>В процессе могут происходить и другие трансформации и оптимизации кода:</p>
                <ul>
                    <li>
                        <p>Недостижимый код удаляется.</p>
                    </li>
                    <li>
                        <p>Неиспользуемые экспорты удаляются.</p>
                    </li>
                    <li>
                        <p>Специфические операторы для разработки, такие как <code>console</code> и <code>debugger</code>,
                        удаляются.</p>
                    </li>
                    <li>
                        <p>Современный синтаксис JavaScript также может быть трансформирован в предыдущий стандарт,
                        с похожей функциональностью.</p>
                    </li>
                    <li>
                        <p>Полученный файл можно минимизировать (удалить пробелы, заменить названия переменных на более
                        короткие и т.д.).</p>
                    </li>
                </ul>
            </li>
        </ol>
        <p>Если мы используем инструменты сборки, то они объединяют модули вместе в один или несколько файлов, и заменяют
        <code>import/export</code> на свои вызовы. Поэтому итоговую сборку можно подключать и без атрибута
        <code>type="module"</code>, как обычный скрипт.</p>
        <p>Хотя и «как есть» модули тоже можно использовать, а сборщик настроить позже при необходимости.</p>
    </article>

    <article>
        <h2>Итого</h2>
        <p>Подводя итог, основные понятия:</p>
        <ol>
            <li>
                <p>Модуль - это файл. Чтобы работал <code>import/export</code>, нужно для браузеров указывать атрибут
                <code>&ltscript type="module"&gt</code>. У модулей есть ряд особенностей:</p>
                <ul>
                    <li>
                        <p>Отложенное (deferred) выполнение по умолчанию.</p>
                    </li>
                    <li>
                        <p>Атрибут async работает во встроенных скриптах.</p>
                    </li>
                    <li>
                        <p>Для загрузки внешних модулей из другого источника, он должен ставить заголовки CORS.</p>
                    </li>
                    <li>
                        <p>Дублирующие внешние скрипты игнорируются.</p>
                    </li>
                </ul>
            </li>
            <li>
                <p>У модулей есть своя область видимости, обмениваться функциональностью можно через <code>import/export</code>.</p>
            </li>
            <li>
                <p>В модулях всегда включена директива <code>use strict</code>.</p>
            </li>
            <li>
                <p>Код в модулях выполняется только один раз. Экспортируемая функциональность создается один раз и
                передается всем импортерам.</p>
            </li>
        </ol>
        <p>Когда мы используем модули, каждый модуль реализует свою функциональность и экспортирует ее. Затем мы
        используем <code>import</code>, чтобы напрямую импортировать ее туда, куда необходимо. Браузер загружает
        и анализирует скрипты автоматически.</p>
        <p>В реальной жизни часто используется сборщик <code>Webpack</code>, чтобы объединить модули: для производительности
        и других «плюшек».</p>
    </article>
</body>
</html>