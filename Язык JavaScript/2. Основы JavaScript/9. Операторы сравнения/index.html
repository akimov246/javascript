<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Операторы сравнения</title>
    <link href="../../../style.css" type="text/css" rel="stylesheet">
</head>
<body>
    <article>
        <h2>Результат сравнения имеет логический тип</h2>
        <p>Все операторы сравнения возвращают значение логического типа (<code>true</code>, <code>false</code>).</p>
        <p>Результат сравнения можно присвоить переменной, как и любое значение.</p>
    </article>

    <article>
        <h2>Сравнение строк</h2>
        <p>Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.</p>
        <p>Другими словами, строки сравниваются посимвольно.</p>
        <p>Алгоритм сравнения двух строк:</p>
        <ol>
            <li>Сначала сравниваются первый символы строк;</li>
            <li>Если первый символ первой строки больше (меньше), чем первый символ второй строки, то первая строка больше
            (меньше) второй. Сравнение завершено;</li>
            <li>Если первый символы равны, то таким же образом сравниваются уже вторые символы строк;</li>
            <li>Сравнение продолжается, пока не закончится одна из строк.</li>
            <li>Если обе строки заканчиваются одновременно, то они равны. Иначе, больше считается более длинная строка.</li>
        </ol>

        <article class="note">
            <h2>Используется кодировка Unicode, а не настоящий алфавит</h2>
            <p>Приведенный выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между
            ними есть и различия.</p>
            <p>Например, в JavaScript имеет значение регистр символов. Заглавная буква <code>"A"</code> не равна строчной
            <code>"a"</code>. Какая же из них больше? Строчная <code>"a"</code>. Почему? Потому что строчные буквы имеют
            большие код во внутренней таблице кодирования, которую использует JavaScript (Unicode)</p>
        </article>
    </article>

    <article>
        <h2>Сравнение разных типов</h2>
        <p>При сравнении значений разных типов JavaScript приводит каждое из них к числу.</p>
        <article class="note">
            <h2>Забавное следствие</h2>
            <p>Возможна следующая ситуация:</p>
            <ul>
                <li>Два значения равны;</li>
                <li>Одно из них <code>true</code> как логическое значение, другое - <code>false</code>.</li>
            </ul>
            <p>Например:</p>
            <code>let a = 0;</code><br>
            <code>alert(Boolean(a));</code> // false<br>
            <code>let b = '0';</code><br>
            <code>alert(Boolean(b));</code> // true<br>
            <code>alert(a == b);</code> // true!
            <p>С точки зрения JavaScript, результат ожидаем. Равенство преобразует значения, используя числовое преобразование,
            поэтому <code>'0'</code> становится <code>0</code>. В то время как явное преобразование с помощью <code>Boolean</code>
            использует другой набор правил.</p>
        </article>
    </article>

    <article>
        <h2>Строгое сравнение</h2>
        <p>Использование обычного сравнения <code>==</code> может вызвать проблемы. Например, оно не отличает <code>0</code>
        от <code>false</code>.</p>
        <p>Это происходит из-за того, что операнды разных типов преобразуются оператором <code>==</code> к числу. В итоге,
        и пустая строка, и <code>false</code> становятся нулем.</p>
        <p>Как же тогда отличить <code>0</code> от <code>false</code>?</p>

        <h3>Оператор строго равенства <code>===</code> проверяет равенство без приведения типов</h3>
        <p>Другими словами, если <code>a</code> и <code>b</code> имеют разные типы, то проверка <code>a===b</code>
        немедленно возвращает <code>false</code> без попытки их преобразования.</p>
        <p>Еще есть оператор строгого неравенства <code>!==</code>, аналогичный <code>!==</code>.</p>
    </article>

    <article>
        <h2>Сравнение с null и undefined</h2>
        <p>Поведение <code>null</code> и <code>undefined</code> при сравнении с другими значениями - особое:</p>
        <h3>При строгом равенстве <code>===</code></h3>
        <p>Эти значения различны, так как различны их типы.</p>
        <code>alert(null === undefined);</code> // false
        <h3>При нестрогом неравенстве <code>==</code></h3>
        <p>Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.</p>
        <code>alert(null == undefined);</code> // true
        <h3>При использовании математических операторов и других операторов сравнения <code>< > <= >=</code></h3>
        <p>Значения <code>null/undefined</code> преобразуются к числам: <code>null</code> становится <code>0</code>, а
        <code>undefined</code> - <code>NaN</code>.</p>
    </article>

    <article>
        <h2>Странный результат сравнения null и 0</h2>
        <p>Сравним <code>null</code> с нулем:</p>
        <code>alert(null > 0);</code> // false<br>
        <code>alert(null == 0);</code> // false<br>
        <code>alert(null >= 0);</code> // true
        <p>С точки зрения математики это странно. Результат сравнения говорит о том, что «<code>null</code> больше или
        равно нулю», тогда результат одного из сравнений выше должен быть <code>true</code>, но они оба ложны.</p>
        <p>Причина в том, что нестрогое равенство и сравнения <code>> < >= <=</code> работают по-разному. Сравнения преобразуют
        <code>null</code> в число, рассматривая его как <code>0</code>. Поэтому выражение <code>null >= 0</code> истинно,
        а <code>null > 0</code> ложно.</p>
        <p>С другой стороны, для нестрогого равенства <code>==</code> значений <code>undefined</code> и <code>null</code>
        действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому.
        Поэтому <code>null == 0</code> ложно.</p>
    </article>

    <article>
        <h2>Несравненное значение undefined</h2>
        <p>Значение <code>undefined</code> несравнимо с другими значениями:</p>
        <code>alert(undefined > 0);</code> // false (1)<br>
        <code>alert(undefined < 0);</code> // false (2)<br>
        <code>alert(undefined == 0);</code> // false (3)
        <p>Почему сравнение <code>undefined</code> с нулем всегда ложно?</p>
        <p>На это есть следующие причины:</p>
        <ul>
            <li>Сравнения <code>(1)</code> и <code>(2)</code> возвращают <code>false</code>, потому что <code>undefined</code>
            преобразуется в <code>NaN</code>, а <code>NaN</code> - это специальное числовое значение, которое возвращает
            <code>false</code> при любых сравнениях;</li>
            <li>Нестрогое равенство <code>(3)</code> возвращает <code>false</code>, потому что <code>undefined</code>
            равно только <code>null</code>, <code>undefined</code> и ничему больше.</li>
        </ul>
    </article>

    <article>
        <h2>Как избежать проблем</h2>
        <p>Зачем мы рассмотрели все эти примеры? Должны ли мы постоянно помнить обо всех этих особенностях? Необязательно.
        Со временем все они станут вам знакомы, но можно избежать проблем, если следовать надежным правилам:</p>
        <ul>
            <li>Относитесь очень осторожно к любому сравнению с <code>undefined/null</code>, кроме случаев строго
            равенства <code>===</code>;</li>
            <li>Не используйте сравнения <code>> < >= <=</code> с переменными, которые могут принимать значения
            <code>null/undefined</code>, разве что вы полностью уверены в том, что делаете. Если переменная может принимать
            эти значения, то добавьте для них отдельные проверки.</li>
        </ul>
    </article>

    <article>
        <h2>Итого</h2>
        <ul>
            <li>Операторы сравнения возвращают значения логического типа;</li>
            <li>Строки сравниваются посимвольно и в лексикографическом порядке;</li>
            <li>Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов
            строго равенства/неравенства;</li>
            <li>Значения <code>null</code> и <code>undefined</code> равны <code>==</code> друг другу и не равны любому
            другому значению;</li>
            <li>Будьте осторожны при использовании операторов сравнений вроде <code>></code> и <code><</code> с переменными,
            которые могут принимать значения <code>null/undefined</code>. Хорошей идеей будет сделать отдельную проверку
            на <code>null/undefined</code>.</li>
        </ul>
    </article>
</body>
</html>