<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Селекторы</title>
    <link href="../../style.css" rel="stylesheet">
    <script defer src="../../highlightElements.js"></script>
    <style>
        #languages li {
            color: brown;
        }

        #languages > li {
            color: black;
        }

        #e-slavic {
            font-style: italic;
        }

        #e-slavic ~ li {
            color: red;
        }

        #latvian {
            font-style: italic;
        }

        #latvian * {
            font-style: normal;
        }

        #latvian + li {
            color: green;
        }

        .span_selector {
            border: 1px solid black;
        }

        #russian li:nth-child(2n) {
            background: #eee;
        }

        #russian li:nth-child(3) {
            color: red;
        }

        #definitions dt:nth-of-type(2n) {
            background: #eee;
        }

        #definitions dd:nth-last-of-type(2) {
            color: red;
        }

        div.example.pseudo-elements li::before {
            content: " [[ ";
        }

        div.example.pseudo-elements li::after {
            content: " ]] ";
        }
    </style>
</head>
<body>
    <article>
        <h2>Селекторы</h2>
        <p>CSS3-селекторы - фундаментально полезная вещь.</p>
        <p>Даже если вы почему-то не пользуетесь ими в CSS, есть много фреймворков для их кросс-браузерного использования
        CSS3 из JavaScript.</p>
        <p>Поэтому их необходимо знать.</p>
    </article>

    <article>
        <h2>Основные виды селекторов</h2>
        <p>Основных видов селекторов всего несколько:</p>
        <ul>
            <li>
                <p><code>*</code> - любые элементы.</p>
            </li>
            <li>
                <p><code>div</code> - элементы с таким тегом.</p>
            </li>
            <li>
                <p><code>#id</code> - элементы с данным <code>id</code>.</p>
            </li>
            <li>
                <p><code>.class</code> - элементы с таким классом.</p>
            </li>
            <li>
                <p><code>[name="value"]</code> - селекторы на атрибут.</p>
            </li>
            <li>
                <p><code>:visited</code> - «псевдоклассы», остальные разные условия на элемент.</p>
            </li>
        </ul>
        <p><b>Селекторы можно комбинировать, записывая последовательно, без пробела:</b></p>
        <ul>
            <li>
                <p><code>.c1.c2</code> - элементы одновременно с классами <code>c1</code> и <code>c2</code>.</p>
            </li>
            <li>
                <p><code>a#id.c1.c2:visited</code> - элемент <code>a</code> с данным <code>id</code>, классами
                <code>c1</code> и <code>c2</code>, и псевдоклассом <code>visited</code>.</p>
            </li>
        </ul>
    </article>

    <article>
        <h2>Отношения</h2>
        <p>В CSS3 предусмотрено четыре вида отношений между элементами.</p>
        <p>Самые известные вы наверняка знаете:</p>
        <ul>
            <li>
                <p><code>div p</code> - элементы <code>p</code>, являющиеся потомками <code>div</code>.</p>
            </li>
            <li>
                <p><code>div > p</code> - только непосредственные потомки.</p>
            </li>
        </ul>
        <p>Есть и два более редких:</p>
        <ul>
            <li>
                <p><code>div ~ p</code> - правые соседи: все <code>p</code> на том же уровне вложенности, которые идут
                после <code>div</code>.</p>
            </li>
            <li>
                <p><code>div + p</code> - первый правый сосед: <code>p</code> на том же уровне вложенности, который идет
                сразу после <code>div</code> (если есть).</p>
            </li>
        </ul>
        <p>Посмотрим их на примере HTML:</p>
<pre><code class="language-html">&lt;h3&gt;Балтославянские языки&lt;/h3&gt;

&lt;ol id="languages"&gt;
    ... Вложенный ol\li список языков...
&lt;/ol&gt;</code></pre>
        <p>CSS-селекторы:</p>
<pre><code class="language-css">#languages li {
    color: brown; /* Потомки #languages, подходящие под селектор li */
}

#languages > li {
    color: black; /* Первый уровень детей #languages подходящий под li */
}

#e-slavic {
    font-style: italic;
}

#e-slavic ~ li { /* Правые соседи #e-slavic с селектором li */
    color: red;
}

#latvian {
    font-style: italic;
}

#latvian * { /* Потомки #latvian, подходящие под * (т.е. любые) */
    font-style: normal;
}

#latvian + li { /* Первый правый сосед #latvian с селектором li */
    color: green;
}</code></pre>
        <p>Результат:</p>
        <div class="example">
            <h3 style="margin: 0">Балтославянские языки</h3>
            <ol id="languages">
                <li>
                    Славянские языки
                    <ol>
                        <li>Славянские микроязыки</li>
                        <li>Праславянский язык</li>
                        <li id="e-slavic">Восточнославянские языки <span class="span_selector">#e-slavic</span></li>
                        <li>Западнославянские языки <span class="span_selector">#e-slavic ~ li</span></li>
                        <li>Южнославянские языки <span class="span_selector">#e-slavic ~ li</span></li>
                        <li>... <span class="span_selector">#e-slavic ~ li</span></li>
                    </ol>
                </li>
                <li>
                    Балтийские языки
                    <ol>
                        <li>Литовский язык</li>
                        <li id="latvian">
                            Латышский язык <span class="span_selector">#latvian</span>
                            <ol>
                                <li>Латгальский язык <span class="span_selector">#latvian *</span></li>
                            </ol>
                        </li>
                        <li>Прусский язык <span class="span_selector">#latvian + li</span></li>
                        <li>... (следующий элемент уже не <span class="span_selector">#latvian + li</span>)</li>
                    </ol>
                </li>
            </ol>
        </div>
    </article>

    <article>
        <h2>Фильтр по месту среди соседей</h2>
        <p>При выборе элемента можно указать место среди соседей.</p>
        <p>Список псевдоклассов для этого:</p>
        <ul>
            <li>
                <p><code>:first-child</code> - первый потомок своего родителя.</p>
            </li>
            <li>
                <p><code>:last-child</code> - последний потомок своего родителя.</p>
            </li>
            <li>
                <p><code>:only-child</code> - единственный потомок своего родителя, соседних элементов нет.</p>
            </li>
            <li>
                <p><code>:nth-child(a)</code> - потомок номер <code>a</code> своего родителя, например,
                <code>:nth-child(2)</code> - второй потомок. Нумерация начинается с <code>1</code>.</p>
            </li>
            <li>
                <p><code>:nth-child(an + b)</code> - расширение предыдущего селектора через указание номера потомка
                формулой, где <code>a, b</code> - константы, а под <code>n</code> подразумевается любое целое число.</p>
                <p>Этот псевдокласс будет фильтровать все элементы, которые попадают под формулу при каком-либо
                <code>n</code>. Например, - <code>:nth-child(2n)</code> даст элементы номер <code>2</code>,
                <code>4</code>, <code>6</code>..., то есть четные.</p>
                <ul>
                    <li>
                        <p><code>:nth-child(2n + 1)</code> даст элементы номер <code>1</code>, <code>3</code>...,
                        то есть нечетные.</p>
                    </li>
                    <li>
                        <p><code>:nth-child(3n + 2)</code> даст элементы номер <code>2</code>, <code>5</code>,
                        <code>8</code> и так далее.</p>
                    </li>
                </ul>
            </li>
        </ul>
        <p>Пример использования для выделения в списке:</p>
        <div class="example">
            <ul id="russian">
                <li>Древнерусский язык</li>
                <li>Древненовгородский диалект <span class="span_selector">li:nth-child(2n)</span></li>
                <li>Западнорусский письменный язык <span class="span_selector">li:nth-child(3)</span></li>
                <li>Украинский язык <span class="span_selector">li:nth-child(2n)</span></li>
                <li>Белорусский язык</li>
                <li>Другие языки <span class="span_selector">li:nth-child(2n)</span></li>
            </ul>
        </div>
<pre><code class="language-css">li:nth-child(2n) { /* Четные */
    background: #eee;
}

li:nth-child(3) { /* Третий потомок */
    color: red;
}</code></pre>
        <ul>
            <li>
                <p><code>:nth-last-child(a)</code>, <code>:nth-last-child(an + b)</code> - то же самое, но отсчет
                начинается с конца, например, <code>:nth-last-child(2)</code> - второй элемент с конца.</p>
            </li>
        </ul>
    </article>

    <article>
        <h2>Фильтр по месту среди соседей с тем же тегом</h2>
        <p>Есть аналогичные псевдоклассы, которые учитывают не всех соседей, а только с тем же тегом:</p>
        <ul>
            <li>
                <p><code>:first-of-type</code></p>
            </li>
            <li>
                <p><code>:last-of-type</code></p>
            </li>
            <li>
                <p><code>:only-of-type</code></p>
            </li>
            <li>
                <p><code>:nth-of-type</code></p>
            </li>
            <li>
                <p><code>:nth-last-of-type</code></p>
            </li>
        </ul>
        <p>Они имеют в точности тот же смысл, что и обычные <code>:first-child</code>, <code>:last-child</code> и так
        далее, но во время подсчета игнорируют элементы с другими тегами, чем тот, к которому применяется фильтр.</p>
        <p>Пример использования для раскраски списка <code>dt</code> «через один» и предпоследнего <code>dd</code>:</p>
        <div class="example">
            <dl id="definitions">
                <dt>Первый dt</dt>
                <dd>Описание dd</dd>

                <dt>Второй dt <span class="span_selector">dt:nth-of-type(2n)</span></dt>
                <dd>Описание dd</dd>

                <dt>Третий dt</dt>
                <dd>Описание dd <span class="span_selector">dd:nth-last-of-type(2)</span></dd>

                <dt>Четвертый dt <span class="span_selector">dt:nth-of-type(2n)</span></dt>
                <dd>Описание dd</dd>
            </dl>
        </div>
<pre><code class="language-css">dt:nth-of-type(2n) {
    /* Четные dt (соседи с другими тегами игнорируются) */
    background: #eee;
}

dd:nth-last-of-type(2) {
    /* Второй dd снизу */
    color: red;
}</code></pre>
        <p>Как видим, селектор <code>dt:nth-of-type(2n)</code> выбрал каждый второй элемент <code>dt</code>, причем
        другие элементы (<code>dd</code>) в подсчетах не участвовали.</p>
    </article>

    <article>
        <h2>Селекторы атрибутов</h2>
        <p>На атрибут целиком:</p>
        <ul>
            <li>
                <p><code>[attr]</code> - атрибут установлен.</p>
            </li>
            <li>
                <p><code>[attr="val"]</code> - атрибут равен <code>val</code>.</p>
            </li>
        </ul>
        <p>На начало атрибута:</p>
        <ul>
            <li>
                <p><code>[attr^="val"]</code> - атрибут начинается с <code>val</code>, например, <code>value</code>.</p>
            </li>
            <li>
                <p><code>[attr|="val"]</code> - атрибут равен <code>val</code> <i>или</i> начинается с <code>val-</code>,
                например, равен <code>val-1</code>.</p>
            </li>
        </ul>
        <p>На содержание:</p>
        <ul>
            <li>
                <p><code>[attr*="val"]</code> - атрибут содержит подстроку <code>val</code>, например, равен <code>myvalue</code>.</p>
            </li>
            <li>
                <p><code>[attr~="val"]</code> - атрибут содержит <code>val</code> как одно из значений через пробел.</p>
            </li>
        </ul>
        <p>Например: <code>[attr~="delete"]</code> верно для <code>"edit delete"</code> и неверно для
        <code>"undelete"</code> или <code>"no-delete"</code>.</p>
        <p>На конец атрибута:</p>
        <ul>
            <li>
                <p><code>[attr$="val"]</code> - атрибут заканчивается на <code>val</code>, например, равен <code>myval</code>.</p>
            </li>
        </ul>
    </article>

    <article>
        <h2>Другие псевдоклассы</h2>
        <ul>
            <li>
                <p><code>:not(селектор)</code> - все, кроме подходящих под селектор.</p>
            </li>
            <li>
                <p><code>:focus</code> - в фокусе.</p>
            </li>
            <li>
                <p><code>:hover</code> - под мышью.</p>
            </li>
            <li>
                <p><code>:empty</code> - без детей (даже без текстовых).</p>
            </li>
            <li>
                <p><code>:checked</code>, <code>:disabled</code>, <code>:enabled</code> - состояния <code>input</code>.</p>
            </li>
            <li>
                <p><code>:target</code> - этот фильтр сработает для элемента, <code>id</code> которого совпадает
                с анкором <code>#...</code> текущего URL.</p>
                <p>Например, если на странице есть элемент с <code>id="intro"</code>, то правило:
                <code>:target { color: red }</code> подсветит его в том случае, если текущий URL имеет вид
                <code>https://...#intro</code>.</p>
            </li>
        </ul>
    </article>

    <article>
        <h2>Псевдоэлементы ::before, ::after</h2>
        <p>«Псевдоэлементы» - различные вспомогательные элементы, которые браузер записывает или может записать в
        документ.</p>
        <p>При помощи <i>псевдоэлементов</i> <code>::before</code> и <code>::after</code> можно добавлять содержимое
        в начало и конец элемента:</p>
<pre><code class="language-html">&lt;style&gt;
    li::before {
        content: " [[ ";
    }

    li::after {
        content: " ]] ";
    }
&lt;/style&gt;

Обратите внимание: содержимое добавляется &lt;b&gt;внутрь&lt;/b&gt; li.

&lt;ul&gt;
    &lt;li&gt;Первый элемент&lt;/li&gt;
    &lt;li&gt;Второй элемент&lt;/li&gt;
&lt;/ul&gt;</code></pre>
        <div class="example pseudo-elements">
            Обратите внимание: содержимое добавляется <b>внутрь</b> li.

            <ul>
                <li>Первый элемент</li>
                <li>Второй элемент</li>
            </ul>
        </div>
        <p>Псевдоэлементы <code>::before</code>/<code>::after</code> добавили содержимое в начало и конец каждого
        <code>li</code>.</p>
    </article>
</body>
</html>